RobloxReplicatedStorage = game:GetService('RobloxReplicatedStorage')
RbxAnalyticsService = game:GetService('RbxAnalyticsService')
ReplicatedStorage = game:GetService('ReplicatedStorage')
UserInputService = game:GetService('UserInputService')
NetworkClient = game:GetService("NetworkClient")
TweenService = game:GetService('TweenService')
VirtualUser = game:GetService('VirtualUser')
HttpService = game:GetService('HttpService')
RunService = game:GetService('RunService')
LogService = game:GetService('LogService')
Lighting = game:GetService('Lighting')
CoreGui = game:GetService('CoreGui')
Players = game:GetService('Players')
Debris = game:GetService('Debris')
Stats = game:GetService('Stats')
CollectionService = game:GetService("CollectionService")
VirtualInputManager = game:GetService("VirtualInputManager")
Workspace = game:GetService('Workspace')
ContentProvider = game:GetService("ContentProvider")


local WindUI
local success, err = pcall(function()
    -- Coba memuat dari repo utama
    WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
end)

if not success then
    WindUI:Notify({
        Title = "WindUI Error",
        Content = "Failed to load WindUI: " .. tostring(err),
        Duration = 10,
        Icon = "alert-triangle"
    })
    return -- Hentikan eksekusi jika UI gagal dimuat
end

if not game:IsLoaded() then
    game.Loaded:Wait()
end

do
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/RudertTiktok/VICLIB/refs/heads/main/VICNOTIFY", true))()

local success, result = pcall(function()
    loadstring(game:GetObjects("rbxassetid://15900013841")[1].Source)()
end)
if not success then
    Notification.new("error", "Error", "Bypass Not Successfully Loaded!?", true, 3)
else
    Notification.new("success", "Success", "Bypass Successfully Loaded!", true, 3)
end


wait(1)

Notification.new("info", "ATTENTION", "Yo User! Thanks for using my Script! ", true, 3)
Notification.new("info", "ATTENTION", "dont expect this script good or not. ", true, 3)
Notification.new("info", "ATTENTION", "By Rudert (SOLO DEV)", true, 4.5)
Notification.new("info", "ATTENTION", "Reizo is Sigma + NonChalant + Charm + Nigger", true, 4.5)
end

local LocalPlayer = Players.LocalPlayer

setfpscap(120)


local SelectedParryMethod = "Hook"

local Config = {       
    -- Fitur lama
    plushie_enabled = false, 
    plushie_type = "Miku", 
    visual_ring = false,    
    manual_spam = false, 
    auto_parry = true,
    auto_spam_parry = true,
    auto_parry_rotation = false,
    lobby_auto_parry = true,
    auto_parry_rotation_acuity = 5,
    curve_method = "Normal",
    no_slow = false,
    no_render = false,
    smart_no_render = false,
    sound_effect_enabled = false,
    night_mode = false,
    strafe = false, -- Pastikan ini ada
    strafe_speed = 50,
    personnel_detector = false,
    personnel_detector_auto_leave = true,
    auto_particles = false,
    screen_enabled = true,
    field = false,
    field_of_view = 0,
    camera = false,
    ability_vulnerability = true,
    mode = "Quad Jump",
    animations = false,
    smart_animations = false,
    animation_type = "None",
    ai_play = false,
    ai_method = "AdvancedPro",    
    ball_text_enabled = false,
    player_text_enabled = false,
    enableSlashFX = true,
    swordModel = "",
    swordAnimations = "",
    swordFX = "",
    plushieEnabled = false,
    plushieType = "",
    visualize_Enabled = false,
    visuals_enabled = true,
    player_follow = false,
    follow_target = nil, 
    color_shift = false, 
    shaders = false, 
    shaders_intensity = 150, 
    shaders_size = 78.54, 
    shaders_threshold = 236.25, 
    environment_specular_scale = 50, 
    environment_diffuse_scale = 50, 
    ray_tracing = false, 
    ambient = false, 
    ambient_density = 50,   
    disable_quantum_effects = false,
    auto_rewards = false, 
    slashes_of_fury_enabled = false, 
    slashes_of_fury_mode = "Blatant", 
    visualize = true, -- Pastikan ini ada
    triggerbot = false, -- Pastikan ini ada
    ping_booster = false, 
    self_effect = true,
    self_effect_selected = "Magic Circle", 
    kill_effect = false, 
    ball_trail_enabled = false,
    ball_trail_color = Color3.fromRGB(255, 0, 0),
    player_trail_enabled = false,
    player_trail_color = Color3.fromRGB(0, 255, 255),
    trail_particle_enabled = false,
    trail_particle_rate = 10,
    trail_animation_type = "Pulse",
    trail_texture = "None",
    kill_effect_scale = 1,
    kill_effect_animation = "Spiral", 
    plasma_trails_enabled = false, -- Pastikan ini ada
    plasma_trails_count = 8,
    plasma_trails_color = Color3.fromRGB(0, 255, 255),
    plasma_rainbow_mode = false, 
    self_effect_type = "Magic Circle",
    self_effect_color = Color3.fromRGB(0, 255, 255),
    self_effect_size = 5,
    self_effect_speed = 1,
    custom_sky = false, -- Pastikan ini ada
    custom_sky_selector = "Default", -- Pastikan ini ada
    gravity = false, -- Pastikan ini ada
    gravity_strength = 50, -- Pastikan ini ada
    spam_speed = 13, -- Pastikan ini ada   
}

if getgenv and type(getgenv) == "function" then
    pcall(function()
        getgenv().Config = Config
    end)
else
    warn("getgenv() not supported by this executor. Using local Config. [Bro I Said U Have To Use High Unc]")
end
 

-- Check if getgenv exists and is a function
if getgenv and type(getgenv) == "function" then
    pcall(function()
        -- Assign all top-level variables to getgenv with their original names
        getgenv().AIPlaying = false
        getgenv().AICoroutine = nil
        getgenv().AITarget = nil
        getgenv().AICurrentMethod = "AdvancedPro"
        getgenv().AIStuckCheck = {
            lastPosition = Vector3.new(),
            checkTime = 0,
            stuckDuration = 0
        }
        getgenv().AICooldowns = {
            jump = 0,
            dash = 0,
            targetSwitch = 0,
            action = 0
        }
        getgenv().BallTrail = nil
        getgenv().PlayerTrail = nil
        getgenv().TrailConnection = nil
        getgenv().lastTrailUpdateTime = 0
        getgenv().BallBillboard = nil
        getgenv().PlayerBillboard = nil
        getgenv().lastUpdateTime = 0
        getgenv().ballBillboardEnabled = false
        getgenv().playerBillboardEnabled = false
        getgenv().AutoPlayModule = {
            CONFIG = {
                DEFAULT_DISTANCE = 30,
                MULTIPLIER_THRESHOLD = 70,
                TRAVERSING = 25,
                DIRECTION = 1,
                JUMP_PERCENTAGE = 50,
                DOUBLE_JUMP_PERCENTAGE = 50,
                JUMPING_ENABLED = false,
                MOVEMENT_DURATION = 0.8,
                OFFSET_FACTOR = 0.7,
                GENERATION_THRESHOLD = 0.25
            },
            ball = nil,
            lobbyChoice = nil,
            animationCache = nil,
            doubleJumped = false,
            ELAPSED = 0,
            CONTROL_POINT = nil,
            LAST_GENERATION = 0,
            signals = {}
        }
        getgenv().updateBillboardText = nil
        getgenv().TargetSelectionMethod = "ClosestToCursor"
        getgenv().RunTime = workspace.Runtime
        getgenv().Alive = workspace.Alive
        getgenv().Dead = workspace.Dead
        getgenv().AutoParry = {
            ball = {
                training_ball_entity = nil,
                client_ball_entity = nil,
                ball_entity = nil,
                properties = {
                    aero_dynamic_time = tick(),
                    hell_hook_completed = true,
                    last_position = Vector3.zero,
                    rotation = Vector3.zero,
                    position = Vector3.zero,
                    last_warping = tick(),               
                    is_curveds = false,
                    is_curved = false,
                    last_tick = tick(),
                    auto_spam = false,
                    cooldown = false,
                    respawn_time = 0,
                    parry_range = 1,
                    spam_range = 0,        
                    maximum_speed = 0,
                    old_speed = 0,
                    parries = 0,
                    direction = 0,
                    distance = 0,
                    velocity = 0,
                    last_hit = 0,
                    lerp_radians = 0,
                    radians = 0,
                    speed = 0,
                    prev_speed = 0,
                    dot = 0,
                    curve_history = {}
                }
            },
            target = {
                current = nil,
                current_changed = false,  
                direction_changed_on_cframe = false,
                from = nil,
                aim = nil,
            },
            entity_properties = {
                server_position = Vector3.zero,
                velocity = Vector3.zero,
                is_moving = false,
                direction = 0,
                distance = 0,
                speed = 0,
                dot = 0
            }
        }
        getgenv().Player = {
            Entity = {
                properties = {
                    sword = '',
                    server_position = Vector3.zero,
                    velocity = Vector3.zero,
                    position = Vector3.zero,
                    is_moving = false,
                    is_moving_backwards = false,
                    speed = 0,
                    ping = 0
                }
            },
            properties = {
                grab_animation = nil
            }
        }
        getgenv().World = {}
        getgenv().parry_mode = "Blatant"
        getgenv().auto_farm_enabled = false
        getgenv().auto_farm_type = "Random Orbit"
        getgenv().auto_farm_orbit = 5
        getgenv().auto_farm_height = 10
        getgenv().auto_farm_radius = 20
        getgenv().cameraViewMode = "ThirdPerson"
        getgenv().Camera = Workspace.CurrentCamera
        getgenv().visualizerEnabled = false
        getgenv().cameraLocked = false
        getgenv().cameraConnection = nil
    end)
else
    warn("getgenv() not supported by this executor. Using local variables. [Bro I Said U Have To Use High Unc]")
end


local AIPlaying = false
local AICoroutine = nil
local AITarget = nil
local AICurrentMethod = "AdvancedPro"
local AIStuckCheck = {
    lastPosition = Vector3.new(),
    checkTime = 0,
    stuckDuration = 0
}
local AICooldowns = {
    jump = 0,
    dash = 0,
    targetSwitch = 0,
    action = 0
}

-- Trail Management
local BallTrail = nil
local PlayerTrail = nil
local TrailConnection = nil
local lastTrailUpdateTime = 0 -- For throttling updates

local BallBillboard = nil
local PlayerBillboard = nil
local lastUpdateTime = 0

local ballBillboardEnabled = false
local playerBillboardEnabled = false

local AutoPlayModule = {}
    AutoPlayModule.CONFIG = {
        DEFAULT_DISTANCE = 30,
        MULTIPLIER_THRESHOLD = 70,
        TRAVERSING = 25,
        DIRECTION = 1,
        JUMP_PERCENTAGE = 50,
        DOUBLE_JUMP_PERCENTAGE = 50,
        JUMPING_ENABLED = false,
        MOVEMENT_DURATION = 0.8,
        OFFSET_FACTOR = 0.7,
        GENERATION_THRESHOLD = 0.25
    }
    
    AutoPlayModule.ball = nil
    AutoPlayModule.lobbyChoice = nil
    AutoPlayModule.animationCache = nil
    AutoPlayModule.doubleJumped = false
    AutoPlayModule.ELAPSED = 0
    AutoPlayModule.CONTROL_POINT = nil
    AutoPlayModule.LAST_GENERATION = 0
    AutoPlayModule.signals = {}

local updateBillboardText = nil

local TargetSelectionMethod = "ClosestToCursor"

local RunTime = workspace.Runtime
local Alive = workspace.Alive
local Dead = workspace.Dead

local AutoParry = {
    ball = nil,
    target = nil,
    entity_properties = nil
}

local Player = {
    Entity = nil,
    properties = {
        grab_animation = nil
    }
}

Player.Entity = {
    properties = {
        sword = '',
        server_position = Vector3.zero,
        velocity = Vector3.zero,
        position = Vector3.zero,
        is_moving = false,
        is_moving_backwards = false,
        speed = 0,
        ping = 0
    }
}

local World = {}

AutoParry.ball = {
    training_ball_entity = nil,
    client_ball_entity = nil,
    ball_entity = nil,
    properties = {
        aero_dynamic_time = tick(),
        firstParryFired = false,
        hell_hook_completed = true,
        last_position = Vector3.zero,
        rotation = Vector3.zero,
        position = Vector3.zero,
        last_warping = tick(),    
        curve_chance = 0,           
        is_curveds = false,
        is_curved = false,
        last_tick = tick(),
        auto_spam = false,
        cooldown = false,
        respawn_time = 0,
        parry_range = 1,
        spam_range = 0,        
        maximum_speed = 0,
        old_speed = 0,
        parries = 0,
        direction = 0,
        distance = 0,
        velocity = 0,
        last_hit = 0,
        lerp_radians = 0,
        prev_radians = 0,
        radians = 0,
        speed = 0,
        prev_speed = 0,
        dot = 0,
        curve_history = {}
    }
}

AutoParry.target = {
    current = nil,
    current_changed = false,  
    direction_changed_on_cframe = false,
    from = nil,
    aim = nil,
}

AutoParry.entity_properties = {
    server_position = Vector3.zero,
    velocity = Vector3.zero,
    is_moving = false,
    direction = 0,
    distance = 0,
    speed = 0,
    dot = 0
}


local parry_mode = "Blatant"
local auto_farm_enabled = false
local auto_farm_type = "Random Orbit"
local auto_farm_orbit = 5
local auto_farm_height = 10
local auto_farm_radius = 20
local cameraViewMode = "ThirdPerson"
local Camera = Workspace.CurrentCamera
local visualizerEnabled = false
local cameraLocked = false
local cameraConnection = nil




getgenv().AnimationsEnabled = false
getgenv().BallDirectionIndicator = true
getgenv().speeddo = 13
getgenv().WorldFilterEnabled = false
getgenv().AtmosphereEnabled = false
getgenv().FogEnabled = false
getgenv().SaturationEnabled = false
getgenv().HueEnabled = false
getgenv().skinChanger = false
getgenv().swordModel = ""
getgenv().swordAnimations = ""
getgenv().swordFX = ""

local skyboxData = {
    ["Default"] = {"591058823", "591059876", "591058104", "591057861", "591057625", "591059642"},
    ["Vaporwave"] = {"1417494030", "1417494146", "1417494253", "1417494402", "1417494499", "1417494643"},
    ["Redshift"] = {"401664839", "401664862", "401664960", "401664881", "401664901", "401664936"},
    ["Desert"] = {"1013852", "1013853", "1013850", "1013851", "1013849", "1013854"},
    ["DaBaby"] = {"7245418472", "7245418472", "7245418472", "7245418472", "7245418472", "7245418472"},
    ["Minecraft"] = {"1876545003", "1876544331", "1876542941", "1876543392", "1876543764", "1876544642"},
    ["SpongeBob"] = {"7633178166", "7633178166", "7633178166", "7633178166", "7633178166", "7633178166"},
    ["Skibidi"] = {"14952256113", "14952256113", "14952256113", "14952256113", "14952256113", "14952256113"},
    ["Blaze"] = {"150939022", "150939038", "150939047", "150939056", "150939063", "150939082"},
    ["Pussy Cat"] = {"11154422902", "11154422902", "11154422902", "11154422902", "11154422902", "11154422902"},
    ["Among Us"] = {"5752463190", "5752463190", "5752463190", "5752463190", "5752463190", "5752463190"},
    ["Space Wave"] = {"16262356578", "16262358026", "16262360469", "16262362003", "16262363873", "16262366016"},
    ["Space Wave2"] = {"1233158420", "1233158838", "1233157105", "1233157640", "1233157995", "1233159158"},
    ["Turquoise Wave"] = {"47974894", "47974690", "47974821", "47974776", "47974859", "47974909"},
    ["Dark Night"] = {"6285719338", "6285721078", "6285722964", "6285724682", "6285726335", "6285730635"},
    ["Bright Pink"] = {"271042516", "271077243", "271042556", "271042310", "271042467", "271077958"},
    ["White Galaxy"] = {"5540798456", "5540799894", "5540801779", "5540801192", "5540799108", "5540800635"},
    ["Blue Galaxy"] = {"14961495673", "14961494492", "14961492844", "14961491298", "14961490439", "14961489508"}
}


local soundOptions = {
    ["back it up"] = "rbxassetid://16190782181",
    ["Sweep"] = "rbxassetid://103508936658553",
    ["Bounce"] = "rbxassetid://134818882821660",
    ["Everybody Wants To Rule The World"] = "rbxassetid://87209527034670",
    ["Missing Money"] = "rbxassetid://134668194128037",
    ["Sour Grapes"] = "rbxassetid://117820392172291",
    ["Erwachen"] = "rbxassetid://124853612881772",
    ["Grasp the Light"] = "rbxassetid://89549155689397",
    ["Beyond the Shadows"] = "rbxassetid://120729792529978",
    ["Rise to the Horizon"] = "rbxassetid://72573266268313",
    ["Echoes of the Candy Kingdom"] = "rbxassetid://103040477333590",
    ["Speed"] = "rbxassetid://125550253895893",
    ["Lo-fi Chill A"] = "rbxassetid://9043887091",
    ["Lo-fi Ambient"] = "rbxassetid://129775776987523",
    ["Tears in the Rain"] = "rbxassetid://129710845038263"
}

local currentSound = Instance.new("Sound")
currentSound.Name = "BackgroundMusic"
currentSound.Volume = 2
currentSound.Looped = false
currentSound.Parent = game:GetService("SoundService")

local selectedSound = "back it up"
local MarketplaceService = game:GetService("MarketplaceService")

-- Validasi Sound ID
local function isValidSoundId(soundId)
    local success, info = pcall(function()
        local id = string.match(soundId, "%d+")
        if not id then return false end
        local assetInfo = MarketplaceService:GetProductInfo(id)
        return assetInfo.AssetTypeId == 3
    end)
    return success and info
end

-- Play Sound (adaptasi playSoundById)
local function playSound()
    local soundId = soundOptions[selectedSound]
    if not soundId then
        WindUI:Notify({
            Title = "Music Error",
            Content = "No sound ID for " .. selectedSound,
            Duration = 5,
            Icon = "warning"
        })
        return
    end
    if isValidSoundId(soundId) then
        currentSound:Stop()
        currentSound.SoundId = soundId
        currentSound:Play()
        WindUI:Notify({
            Title = "Background Music",
            Content = "Playing " .. selectedSound,
            Duration = 5,
            Icon = "music"
        })
    else
        WindUI:Notify({
            Title = "Music Error",
            Content = "Failed to load " .. selectedSound .. " (Invalid or Unreviewed)",
            Duration = 5,
            Icon = "warning"
        })
    end
end

local CURVE_HISTORY_SIZE = 5

-- Skin Changer System (Fixed with all 4 toggles)
if getgenv().updateSword and getgenv().skinChanger then
    getgenv().updateSword()
    return
end

-- Initialize semua toggles jika belum ada
if getgenv().changeSwordModel == nil then getgenv().changeSwordModel = true end
if getgenv().changeSwordAnimation == nil then getgenv().changeSwordAnimation = true end
if getgenv().changeSwordFX == nil then getgenv().changeSwordFX = true end

local swordInstancesInstance = ReplicatedStorage:WaitForChild("Shared", 9e9):WaitForChild("ReplicatedInstances", 9e9):WaitForChild("Swords", 9e9)
local swordInstances = require(swordInstancesInstance)

local swordsController
while task.wait() and (not swordsController) do
    for i, v in getconnections(ReplicatedStorage.Remotes.FireSwordInfo.OnClientEvent) do
        if v.Function and islclosure(v.Function) then
            local upvalues = getupvalues(v.Function)
            if #upvalues == 1 and type(upvalues[1]) == "table" then
                swordsController = upvalues[1]
                break
            end
        end
    end
end

local function getSlashName(swordName)
    local slashName = swordInstances:GetSword(swordName)
    return (slashName and slashName.SlashName) or "SlashEffect"
end

local function setSword()
    if not getgenv().skinChanger then return end
    
    setupvalue(rawget(swordInstances, "EquipSwordTo"), 3, false)
    
    
    if getgenv().changeSwordModel then
        swordInstances:EquipSwordTo(LocalPlayer.Character, getgenv().swordModel)
    end
    
    
    if getgenv().changeSwordAnimation then
        swordsController:SetSword(getgenv().swordAnimations)
    end
end

local playParryFunc
local parrySuccessAllConnection
while task.wait() and not parrySuccessAllConnection do
    for i, v in getconnections(ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent) do
        if v.Function and getinfo(v.Function).name == "parrySuccessAll" then
            parrySuccessAllConnection = v
            playParryFunc = v.Function
            v:Disable()
        end
    end
end

local parrySuccessClientConnection
while task.wait() and not parrySuccessClientConnection do
    for i, v in getconnections(ReplicatedStorage.Remotes.ParrySuccessClient.Event) do
        if v.Function and getinfo(v.Function).name == "parrySuccessAll" then
            parrySuccessClientConnection = v
            v:Disable()
        end
    end
end

getgenv().slashName = getSlashName(getgenv().swordFX)

local lastOtherParryTimestamp = 0
local clashConnections = {}

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(...)
    setthreadidentity(2)
    local args = {...}
    if tostring(args[4]) ~= LocalPlayer.Name then
        lastOtherParryTimestamp = tick()
    elseif getgenv().skinChanger and getgenv().changeSwordFX then  -- PERUBAHAN PENTING DI SINI!
        args[1] = getgenv().slashName
        args[3] = getgenv().swordFX
    end
    return playParryFunc(unpack(args))
end)

table.insert(clashConnections, getconnections(ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent)[1])

getgenv().updateSword = function()
    
    if getgenv().changeSwordFX then
        getgenv().slashName = getSlashName(getgenv().swordFX)
    end
    setSword()
end

task.spawn(function()
    while task.wait(1) do
        if getgenv().skinChanger and getgenv().changeSwordModel then
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            if LocalPlayer:GetAttribute("CurrentlyEquippedSword") ~= getgenv().swordModel then
                setSword()
            end
            if char and (not char:FindFirstChild(getgenv().swordModel)) then
                setSword()
            end
            for _, v in (char and char:GetChildren()) or {} do
                if v:IsA("Model") and v.Name ~= getgenv().swordModel then
                    v:Destroy()
                end
                task.wait()
            end
        end
    end
end)

local MainRemote = nil
local HashOne, HashTwo, HashThree = nil
local Parry_Key = nil
local PropertyChangeOrder = {}

if not LPH_OBFUSCATED then
    function LPH_JIT(Function) return Function end
    function LPH_JIT_MAX(Function) return Function end
    function LPH_NO_VIRTUALIZE(Function) return Function end
end


LPH_NO_VIRTUALIZE(function()
    local success, err = pcall(function()
        for _, Object in next, game:GetDescendants() do
            if Object:IsA("RemoteEvent") and string.find(Object.Name, "\n") then
                Object.Changed:Once(function()
                    table.insert(PropertyChangeOrder, Object)
                end)
            end
        end
    end)
end)()

local startTime = tick()
repeat
    task.wait()
    if tick() - startTime > 10 then
        break
    end
until #PropertyChangeOrder >= 3

if #PropertyChangeOrder >= 3 then
    ShouldPlayerJump = PropertyChangeOrder[1]
    MainRemote = PropertyChangeOrder[2]
    GetOpponentPosition = PropertyChangeOrder[3]
end

local success, err = pcall(function()
    for _, Value in pairs(getconnections(game:GetService("Players").LocalPlayer.PlayerGui.Hotbar.Block.Activated)) do
        if Value and Value.Function and not iscclosure(Value.Function) then
            for _, Value2 in pairs(getupvalues(Value.Function)) do
                if type(Value2) == "function" then
                    Parry_Key = getupvalue(getupvalue(Value2, 2), 17)
                    break
                end
            end
        end
    end
end)

print("Parry_Key:", Parry_Key)
print("MainRemote:", MainRemote)
print("PropertyChangeOrder:", PropertyChangeOrder)

local revertedRemotes = {}
local originalMetatables = {}

local function isValidRemoteArgs(args)
    return #args == 7 and
           type(args[2]) == "string" and  
           type(args[3]) == "number" and 
           typeof(args[4]) == "CFrame" and 
           type(args[5]) == "table" and  
           type(args[6]) == "table" and 
           type(args[7]) == "boolean"
end

local function hookRemote(remote)
    if not revertedRemotes[remote] then
        local meta = getrawmetatable(remote)
        if not originalMetatables[meta] then
            originalMetatables[meta] = true  
            setreadonly(meta, false)  

            local oldIndex = meta.__index
            meta.__index = function(self, key)
                if key == "FireServer" and self:IsA("RemoteEvent") then
                    return function(_, ...)
                        local args = { ... }
                        if isValidRemoteArgs(args) then
                            if not revertedRemotes[self] then
                                revertedRemotes[self] = args
                            end
                        end
                        return oldIndex(self, "FireServer")(_, table.unpack(args))
                    end
                elseif key == "InvokeServer" and self:IsA("RemoteFunction") then
                    return function(_, ...)
                        local args = { ... }
                        if isValidRemoteArgs(args) then
                            if not revertedRemotes[self] then
                                revertedRemotes[self] = args
                                print("Hooked RemoteFunction:", self.Name)
                            end
                        end
                        return oldIndex(self, "InvokeServer")(_, table.unpack(args))
                    end
                end
                return oldIndex(self, key)
            end

            setreadonly(meta, true)
        end
    end
end

local function restoreRemotes()
    for remote, _ in pairs(revertedRemotes) do
        if originalMetatables[getmetatable(remote)] then
            local meta = getrawmetatable(remote)
            setreadonly(meta, false)
            meta.__index = nil
            setreadonly(meta, true)
        end
    end
    revertedRemotes = {}
end

for _, remote in pairs(game.ReplicatedStorage:GetChildren()) do
    if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
        hookRemote(remote)
    end
end

game.ReplicatedStorage.ChildAdded:Connect(function(child)
    if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
        hookRemote(child)
    end
end)

function gradient(text, startColor, endColor)
    local result = ""
    local length = #text

    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end

    return result
end

local Confirmed = false

WindUI:Popup({
    Title = "VicoXBladeBall (Premium-Moderate)",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Content = "Welcome VicoMem!" .. gradient("\nVicoX", Color3.fromHex("#00FF87"), Color3.fromHex("#60EFFF")) .. "\n#1 On Top..",
    Buttons = {
        {
            Title = "Cancel",
            Icon = "sword",
            Callback = function() end,
            Variant = "Primary",
        },
        {
            Title = "Continue",
            Icon = "arrow-right",
            Callback = function() Confirmed = true end,
            Variant = "Tertiary",
        }
    }
})

repeat wait() until Confirmed


local Window = WindUI:CreateWindow({
    Title = "VicoX",
    Author = "Rudert",
    Folder = "VicoXAmbatublow", 
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    
    
    Topbar = {
        Height = 44, 
        ButtonsType = "Mac", 
    },


    OpenButton = {
        Title = "VicoX", -- Teks di tombol
        Icon = "swords", -- Ikon (bisa string atau rbxassetid)
        CornerRadius = UDim.new(0, 12), -- Sudut melengkung
        StrokeThickness = 2, -- Ketebalan garis luar
        Enabled = true, -- Apakah tombol aktif?
        Draggable = true, -- Bisa diseret?
        OnlyMobile = false, -- Hanya muncul di mobile?
        Scale = 0.5, -- Ukuran tombol (0.5 = 50%)
        Color = ColorSequence.new( -- Warna gradien tombol
            Color3.fromHex("#FF0000"), -- Warna awal (Merah)
            Color3.fromHex("#FFFF00")  -- Warna akhir (Kuning)
        )
    },
    

    OnOpen = function()
        WindUI:Notify({
            Title = "VicoX UI",
            Content = "UI opened. Good luck!",
            Duration = 2,
            Icon = "eye"
        })
    end,

    
    KeySystem = {
        Key = { "Testing-You", "OnlyOwnerWhoKnows" },
        Note = "Key Is = Testing-You. Don't Worry Just.. Put it And Play As You Want.",
        Thumbnail = {
            Image = "rbxassetid://18220445082",
            Title = "#BladeBall \n\n#VicoXOnTop"
        },
        URL = "https://discord.gg/pbUCMc8VFs",
        SaveKey = true,
    },
})

-- Gunakan fitur baru: Tag di pojok kanan atas
Window:Tag({
    Title = "v" .. WindUI.Version, -- Menampilkan versi WindUI
    Icon = "github",
    Color = Color3.fromHex("#1c1c1c"),
    Border = true,
})

local ConfigManager = Window.ConfigManager
local ConfigName = "VicoX_Default"
local CurrentConfig = ConfigManager:Config(ConfigName)
Window.CurrentConfig = CurrentConfig

local AllConfigs = ConfigManager:AllConfigs()
local ConfigExists = table.find(AllConfigs, ConfigName) ~= nil

if ConfigExists then
    CurrentConfig:Load()
    WindUI:Notify({...})
    
    
    pcall(function()
        if CurrentConfig.Flags and type(CurrentConfig.Flags) == "table" then
            for flag, value in pairs(CurrentConfig.Flags) do
                if Config[flag] ~= nil then 
                    Config[flag] = value
                end
            end
        end
    end)
end
CurrentConfig:SetAutoLoad(true)

local function SaveConfig()
    if CurrentConfig:Save() then
        WindUI:Notify({
            Title = "Config Saved",
            Content = "Updated: " .. ConfigName,
            Duration = 2,
            Icon = "check"
        })
    end
end

Window:EditOpenButton({
    Title = "VicoX",
    Icon = "swords",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("#FF0000"), Color3.fromHex("#FFFF00")),
    Draggable = true,
})

local Tabs = {
    Home = Window:Tab({ Title = "Home", Icon = "wind", Desc = "Homies Dayum" }),
    Special = Window:Tab({ Title = "Special", Icon = "clipboard", Desc = "A special Function For you!" }), 
    Blatant = Window:Tab({ Title = "Blatant", Icon = "swords", Desc = "Gain in Blade Ball!" }),
    Visuals = Window:Tab({ Title = "Visuals", Icon = "eye", Desc = "Enhance your Blade Ball visuals." }),
    Worlds = Window:Tab({ Title = "Worlds", Icon = "cloud", Desc = "World Change your mode Visuals." }),    
    Misc = Window:Tab({ Title = "Misc", Icon = "settings", Desc = "Additional Blade Ball utilities." }),
    Players = Window:Tab({ Title = "Players", Icon = "sparkles", Desc = "Player Change set." }),
    Farm = Window:Tab({ Title = "AI", Icon = "bot", Desc = "Automate gameplay with AI." }),
    Settings = Window:Tab({ Title = "Settings", Icon = "leaf", Desc = "Settings." }),
    Config = Window:Tab({ Title = "Config", Icon = "file-cog", Desc = "Save and load your Blade Ball settings." }),
    Theme = Window:Tab({ Title = "Theme", Icon = "palette", Desc = "Customize your UI." }),
    Info = Window:Tab({ Title = "Discord Info", Icon = "info", Desc = "Real-time Blade Ball server info." })
}
-- Visited Counter System Fixed
local VisitedSystem = {
    counts = {},
    enabled = true,
    lastTrack = {},
    originalTitles = {},
    lastActiveTab = "Home",
    checkInterval = 0.5,
    lastCheckTime = 0
}

function VisitedSystem:track(tabName)
    if not self.enabled then return end
    
    local currentTime = tick()
    if self.lastTrack[tabName] and (currentTime - self.lastTrack[tabName] < 1) then
        return
    end
    
    self.lastTrack[tabName] = currentTime
    self.counts[tabName] = (self.counts[tabName] or 0) + 1
    self:updateTabTitle(tabName)
    self:save()
    
    print(string.format("[Visited] %s: %d", tabName, self.counts[tabName]))
end

function VisitedSystem:updateTabTitle(tabName)
    if not Tabs[tabName] then return end
    
    local count = self.counts[tabName] or 0
    local originalTitle = self:getOriginalTitle(tabName)
    
    if count > 0 then
        Tabs[tabName].Title = string.format("%s (%d)", originalTitle, count)
    else
        Tabs[tabName].Title = originalTitle
    end
end

function VisitedSystem:getOriginalTitle(tabName)
    if not self.originalTitles[tabName] then
        if Tabs[tabName] and Tabs[tabName].Title then
            local currentTitle = Tabs[tabName].Title
            self.originalTitles[tabName] = string.gsub(currentTitle, "%s*%(%d+%)$", "")
        else
            self.originalTitles[tabName] = tabName
        end
    end
    return self.originalTitles[tabName]
end

function VisitedSystem:save()
    Config.visited_counts = self.counts
    Config.visited_enabled = self.enabled
    SaveConfig()
end

function VisitedSystem:load()
    if Config.visited_counts then
        self.counts = Config.visited_counts
    end
    
    if Config.visited_enabled ~= nil then
        self.enabled = Config.visited_enabled
    end
    
    for tabName, _ in pairs(Tabs) do
        self:getOriginalTitle(tabName)
    end
end

function VisitedSystem:showStats()
    local total = 0
    local mostVisited = {name = "None", count = 0}
    
    local sorted = {}
    for tabName, count in pairs(self.counts) do
        if count > 0 then
            table.insert(sorted, {name = tabName, count = count})
            total = total + count
            if count > mostVisited.count then
                mostVisited.name = tabName
                mostVisited.count = count
            end
        end
    end
    
    table.sort(sorted, function(a, b) return a.count > b.count end)
    
    local statsText = "ðŸ“Š VISITED STATISTICS\n\n"
    statsText = statsText .. string.format("Total Visits: %d\n", total)
    statsText = statsText .. string.format("Most Visited: %s (%dx)\n\n", mostVisited.name, mostVisited.count)
    
    if #sorted > 0 then
        for _, data in ipairs(sorted) do
            statsText = statsText .. string.format("%-12s: %3d\n", data.name, data.count)
        end
    else
        statsText = statsText .. "No visits recorded yet!"
    end
    
    WindUI:Notify({
        Title = "Visited Statistics",
        Content = statsText,
        Duration = 6,
        Icon = "bar-chart"
    })
    
    print("\n" .. statsText)
end

function VisitedSystem:reset()
    self.counts = {}
    self.lastTrack = {}
    
    for tabName, originalTitle in pairs(self.originalTitles) do
        if Tabs[tabName] then
            Tabs[tabName].Title = originalTitle
        end
    end
    
    self:save()
    
    WindUI:Notify({
        Title = "Visited Counter",
        Content = "All visited data has been reset",
        Duration = 3,
        Icon = "refresh-cw"
    })
end

local function setupActiveTabDetection()
    print("[Visited] Setting up active tab detection...")
    
    local function checkActiveTab()
        local activeTabName = nil
        
        for tabName, tab in pairs(Tabs) do
            local success, isSelected = pcall(function()
                return tab.Selected or false
            end)
            
            if success and isSelected then
                activeTabName = tabName
                break
            end
        end
        
        if not activeTabName then
            for tabName, tab in pairs(Tabs) do
                local success, zIndex = pcall(function()
                    return tab.ZIndex or 0
                end)
                
                if success and zIndex > 100 then
                    activeTabName = tabName
                    break
                end
            end
        end
        
        return activeTabName or VisitedSystem.lastActiveTab
    end
    
    RunService.Heartbeat:Connect(function()
        if not VisitedSystem.enabled then return end
        
        local currentTime = tick()
        if currentTime - VisitedSystem.lastCheckTime < VisitedSystem.checkInterval then
            return
        end
        VisitedSystem.lastCheckTime = currentTime
        
        local activeTab = checkActiveTab()
        
        if activeTab and activeTab ~= VisitedSystem.lastActiveTab then
            VisitedSystem.lastActiveTab = activeTab
            VisitedSystem:track(activeTab)
        end
    end)
    
    print("[Visited] Active tab detection running")
end

local function hookTabButtonsDirectly()
    print("[Visited] Hooking tab buttons directly...")
    
    task.spawn(function()
        task.wait(2)
        
        local tabNames = {"Home", "Special", "Blatant", "Visuals", "Worlds", 
                        "Misc", "Players", "Farm", "Settings", "Config", "Theme", "Info"}
        
        for i = 1, 12 do
            local tabName = tabNames[i]
            task.spawn(function()
                local maxAttempts = 10
                for attempt = 1, maxAttempts do
                    local success, tabButton = pcall(function()
                        local path = string.format("Window.Container.Body.Tabs.Tab%d", i)
                        local button = Window:FindFirstChild(path, true)
                        return button
                    end)
                    
                    if success and tabButton then
                        local connection = tabButton.MouseButton1Click:Connect(function()
                            VisitedSystem:track(tabName)
                        end)
                        table.insert(ConnectionsManager, connection)
                        print("[Visited] Direct hooked tab:", tabName)
                        return
                    end
                    
                    task.wait(0.5)
                end
                print("[Visited] Failed to hook tab:", tabName)
            end)
        end
    end)
end

local function setupSimpleTracking()
    print("[Visited] Setting up simple tracking...")
    
    local originalSelectTab = Window.SelectTab
    
    function Window:SelectTab(tabIndexOrName)
        local result = originalSelectTab(self, tabIndexOrName)
        
        task.spawn(function()
            task.wait(0.1)
            
            local tabName
            if type(tabIndexOrName) == "number" then
                local tabNames = {"Home", "Special", "Blatant", "Visuals", "Worlds", 
                                "Misc", "Players", "Farm", "Settings", "Config", "Theme", "Info"}
                tabName = tabNames[tabIndexOrName]
            elseif type(tabIndexOrName) == "string" then
                tabName = tabIndexOrName
            end
            
            if tabName then
                VisitedSystem:track(tabName)
            end
        end)
        
        return result
    end
    
    print("[Visited] Hooked Window.SelectTab")
end

local function createVisitedUI()
    local mainSection = Tabs.Info:Section({
        Title = "ðŸ‘ï¸ Visited Counter",
        Desc = "Track your tab visits",
        Box = true,
        BoxBorder = true,
        Opened = true
    })
    
    mainSection:Toggle({
        Title = "Enable Visited Tracking",
        Flag = "VisitedEnable_SAVE",
        Icon = "activity",
        Value = VisitedSystem.enabled,
        Callback = function(state)
            VisitedSystem.enabled = state
            VisitedSystem:save()
            
            WindUI:Notify({
                Title = "Visited Tracking",
                Content = state and "Enabled" or "Disabled",
                Duration = 2,
                Icon = state and "check" or "x"
            })
        end
    })
    
    mainSection:Divider()
    
    mainSection:Button({
        Title = "ðŸ“Š Show Statistics",
        Icon = "bar-chart",
        Justify = "Center",
        Callback = function()
            VisitedSystem:showStats()
        end
    })
    
    mainSection:Button({
        Title = "ðŸ”„ Refresh All Counts",
        Icon = "refresh-cw",
        Justify = "Center",
        Callback = function()
            for tabName, _ in pairs(Tabs) do
                VisitedSystem:updateTabTitle(tabName)
            end
            WindUI:Notify({
                Title = "Visited Counter",
                Content = "Tab counts refreshed",
                Duration = 2
            })
        end
    })
    
    mainSection:Divider()
    
    mainSection:Section({
        Title = "Manual Tracking",
        Desc = "Click to manually track visits",
        TextSize = 14,
        TextTransparency = 0.3
    })
    
    local tabNames = {"Home", "Special", "Blatant", "Visuals", "Worlds", 
                     "Misc", "Players", "Farm", "Settings", "Config", "Theme", "Info"}
    
    for _, tabName in ipairs(tabNames) do
        mainSection:Button({
            Title = tabName,
            Icon = "plus",
            Callback = function()
                VisitedSystem:track(tabName)
                WindUI:Notify({
                    Title = "Manual Track",
                    Content = "Tracked: " .. tabName,
                    Duration = 1
                })
            end
        })
    end
    
    mainSection:Divider()
    
    mainSection:Button({
        Title = "ðŸ—‘ï¸ Reset All Data",
        Icon = "trash-2",
        Color = Color3.fromHex("#FF4444"),
        Justify = "Center",
        Callback = function()
            Window:Dialog({
                Title = "Reset Visited Data",
                Content = "Are you sure you want to reset all visited counters?",
                Icon = "alert-triangle",
                Buttons = {
                    {
                        Title = "Cancel",
                        Variant = "Secondary",
                        Callback = function() end
                    },
                    {
                        Title = "Reset",
                        Variant = "Destructive",
                        Callback = function()
                            VisitedSystem:reset()
                        end
                    }
                }
            })
        end
    })
end

local function initializeVisitedSystem()
    print("INITIALIZING VISITED SYSTEM")
    
    VisitedSystem:load()
    
    setupSimpleTracking()
    setupActiveTabDetection()
    hookTabButtonsDirectly()
    
    createVisitedUI()
    
    task.spawn(function()
        task.wait(3)
        for tabName, _ in pairs(Tabs) do
            VisitedSystem:updateTabTitle(tabName)
        end
        print("[Visited] Updated all tab titles")
    end)
    
    task.spawn(function()
        task.wait(1)
        VisitedSystem:track("Home")
    end)
    
    print("[Visited] âœ… System ready")
end

task.spawn(function()
    task.wait(3)
    initializeVisitedSystem()
end)

getgenv().Visited = {
    track = function(tabName) return VisitedSystem:track(tabName) end,
    stats = function() VisitedSystem:showStats() end,
    reset = function() VisitedSystem:reset() end
}

Window:SelectTab(1)

-- Utility Functions
function create_animation(object: Instance, info: TweenInfo, value: table)
    local animation = TweenService:Create(object, info, value)
    animation:Play()
    task.wait(info.Time)
    Debris:AddItem(animation, 0)
end

local ConnectionsManager = {}

function ConnectionsManager:disconnect()
    if not ConnectionsManager[self] then
        return
    end
    ConnectionsManager[self]:Disconnect()
    ConnectionsManager[self] = nil
end

function ConnectionsManager:abadone()
    for _, connection in ConnectionsManager do
        if typeof(connection) == 'function' then
            continue
        end
        connection:Disconnect()
        connection = nil
    end
end

ConnectionsManager['controller'] = RunService.Heartbeat:Connect(function()
    if not Window then
        ConnectionsManager:abadone()
    end
end)

local function linear_predict(a: any, b: any, time_volume: number)
    return a + (b - a) * time_volume
end

function World:get_pointer()
    local UserInputService = game:GetService("UserInputService")    
    local mouse_location = UserInputService:GetMouseLocation()
    local ray = workspace.CurrentCamera:ScreenPointToRay(mouse_location.X, mouse_location.Y, 0)    
    local target = ray.Origin + ray.Direction
    return CFrame.lookAt(ray.Origin, target)
end

function AutoParry.Lobby_Balls()
    for _, Instance in pairs(workspace.TrainingBalls:GetChildren()) do
        if Instance:GetAttribute("realBall") then
            return Instance
        end
    end
end


function AutoParry.get_ball()    
    local balls = {}
        
    for _, ball in ipairs(balls) do
        if ball:GetAttribute("realBall") then
            if ball:IsA("BasePart") then
                ball.CanCollide = false
            end
            return ball
        end
    end
       
    for _, ball in workspace.Balls:GetChildren() do
        if ball:GetAttribute("realBall") then
            if ball:IsA("BasePart") then
                ball.CanCollide = false
            end
            return ball
        end
    end   
   
    for _, instance in workspace.TrainingBalls:GetChildren() do
        if instance:GetAttribute("realBall") then
            if instance:IsA("BasePart") then
                instance.CanCollide = false
            end
            return instance
        end
    end
        
    return nil
end

function AutoParry.get_client_ball()
    for _, ball in workspace.Balls:GetChildren() do
        if not ball:GetAttribute("realBall") then
            return ball
        end
    end
end

function Player:get_aim_entity()
    local closest_entity = nil
    local minimal_dot_product = -math.huge
    local camera_direction = workspace.CurrentCamera.CFrame.LookVector
    for _, player in workspace.Alive:GetChildren() do
        if not player or player.Name == LocalPlayer.Name or not player:FindFirstChild('HumanoidRootPart') then
            continue
        end
        local entity_direction = (player.HumanoidRootPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
        local dot_product = camera_direction:Dot(entity_direction)
        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_entity = player
        end
    end
    return closest_entity
end

function Player:get_closest_player_to_cursor()
    local closest_player = nil
    local minimal_dot_product = -math.huge
    for _, player in workspace.Alive:GetChildren() do
        if player == LocalPlayer.Character or player.Parent ~= workspace.Alive then
            continue
        end
        local player_direction = (player.PrimaryPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
        local pointer = World.get_pointer()
        local dot_product = pointer.LookVector:Dot(player_direction)
        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_player = player
        end
    end
    return closest_player
end

local Sound_Effect = true
local sound_effect_type = "DC_15X"
local CustomId = ""
local sound_assets = {
    DC_15X = 'rbxassetid://936447863',
    Neverlose = 'rbxassetid://8679627751',
    Minecraft = 'rbxassetid://8766809464',
    MinecraftHit2 = 'rbxassetid://8458185621',
    TeamfortressBonk = 'rbxassetid://8255306220',
    TeamfortressBell = 'rbxassetid://2868331684',
    Medal = "rbxassetid://6607336718",
    Fatality = "rbxassetid://6607113255",
        Skeet = "rbxassetid://6607204501",
        Switches = "rbxassetid://6607173363",
        ["Rust Headshot"] = "rbxassetid://138750331387064",
        ["Neverlose Sound"] = "rbxassetid://110168723447153",
        Bubble = "rbxassetid://6534947588",
        Laser = "rbxassetid://7837461331",
        Steve = "rbxassetid://4965083997",
        ["Call of Duty"] = "rbxassetid://5952120301",
        Bat = "rbxassetid://3333907347",
        ["TF2 Critical"] = "rbxassetid://296102734",
        Saber = "rbxassetid://8415678813",
        Bameware = "rbxassetid://3124331820",
    Custom = 'empty'
}

local function play_parry_sound()
    if not Config.sound_effect_enabled then
        return
    end
    local sound_id = sound_assets[sound_effect_type]
    if sound_effect_type == "Custom" then
        sound_id = CustomId ~= "" and "rbxassetid://" .. CustomId or "empty"
    end
    if sound_id == "empty" then
        return
    end
    local sound = Instance.new("Sound")
    sound.SoundId = sound_id
    sound.Volume = 1
    sound.Parent = workspace
    sound:Play()
    Debris:AddItem(sound, 3)
end

function AutoParry.perform_grab_animation()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local currently_equipped = Player.Entity.properties.sword or Player.Character:GetAttribute('CurrentlyEquippedSword')

    
    if not currently_equipped or not animation then
        warn("Failed to perform grab animation: Invalid sword or animation not found")
        return
    end
    
    local success, sword_data = pcall(function()
        return ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(currently_equipped)
    end)
    if not success or not sword_data or not sword_data['AnimationType'] then
        warn("Failed to retrieve sword data for " .. tostring(currently_equipped))
        return
    end
   
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild('Humanoid') then
        warn("Character or Humanoid not found for animation")
        return
    end
    
    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == sword_data['AnimationType'] then
            local sword_animation_type = object:FindFirstChild('GrabParry') and 'GrabParry' or object:FindFirstChild('Grab') and 'Grab'
            if sword_animation_type then
                animation = object[sword_animation_type]
            end
        end
    end
    
    local success, result = pcall(function()
        local grab_animation = character.Humanoid:LoadAnimation(animation)
        Player.properties.grab_animation = grab_animation
        grab_animation:Play()
    end)
    if not success then
        warn("Failed to load or play animation: " .. tostring(result))
    end
end

local TargetSelectionMethod = "ClosestToCursor"

function AutoParry:ParryData()
    local Camera = workspace.CurrentCamera
    if not Camera then return {0, CFrame.new(), {}, {0, 0}} end

    local ViewportSize = Camera.ViewportSize
    local LastInput = UserInputService:GetLastInputType()
    local MouseLocation = (LastInput == Enum.UserInputType.MouseButton1 or LastInput == Enum.UserInputType.MouseButton2 or LastInput == Enum.UserInputType.Keyboard)
        and UserInputService:GetMouseLocation()
        or Vector2.new(ViewportSize.X / 2, ViewportSize.Y / 2)
    local Used = {MouseLocation.X, MouseLocation.Y}
    if TargetSelectionMethod == "ClosestToCursor" then
        local ClosestEntity = Player:get_closest_player_to_cursor()
        if closest_player and closest_player.PrimaryPart then
            Used = Camera:WorldToScreenPoint(closest_entity.PrimaryPart.Position)
        end
    end

    local Alive = workspace.Alive:GetChildren()
    local Events = table.create(#Alive)
    for _, v in ipairs(Alive) do
        Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
    end
    
    local directionMap = {
        ["Linear"] = function()
            local target_pos = AutoParry.entity_properties.server_position or Vector3.zero
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_pos + Vector3.new(math.random(-100, 100), math.random(-50, 50), math.random(-100, 100)))
        end,
        ["Backwards"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.LookVector * 100000) + Vector3.new(math.random(-100, 100), math.random(1000, 2000), math.random(-100, 100)))
        end,
        ["Random"] = function()
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Vector3.new(math.random(-10000, 10000), math.random(-5000, 5000), math.random(-10000, 10000)))
        end,
        ["Accelerated"] = function()
            local target_pos = AutoParry.entity_properties.server_position or Vector3.zero
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_pos + Vector3.new(math.random(-50, 50), math.random(200, 400), math.random(-50, 50)))
        end,
        ["Right"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.RightVector * 100000) + Vector3.new(math.random(1000, 2000), math.random(-100, 100), math.random(-100, 100)))
        end,
        ["Left"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 100000) + Vector3.new(math.random(-2000, -1000), math.random(-100, 100), math.random(-100, 100)))
        end,
        ["LeftSharp"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 150000) + Vector3.new(math.random(-3000, -1500), math.random(-50, 50), math.random(-50, 50)))
        end,
        ["LeftSemiSharp"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 80000) + Vector3.new(math.random(-1500, -500), math.random(-50, 50), math.random(-50, 50)))
        end,
        ["Up"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.UpVector * 100000) + Vector3.new(math.random(-100, 100), math.random(1000, 2000), math.random(-100, 100)))
        end,
        ["Down"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.UpVector * 100000) + Vector3.new(math.random(-100, 100), math.random(-2000, -1000), math.random(-100, 100)))
        end,
        ["Normal"] = function()
            return Camera.CFrame
        end,
        ["FollowCamera"] = function()
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Camera.CFrame.Position + Camera.CFrame.LookVector * 100000 + Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
        end,
        ["Forward"] = function()
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, LocalPlayer.Character.PrimaryPart.Position + LocalPlayer.Character.PrimaryPart.CFrame.LookVector * 100000 + Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
        end,
        ["Circular"] = function()
            local angle = math.rad(math.random(0, 360))
            local offset = Vector3.new(math.cos(angle) * 10000, math.sin(angle) * 5000, math.random(-5000, 5000))
            local target_pos = AutoParry.entity_properties.server_position or Vector3.zero
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_pos + offset)
        end,
        ["Default"] = function()
            return Camera.CFrame * CFrame.new(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
        end
    }

    return {0, directionMap[Config.curve_method] and directionMap[Config.curve_method]() or Camera.CFrame, Events, Used}
end

function AutoParry:ExecuteParry()    
    task.spawn(function()
        local VicoX = AutoParry:ParryData()            
        MainRemote:FireServer(HashTwo, Parry_Key, table.unpack(VicoX))          
    end)
end

function AutoParry:PerformParry()    
    local ball_properties = AutoParry.ball.properties
    if ball_properties.cooldown and not ball_properties.auto_spam then
        return
    end

    ball_properties.parries += 1
    ball_properties.last_hit = tick()

    local camera = workspace.CurrentCamera
    if not camera then
        return
    end
    local camera_position = camera.CFrame.Position
    local target_position = AutoParry.entity_properties.server_position or Vector3.zero
    local direction = camera.CFrame

    if not ball_properties.auto_spam then 
        pcall(function()
            AutoParry:perform_grab_animation()
        end)
        ball_properties.cooldown = true

        local current_curve = Config.curve_method
        if current_curve == "Linear" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_position + Vector3.new(math.random(-100, 100), math.random(-50, 50), math.random(-100, 100)))
        elseif current_curve == "Backwards" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.LookVector * 100000) + Vector3.new(math.random(-100, 100), math.random(1000, 2000), math.random(-100, 100)))
        elseif current_curve == "Random" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Vector3.new(math.random(-10000, 10000), math.random(-5000, 5000), math.random(-10000, 10000)))
        elseif current_curve == "Accelerated" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_position + Vector3.new(math.random(-50, 50), math.random(200, 400), math.random(-50, 50)))
        elseif current_curve == "Right" then
            direction = CFrame.new(camera_position, camera_position + (camera.CFrame.RightVector * 100000) + Vector3.new(math.random(1000, 2000), math.random(-100, 100), math.random(-100, 100)))
        elseif current_curve == "Left" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.RightVector * 100000) + Vector3.new(math.random(-2000, -1000), math.random(-100, 100), math.random(-100, 100)))
        elseif current_curve == "LeftSharp" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.RightVector * 150000) + Vector3.new(math.random(-3000, -1500), math.random(-50, 50), math.random(-50, 50)))
        elseif current_curve == "LeftSemiSharp" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.RightVector * 80000) + Vector3.new(math.random(-1500, -500), math.random(-50, 50), math.random(-50, 50)))
        elseif current_curve == "Up" then
            direction = CFrame.new(camera_position, camera_position + (camera.CFrame.UpVector * 100000) + Vector3.new(math.random(-100, 100), math.random(1000, 2000), math.random(-100, 100)))
        elseif current_curve == "Down" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.UpVector * 100000) + Vector3.new(math.random(-100, 100), math.random(-2000, -1000), math.random(-100, 100)))
        elseif current_curve == "Normal" then
            direction = camera.CFrame
        elseif current_curve == "FollowCamera" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, camera_position + camera.CFrame.LookVector * 100000 + Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
        elseif current_curve == "Forward" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, LocalPlayer.Character.PrimaryPart.Position + LocalPlayer.Character.PrimaryPart.CFrame.LookVector * 100000 + Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
        elseif current_curve == "Circular" then
            local angle = math.rad(math.random(0, 360))
            local offset = Vector3.new(math.cos(angle) * 10000, math.sin(angle) * 5000, math.random(-5000, 5000))
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_position + offset)
        end
    else
        direction = CFrame.new(camera_position, target_position + Vector3.new(0, 300, 0))
    end

    local parry_data = AutoParry:ParryData()
    local target_name = AutoParry.target.aim and AutoParry.target.aim.Name or ""
    local target_data = target_name ~= "" and { [target_name] = target_position } or {}
    
    if SelectedParryMethod == "getgc" then            
        pcall(function()
            MainRemote:FireServer(
                HashTwo, 
                Parry_Key, 
                parry_data[1],
                direction, 
                target_data,
                { target_position.X, target_position.Y }            
            )
        end)
    elseif SelectedParryMethod == "Hook" then        
        pcall(function()
            if not FirstParryDone then
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)
                task.wait(0.015)
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001)
                FirstParryDone = true
            else                           
                for remote, originalArgs in pairs(revertedRemotes) do
                    local modifiedArgs = {
                        originalArgs[1],
                        originalArgs[2],
                        originalArgs[3],
                        parry_data[2], 
                        parry_data[3],
                        parry_data[4],
                        originalArgs[7]
                    }
                    if remote:IsA("RemoteEvent") then
                        remote:FireServer(unpack(modifiedArgs))
                    elseif remote:IsA("RemoteFunction") then
                        remote:InvokeServer(unpack(modifiedArgs))
                    end
                end
            end
        end)
        if not next(revertedRemotes) then
            WindUI:Notify({
                Title = "Hook Warning",
                Content = "No parry remote captured. Try parrying manually.",
                Duration = 5,
            })
        end
    end 
        
    task.delay(0.46, function()
        if ball_properties.parries > 0 then
            ball_properties.parries -= 1
        end
        ball_properties.firstParryFired = false
    end)
end

function AutoParry.reset()
    AutoParry.ball.properties.is_curved = false
    AutoParry.ball.properties.auto_spam = false
    AutoParry.ball.properties.cooldown = false
    AutoParry.ball.properties.maximum_speed = 0
    AutoParry.ball.properties.parries = 0
    AutoParry.entity_properties.server_position = Vector3.zero
    AutoParry.target.current = nil
    AutoParry.target.from = nil
        
    spam_parry_count = 0
    last_spam_time = 0
end

local deathshit = false
ReplicatedStorage.Remotes.DeathBall.OnClientEvent:Connect(function(c, d)
    deathshit = d and true or false
end)

local Infinity = false
ReplicatedStorage.Remotes.InfinityBall.OnClientEvent:Connect(function(a, b)
    Infinity = b and true or false
end)

local timehole = false
ReplicatedStorage.Remotes.TimeHoleHoldBall.OnClientEvent:Connect(function(e, f)
    timehole = f and true or false
end)

ReplicatedStorage.Remotes.PlrHellHooked.OnClientEvent:Connect(function(hooker: Model)
    AutoParry.ball.properties.hell_hook_completed = hooker.Name == LocalPlayer.Name
end)

ReplicatedStorage.Remotes.PlrHellHookCompleted.OnClientEvent:Connect(function()
    AutoParry.ball.properties.hell_hook_completed = true
end)

function AutoParry.is_curved()
	local target = AutoParry.target.current
	if not target then return false end

	local ball_properties = AutoParry.ball.properties
	local current_target = AutoParry.target.current.Name
	local ping = Player.Entity.properties.ping

	if target.PrimaryPart:FindFirstChild('MaxShield') and current_target ~= LocalPlayer.Name and ball_properties.distance < 50 then
		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('TimeHole1') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
		ball_properties.auto_spam = false
		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('WEMAZOOKIEGO') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('At2') and ball_properties.speed <= 0 then
		return true
	end

	if AutoParry.ball.ball_entity:FindFirstChild('AeroDynamicSlashVFX') then
		Debris:AddItem(AutoParry.ball.ball_entity.AeroDynamicSlashVFX, 0)
		ball_properties.auto_spam = false
		ball_properties.aero_dynamic_time = tick()
	end

	if RunTime:FindFirstChild('Tornado') then
		if ball_properties.distance > 5 and (tick() - ball_properties.aero_dynamic_time) < (RunTime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then
			return true
		end
	end

	if not ball_properties.hell_hook_completed and target.Name == LocalPlayer.Name and ball_properties.distance > 5 - math.random() then
		return true
	end
	
	local ball_direction = ball_properties.velocity.Unit
	local ball_speed = ball_properties.speed
	
	local speed_threshold = math.min(ball_speed / 150, 30)
	local angle_threshold = 30 * math.max(ball_properties.dot, 0)

	local player_ping = Player.Entity.properties.ping

	local accurate_direction = ball_properties.velocity.Unit
	accurate_direction *= ball_direction

	local direction_difference = (accurate_direction - ball_properties.velocity).Unit
	local accurate_dot = ball_properties.direction:Dot(direction_difference)
	local dot_difference = ball_properties.dot - accurate_dot
	
	local dot_base = 0.4
	if player_ping >= 200 then
		dot_base = 0.3
	elseif player_ping >= 300 then
		dot_base = 0.25
	end
	local dot_threshold = dot_base - player_ping / 1500

	local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)
	local enough_speed = ball_properties.maximum_speed > 100
	
	local ball_distance_threshold = 12 - math.min(ball_properties.distance / 1000, 12) + angle_threshold + speed_threshold
	
	if enough_speed and reach_time > player_ping / 10 then
		ball_distance_threshold = math.max(ball_distance_threshold - 12, 12)
	end
	
	if ball_properties.distance < ball_distance_threshold then
		return false
	end

	if dot_difference < dot_threshold then
		return true
	end
	
	if ball_properties.lerp_radians < 0.015 then 
		ball_properties.last_curve_position = ball_properties.position
		ball_properties.last_warping = tick() 
	end
	
	if (tick() - ball_properties.last_warping) < (reach_time / 2) then
		return true
	end

	return ball_properties.dot < dot_threshold
end

function AutoParry.is_curveds()    
    local ball = AutoParry.ball and AutoParry.ball.ball_entity
    local ball_properties = AutoParry.ball and AutoParry.ball.properties
    local target = AutoParry.target and AutoParry.target.current
    if not ball or not ball_properties or not target or not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        return false
    end

    local zoom = ball:FindFirstChild("zoomies")
    if not zoom then return false end

    local ping = (Player.Entity and Player.Entity.properties and Player.Entity.properties.ping or 100)
    local ping_ms = ping / 1000

    if target:FindFirstChild("MaxShield") and target.Name ~= LocalPlayer.Name and (ball_properties.distance or math.huge) < 50 then
        return false
    end
    if ball:FindFirstChild("TimeHole1") and target.Name ~= LocalPlayer.Name and (ball_properties.distance or math.huge) < 100 then
        return false
    end
    if ball:FindFirstChild("WEMAZOOKIEGO") and target.Name ~= LocalPlayer.Name and (ball_properties.distance or math.huge) < 100 then
        return false
    end

    if ball:FindFirstChild("At2") and zoom.VectorVelocity.Magnitude <= 0 then
        return true
    end

    local tornadoTime = ball_properties.aero_dynamic_time or tick()
    if ball:FindFirstChild("AeroDynamicSlashVFX") then
        Debris:AddItem(ball.AeroDynamicSlashVFX, 0)
        tornadoTime = tick()
        ball_properties.aero_dynamic_time = tornadoTime
        ball_properties.aero_dynamic_active = true
    end

    local runtime = Workspace.Runtime
    if runtime:FindFirstChild("Tornado") then
        if (tick() - tornadoTime) < ((runtime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159) then
            return true
        end
    end

    if deathshit then
        ball_properties.auto_spam = false
        return true
    end
    if Infinity then
        ball_properties.auto_spam = false
        return true
    end
    if timehole then
        return true
    end

    if not (ball_properties.hell_hook_completed or false) and target.Name == LocalPlayer.Name and (ball_properties.distance or math.huge) > 5 then
        return true
    end

    local currentVel = zoom.VectorVelocity
    ball_properties.recent_velocities = ball_properties.recent_velocities or {}
    table.insert(ball_properties.recent_velocities, currentVel)
    if #ball_properties.recent_velocities > 10 then
        table.remove(ball_properties.recent_velocities, 1)
    end

    local totalWeight = 0
    local weightedSum = Vector3.new(0, 0, 0)
    for i, vel in ipairs(ball_properties.recent_velocities) do
        local weight = i / #ball_properties.recent_velocities
        weightedSum = weightedSum + vel * weight
        totalWeight = totalWeight + weight
    end
    local avgVel = totalWeight > 0 and weightedSum / totalWeight or (ball_properties.velocity or currentVel)

    local ballDir = avgVel.Magnitude > 0 and avgVel.Unit or (ball_properties.velocity and ball_properties.velocity.Unit or Vector3.new(0, 0, 1))
    local toBall = (LocalPlayer.Character.PrimaryPart.Position - ball.Position).Unit
    local dotVal = toBall:Dot(ballDir)
    
    local dotMin = 0.98
    if ping >= 200 then dotMin = 0.96 end
    if ping >= 300 then dotMin = 0.94 end
    
    if dotVal >= dotMin then 
        return false
    end

    local speed = avgVel.Magnitude
    local distance = ball_properties.distance or (LocalPlayer.Character.PrimaryPart.Position - ball.Position).Magnitude
    local reachTime = distance / math.max(speed, 1) - ping_ms

    local speed_start = 5
    local speed_end = 25
    if ping >= 200 then speed_start = 6; speed_end = 28 end
    if ping >= 300 then speed_start = 7; speed_end = 30 end
    
    local speedThreshold = linear_predict(speed_start, speed_end, math.min(speed / 1000, 1))
    
    local angle_mult = 25
    if ping >= 200 then angle_mult = 28 end
    if ping >= 300 then angle_mult = 30 end
    
    local angleThreshold = angle_mult * math.max(dotVal, 0)
    
    local dot_start = 0.15
    local dot_end = 0.35
    if ping >= 200 then dot_start = 0.18; dot_end = 0.38 end
    if ping >= 300 then dot_start = 0.20; dot_end = 0.40 end
    
    local dotThreshold = linear_predict(dot_start, dot_end, math.min(ping_ms, 1)) - ping_ms
    
    local base_dist = 8
    if ping >= 200 then base_dist = 9 end
    if ping >= 300 then base_dist = 10 end
    
    local ballDistanceThreshold = base_dist - math.min(distance / 1000, base_dist) + speedThreshold + angleThreshold

    if speed > 100 and reachTime > ping_ms * 6 then
        local reduction_amount = 8
        if speed < 300 then reduction_amount = ping >= 200 and 9 or 8
        elseif speed < 600 then reduction_amount = ping >= 200 and 10 or 9
        elseif speed < 1000 then reduction_amount = ping >= 200 and 11 or 10
        elseif speed < 1500 then reduction_amount = ping >= 200 and 12 or 11
        else reduction_amount = ping >= 200 and 13 or 12 end
        
        ballDistanceThreshold = math.max(ballDistanceThreshold - reduction_amount, reduction_amount)
    end

    if distance < ballDistanceThreshold then
        return false
    end

    local backwardsCurveDetected = false
    local backwards_base = 70
    local backwards_limit = 80
    if ping >= 200 then backwards_base = 72; backwards_limit = 82 end
    if ping >= 300 then backwards_base = 75; backwards_limit = 85 end
    
    local backwardsAngleThreshold = math.max(backwards_base, math.min(backwards_limit, backwards_base + (speed / 200)))
    
    local playerPos = LocalPlayer.Character.PrimaryPart.Position
    local ballPos = ball.Position
    local horizDirection = Vector3.new(playerPos.X - ballPos.X, 0, playerPos.Z - ballPos.Z)
    if horizDirection.Magnitude > 0 then
        horizDirection = horizDirection.Unit
        local awayFromPlayer = -horizDirection
        local horizBallDir = Vector3.new(ballDir.X, 0, ballDir.Z)
        if horizBallDir.Magnitude > 0 then
            horizBallDir = horizBallDir.Unit
            local backwardsAngle = math.deg(math.acos(math.clamp(awayFromPlayer:Dot(horizBallDir), -1, 1)))
            if backwardsAngle < backwardsAngleThreshold then
                backwardsCurveDetected = true
            end
        end
    end

    ball_properties.previous_velocities = ball_properties.previous_velocities or {}
    local similarity = 0
    if #ball_properties.previous_velocities > 0 then
        local prevVel = ball_properties.previous_velocities[#ball_properties.previous_velocities]
        local velDiff = (currentVel - prevVel).Magnitude
        similarity = 1 - math.min(velDiff / math.max(prevVel.Magnitude, 0.1), 1)
    end
    table.insert(ball_properties.previous_velocities, currentVel)
    if #ball_properties.previous_velocities > 5 then
        table.remove(ball_properties.previous_velocities, 1)
    end

    local similarity_threshold = 0.6
    if ping >= 200 then similarity_threshold = 0.55 end
    if ping >= 300 then similarity_threshold = 0.50 end
    
    if similarity < similarity_threshold and (tick() - (ball_properties.last_warping or 0)) > 0.08 then
        ball_properties.last_warping = tick()
        return true
    end

    if dotVal < dotThreshold or backwardsCurveDetected then
        return true
    end

    return false
end

local old_from_target = nil :: Model

function AutoParry:is_spam() 
    local target = AutoParry.target.current
    local ball_properties = AutoParry.ball.properties
    local player_character = LocalPlayer.Character
    local current_changed = AutoParry.target.current_changed
    local direction_changed_on_cframe = AutoParry.target.direction_changed_on_cframe
    local time_threshold_adjust = 1.0  -- Added missing variable
    
    -- Reset jika target dan arah berubah secara bersamaan
    if current_changed and direction_changed_on_cframe then
       self.parries = 0
       return false
    end
    
    -- Cek jika ada target lain yang lebih dekat dengan arah kamera
    if player_character and player_character.PrimaryPart and target and target.PrimaryPart and workspace.CurrentCamera then
        local camera_cframe = workspace.CurrentCamera.CFrame
        local camera_direction = camera_cframe.LookVector
        local current_target_position = target.PrimaryPart.Position
        local vector_to_current_target = (current_target_position - camera_cframe.Position).Unit
        local dot_to_current_target = camera_direction:Dot(vector_to_current_target)

        for _, other_player in pairs(workspace.Alive:GetChildren()) do
            if other_player ~= target and other_player ~= player_character and other_player:IsA("Model") and other_player.PrimaryPart then
                local other_position = other_player.PrimaryPart.Position
                local vector_to_other = (other_position - camera_cframe.Position).Unit
                local dot_to_other = camera_direction:Dot(vector_to_other)
                
                -- Prioritaskan target yang lebih dekat dengan arah pandang kamera
                if dot_to_other > dot_to_current_target + 0.1 then
                    return false
                end
            end
        end
    end

    -- Validasi karakter pemain
    if player_character and player_character.Parent == workspace.Dead then               
        return false
    end

    -- Validasi target dan bola
    if not target or not target.Parent or not player_character or not player_character.Parent then
        self.parries = 0
        return false
    end

    if not AutoParry.ball or not ball_properties or not ball_properties.position then
        self.parries = 0
        return false
    end

    -- Cek kesehatan target
    local target_humanoid = target:FindFirstChildOfClass("Humanoid")
    if not target_humanoid or target_humanoid.Health <= 0 then      
        return false
    end

    -- Track perubahan pengirim bola
    local old_from_target_ref = old_from_target or AutoParry.target.from
    if AutoParry.target.from ~= player_character then
        old_from_target = AutoParry.target.from
    end

    -- Tunggu hingga mencapai threshold parries yang lebih tinggi
    if self.parries < 4 and AutoParry.target.from == old_from_target_ref then
        return false
    end

    -- Hitung threshold berdasarkan ping
    local player_ping = Player.Entity.properties.ping
    local distance_threshold = 19 + (player_ping / 80)
    local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)

    -- Reset jika terlalu lama sejak hit terakhir
    if (tick() - self.last_hit) > 0.8 and self.entity_distance > distance_threshold and self.parries < 4 then
        self.parries = 1
        return false
    end

    -- Deteksi curve ball dengan threshold yang lebih tinggi
    if ball_properties.lerp_radians then       
        local curve_threshold = 0.028 + (player_ping / 100) 
        if ball_properties.lerp_radians > curve_threshold then
            if self.parries > 5 then
                self.parries = 2
            end
            return false
        end
    end

    -- Analisis mendalam untuk curve ball
    local is_curve = false
    local is_high_curve = false
    if ball_properties.lerp_radians then       
        local curve_threshold = 0.028 + (player_ping / 100)
        local dot_threshold = 0.2 - (player_ping / 1000)  -- Fixed: was missing division
        local high_curve_dot_threshold = 0.4
        
        if ball_properties.lerp_radians > curve_threshold then
            is_curve = true
            -- High curve detection
            if ball_properties.dot < high_curve_dot_threshold or 
               (tick() - ball_properties.last_warping) < (reach_time / (1.1 / time_threshold_adjust)) then
                is_high_curve = true
                return false
            -- Medium curve detection
            elseif ball_properties.dot < dot_threshold then
                if self.parries < 8 then  -- Increased threshold
                    return false
                end
                if self.parries >= 8 then  -- Increased threshold
                    self.parries = 1
                end
            end
        end
    end

    -- Beri waktu lebih untuk mendeteksi warp timing
    if (tick() - ball_properties.last_warping) < (reach_time / 1.3) and 
       self.entity_distance > distance_threshold and 
       self.parries < 5 then  -- Increased from 4 to 5
        if self.parries > 4 then  -- Increased from 3 to 4
            self.parries = 1
        end
        return false
    end

    -- Speed consistency check dengan threshold lebih tinggi
    if math.abs(self.speed - self.old_speed) < 5.2 and 
       self.entity_distance > distance_threshold and 
       self.speed < 60 and 
       self.parries < 4 then  -- Increased from 3 to 4
        if self.parries > 4 then  -- Increased from 3 to 4
            self.parries = 0
        end
        return false
    end
    
    -- Minimum speed requirement
    if self.speed < 50 then
        self.parries = 1
        return false
    end

    -- Speed validation
    if self.maximum_speed < self.speed and self.entity_distance > distance_threshold then
        self.parries = 1
        return false
    end

    -- Distance checks dengan threshold yang dinaikkan
    if self.entity_distance > self.range and self.entity_distance > distance_threshold then
        if self.parries > 3 then  -- Increased from 2 to 3
            self.parries = 1
        end
        return false
    end

    if self.ball_distance > self.range and self.entity_distance > distance_threshold then
        if self.parries > 3 then  -- Increased from 2 to 3
            self.parries = 2
        end
        return false
    end

    if self.last_position_distance > self.spam_accuracy and self.entity_distance > distance_threshold then
        if self.parries > 5 then  -- Increased from 4 to 5
            self.parries = 2
        end
        return false
    end

    if self.ball_distance > self.spam_accuracy and self.ball_distance > distance_threshold then
        if self.parries > 4 then  -- Increased from 3 to 4
            self.parries = 2
        end
        return false
    end

    if self.entity_distance > self.spam_accuracy and self.entity_distance > (distance_threshold - math.pi) then
        if self.parries > 4 then  -- Increased from 3 to 4
            self.parries = 2
        end
        return false
    end

    -- Hanya return true jika semua kondisi terpenuhi dan threshold parries tercapai
    return self.parries >= 3  -- Explicit check untuk memastikan threshold tercapai
end

AutoParry.ball.training_ball_entity = AutoParry.Lobby_Balls()
AutoParry.ball.ball_entity = AutoParry.get_ball()
AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()


NetworkClient:SetOutgoingKBPSLimit(math.huge)

local cached_ping = 0
local last_ping_update = 0
local function update_cached_ping()
    if tick() - last_ping_update >= 0.01 then
        cached_ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
        last_ping_update = tick()
    end
    return cached_ping
end

local function setupConnections()    
    task.spawn(function()
        if ConnectionsManager['server_position_simulation'] then
            ConnectionsManager:disconnect('server_position_simulation')
        end
        if ConnectionsManager['player_properties_update'] then
            ConnectionsManager:disconnect('player_properties_update')
        end
        if ConnectionsManager['ball_properties_update'] then
            ConnectionsManager:disconnect('ball_properties_update')
        end

        ConnectionsManager['server_position_simulation'] = RunService.Heartbeat:Connect(function()
            local ping = update_cached_ping()
            if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
                return
            end
            local primary_part = LocalPlayer.Character.PrimaryPart
            local old_position = primary_part.Position   
            Player.Entity.properties.server_position = old_position
        end)

        ConnectionsManager['player_properties_update'] = RunService.PostSimulation:Connect(function()
            local character = LocalPlayer.Character
            if not character or not character.PrimaryPart then
                return
            end
            local player_properties = Player.Entity.properties
            player_properties.sword = character:GetAttribute('CurrentlyEquippedSword')
            player_properties.ping = update_cached_ping()
            player_properties.velocity = character.PrimaryPart.AssemblyLinearVelocity
            player_properties.speed = player_properties.velocity.Magnitude
            player_properties.is_moving = player_properties.speed > 16

            player_properties.is_moving_backwards = false
            if AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.position then
                local ball_position = AutoParry.ball.properties.position
                local character_position = character.PrimaryPart.Position
                local direction_to_ball = (ball_position - character_position).Unit
                local velocity_direction = player_properties.velocity.Unit        
                if player_properties.speed > 16 and direction_to_ball:Dot(velocity_direction) < -0.1 then
                    player_properties.is_moving_backwards = true
                end
            end
        end)

        ConnectionsManager['ball_properties_update'] = RunService.PostSimulation:Connect(function()
            local balls = {}
            local ball = AutoParry.ball.ball_entity
            local lobby_ball = AutoParry.ball.training_ball_entity
            if ball then table.insert(balls, ball) end
            if lobby_ball then table.insert(balls, lobby_ball) end

            if not balls or #balls == 0 then
                return
            end

            for _, ball in pairs(balls) do
                local zoomies = ball:FindFirstChild('zoomies')
                local ball_properties = AutoParry.ball.properties

                ball_properties.position = ball.Position
                ball_properties.velocity = ball.AssemblyLinearVelocity

                if zoomies then
                    ball_properties.velocity = zoomies.VectorVelocity
                end

                ball_properties.distance = (Player.Entity.properties.server_position - ball_properties.position).Magnitude
                ball_properties.speed = ball_properties.velocity.Magnitude
                ball_properties.direction = (Player.Entity.properties.server_position - ball_properties.position).Unit
                ball_properties.dot = ball_properties.direction:Dot(ball_properties.velocity.Unit)
                ball_properties.radians = math.rad(math.asin(ball_properties.dot))
                ball_properties.lerp_radians = ball_properties.lerp_radians and (ball_properties.lerp_radians * 0.3 + ball_properties.radians * 0.9) or ball_properties.radians

                if not (ball_properties.lerp_radians < 0) and not (ball_properties.lerp_radians > 0) then
                    ball_properties.lerp_radians = 0.027
                end

                ball_properties.maximum_speed = math.max(ball_properties.speed, ball_properties.maximum_speed)
                
                AutoParry.target.aim = not UserInputService.TouchEnabled and (Player.get_closest_player_to_cursor and Player.get_closest_player_to_cursor() or nil) or (Player.get_aim_entity and Player.get_aim_entity() or nil)

                if ball:GetAttribute('from') then
                    AutoParry.target.from = workspace.Alive:FindFirstChild(ball:GetAttribute('from'))
                end

                if ball:GetAttribute('target') then
                    AutoParry.target.current = workspace.Alive:FindFirstChild(ball:GetAttribute('target'))
                end

                if not AutoParry.target.current then
                    return
                end

                ball_properties.rotation = ball_properties.position

                if AutoParry.target.current.Name == LocalPlayer.Name then
                    ball_properties.rotation = AutoParry.target.aim and AutoParry.target.aim.PrimaryPart and AutoParry.target.aim.PrimaryPart.Position or ball_properties.position
                    return
                end

                local target_server_position = AutoParry.target.current.PrimaryPart.Position
                local target_velocity = AutoParry.target.current.PrimaryPart.AssemblyLinearVelocity

                AutoParry.entity_properties.server_position = target_server_position
                AutoParry.entity_properties.velocity = target_velocity
                AutoParry.entity_properties.distance = (LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and (LocalPlayer.Character.PrimaryPart.Position - target_server_position).Magnitude or math.huge)
                AutoParry.entity_properties.direction = (Player.Entity.properties.server_position - target_server_position).Unit
                AutoParry.entity_properties.speed = target_velocity.Magnitude
                AutoParry.entity_properties.is_moving = target_velocity.Magnitude > 0.1
                AutoParry.entity_properties.dot = AutoParry.entity_properties.is_moving and math.max(AutoParry.entity_properties.direction:Dot(target_velocity.Unit), 0)

                ball.AncestryChanged:Connect(function(_, parent)
                    if not parent then
                        ball_properties.maximum_speed = 0
                        AutoParry.target.current = nil
                        AutoParry.target.from = nil
                    end
                end)
            end
        end)
    end)
end

task.spawn(setupConnections)

LocalPlayer.CharacterAdded:Connect(function(character)
    if character then
        task.spawn(setupConnections)
    end
end)

if LocalPlayer.Character then
    task.spawn(setupConnections)
end



local AutoAbility = {
    enabled = false, -- Controlled by UI toggle
    parry_cooldown = false,
}

function AutoAbility:isCooldownInEffect(uigradient)
    if not uigradient then return false end
    return uigradient.Offset.Y < 0.4
end

function AutoAbility:isAbilityReady(uigradient)
    if not uigradient then return false end
    return uigradient.Offset.Y == 0.5
end

function AutoAbility:cooldownProtection()
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local hotbar = playerGui:WaitForChild("Hotbar")
    local parryCD = hotbar:WaitForChild("Block"):WaitForChild("UIGradient")

    if self:isCooldownInEffect(parryCD) then
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("AbilityButtonPress"):FireServer()
        self.parry_cooldown = true
        task.delay(0.5, function() -- Adjust delay based on game mechanics
            self.parry_cooldown = false
        end)
        return true
    end
    return false
end

function AutoAbility:performAutoAbility()
    if not self.enabled or self.parry_cooldown then return false end

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Abilities") then return false end

    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local hotbar = playerGui:WaitForChild("Hotbar")
    local abilityCD = hotbar:WaitForChild("Ability"):WaitForChild("UIGradient")

    if not self:isAbilityReady(abilityCD) then return false end

    
    local abilitiesToCheck = {
        "Raging Deflection ",
        "Rapture ",
        "Calming Deflection ",
        "Aerodynamic Slash ",
        "Fracture ",
        "Death Slash "
    }

    local abilityActivated = false
    for _, abilityName in ipairs(abilitiesToCheck) do
        local ability = character.Abilities:FindFirstChild(abilityName)
        if ability and ability.Enabled then
            abilityActivated = true
            break
        end
    end

    if abilityActivated then
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("AbilityButtonPress"):FireServer()
        if character.Abilities:FindFirstChild("Death Slash") and character.Abilities["Death Slash"].Enabled then
            task.wait(2.432)
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("DeathSlashShootActivation"):FireServer(true)
        end
        return true
    end

    return false
end


ConnectionsManager['auto_spam'] = RunService.Heartbeat:Connect(function()
    if not AutoParry.ball.properties.auto_spam then              
        return
    end    

    local speeddo = getgenv().speeddo
    for v = 1, speeddo do
        task.spawn(function() AutoParry:PerformParry() end)
    end
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(slash: any, root: any)
    task.spawn(function()
        if root.Parent and root.Parent ~= LocalPlayer.Character and root.Parent.Parent == workspace.Alive then
            AutoParry.ball.properties.cooldown = false
        end
    end)
    play_parry_sound()
   
end)

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if LocalPlayer.Character.Parent ~= Alive then
        return
    end
    
    if not Player.properties.grab_animation then
        return
    end
    
    Player.properties.grab_animation:Stop()
    
    local ball = AutoParry.get_client_ball()
    
    if not ball then
        return
    end
    
    ball = nil
end)



ConnectionsManager['auto_parry'] = RunService.Heartbeat:Connect(function()
    local auto_parry_enabled = Config.auto_parry
           
    if not auto_parry_enabled then
        AutoParry.reset()
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end

    local Character = LocalPlayer.Character

    if not Character then
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end

    if Character.Parent == workspace.Dead then
        AutoParry.reset()
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end

    if not AutoParry.ball.ball_entity then
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end

    local ball_properties = AutoParry.ball.properties
    local Singularity_Cape = LocalPlayer.Character.PrimaryPart:FindFirstChild('SingularityCape')    
    ball_properties.is_curved = AutoParry.is_curved()
    ball_properties.is_curveds = AutoParry.is_curveds()
    
    
    if AutoParry.entity_properties.distance and AutoParry.entity_properties.distance >= 5 and AutoParry.entity_properties.distance <= 7 then
        ball_properties.is_curved = false
        ball_properties.is_curveds = false
    end

    
    if Singularity_Cape then
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return 
    end

    local ping_threshold = math.clamp(Player.Entity.properties.ping / 10, 12, 18)
    local ping_thresholds = math.clamp(Player.Entity.properties.ping / 10, 2, 18)
    local ping_high = Player.Entity.properties.ping >= 200

if Player.Entity.properties.ping >= 300 then
    ping_threshold = math.clamp(Player.Entity.properties.ping / 8, 15, 22)
end


    local player_properties = Player.Entity.properties
    
    local baseMoveAmount = 0.5
    local moveAmount = baseMoveAmount * (1 / (AutoParry.entity_properties.distance + 0.01)) * 1000

    local spam_accuracity = math.min(moveAmount + (ball_properties.maximum_speed / 7), (150 + moveAmount))
    local parry_accuracity = ball_properties.maximum_speed / 11.5 + ping_threshold

    if player_properties.is_moving then
        parry_accuracity *= 1.1       
    end

    if player_properties.is_moving_backwards then
        parry_accuracity *= (1 / 1.05)        
    end
    
    if Player.Entity.properties.ping >= 290 then
        parry_accuracity = parry_accuracity * (1 + (Player.Entity.properties.ping / 500))
    end

   
    
    ball_properties.spam_range = ping_threshold + ball_properties.speed / 2
    ball_properties.parry_range = ping_threshold + ball_properties.speed / math.pi

    
    if Player.Entity.properties.sword == 'Titan Blade' then
        ball_properties.parry_range += 11
        ball_properties.spam_range += 2
    end	

    local distance_to_last_position = LocalPlayer:DistanceFromCharacter(ball_properties.last_position)
   
    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name and AutoAbility.enabled then
        if AutoAbility:cooldownProtection() then
            AutoParry.ball.properties.auto_spam = false
            AutoParry.ball.properties.parries = 0
            return
        end
        if AutoAbility:performAutoAbility() then
            AutoParry.ball.properties.auto_spam = false
            AutoParry.ball.properties.parries = 0
            return
        end
    end
    
    AutoParry.target.current_changed = AutoParry.target.current_changed or false
    AutoParry.target.direction_changed_on_cframe = AutoParry.target.direction_changed_on_cframe or false

    if AutoParry.target.current ~= AutoParry.target.previous then
        AutoParry.target.current_changed = true
        AutoParry.target.previous = AutoParry.target.current
    else
        AutoParry.target.current_changed = false
    end

    if AutoParry.target.current then
        local current_cframe = AutoParry.target.current.PrimaryPart and AutoParry.target.current.PrimaryPart.CFrame or CFrame.new()
        if not AutoParry.target.last_cframe then
            AutoParry.target.last_cframe = current_cframe
        end
        local current_direction = current_cframe.LookVector
        local last_direction = AutoParry.target.last_cframe.LookVector
        AutoParry.target.direction_changed_on_cframe = (current_direction - last_direction).Magnitude > 0.1
        AutoParry.target.last_cframe = current_cframe
    else
        AutoParry.target.direction_changed_on_cframe = false
    end                          
    
    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then        
            ball_properties.auto_spam = AutoParry.is_spam({
                speed = ball_properties.speed,
                spam_accuracy = spam_accuracity,
                parries = ball_properties.parries,
                ball_speed = ball_properties.speed,
                range = ball_properties.spam_range,
                last_hit = ball_properties.last_hit,
                ball_distance = ball_properties.distance,
                maximum_speed = ball_properties.maximum_speed,
                old_speed = ball_properties.old_speed,
                entity_distance = AutoParry.entity_properties.distance,
                last_position_distance = distance_to_last_position,
            })
        end    

    if ball_properties.auto_spam then
        return
    end

if ping_high then
    if ball_properties.is_curveds and ball_properties.dot > -0.4 then
        ball_properties.is_curveds = false
    end
end


    if ball_properties.is_curveds or ball_properties.is_curved then              
        return
    end

    if (player_properties.is_moving or player_properties.is_moving_backwards) and (ball_properties.is_curveds or ball_properties.is_curved) then       
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end
    
    if ball_properties.distance > ball_properties.parry_range and ball_properties.distance > parry_accuracity then        
        return
    end
	
    if AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character then        
        return
    end

    local lastPosition = LocalPlayer.Character.PrimaryPart.Position 
    local target_Ball_Distance = (ball_properties.position - AutoParry.entity_properties.server_position).Magnitude
       
    if parry_mode == "Legit" then
        if target_Ball_Distance <= 10 and AutoParry.entity_properties.distance <= 50 then
            if math.random(1, 2) == 1 then
                AutoParry:PerformParry()
            end
        end
    end
    
    if parry_mode == "Legit" then
        if ball_properties.maximum_speed >= 250 then
            parry_accuracity *= 1.2
        end
    end
    
    lastPosition = LocalPlayer.Character.PrimaryPart.Position 
    ball_properties.last_ball_pos = ball_properties.position

    AutoParry:PerformParry()

    task.spawn(function()
        repeat
            RunService.PreSimulation:Wait(0)
        until 
            (tick() - ball_properties.last_hit) > (1 - math.clamp(ping_threshold / 100, 0.1, 0.8))

        ball_properties.cooldown = false
    end)
end)

local LocalPlayer = Players.LocalPlayer

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoParryDebugGui"
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main frame
local DebugFrame = Instance.new("Frame")
DebugFrame.Size = UDim2.new(0, 180, 0, 280) -- Smaller for Android
DebugFrame.Position = UDim2.new(0, 5, 0, 5)
DebugFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
DebugFrame.BackgroundTransparency = 0.2
DebugFrame.BorderSizePixel = 0
DebugFrame.Parent = ScreenGui

-- Rounded corners
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = DebugFrame

-- Shadow effect
local Shadow = Instance.new("ImageLabel")
Shadow.Size = UDim2.new(1, 16, 1, 16)
Shadow.Position = UDim2.new(0, -8, 0, -8)
Shadow.BackgroundTransparency = 1
Shadow.Image = "rbxassetid://1316045217"
Shadow.ImageTransparency = 0.6
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ScaleType = Enum.ScaleType.Slice
Shadow.SliceCenter = Rect.new(10, 10, 10, 10)
Shadow.ZIndex = -1
Shadow.Parent = DebugFrame

-- Make frame draggable
local dragging, dragInput, dragStart, startPos
DebugFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = DebugFrame.Position
        input:Destroy()
    end
end)

DebugFrame.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        dragInput = input
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

RunService.RenderStepped:Connect(function()
    if dragging and dragInput then
        local delta = dragInput.Position - dragStart
        DebugFrame.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

-- Title bar
local TitleLabel = Instance.new("TextLabel")
TitleLabel.Size = UDim2.new(1, -35, 0, 25)
TitleLabel.Position = UDim2.new(0, 8, 0, 5)
TitleLabel.BackgroundTransparency = 1
TitleLabel.Text = "Debug"
TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.TextSize = 14
TitleLabel.Font = Enum.Font.GothamBold
TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
TitleLabel.Parent = DebugFrame

-- Minimize/maximize button for main frame
local MainToggleButton = Instance.new("TextButton")
MainToggleButton.Size = UDim2.new(0, 25, 0, 25)
MainToggleButton.Position = UDim2.new(1, -30, 0, 5)
MainToggleButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
MainToggleButton.Text = "-"
MainToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MainToggleButton.TextSize = 14
MainToggleButton.Font = Enum.Font.Gotham
MainToggleButton.Parent = DebugFrame
local MainToggleCorner = Instance.new("UICorner")
MainToggleCorner.CornerRadius = UDim.new(0, 5)
MainToggleCorner.Parent = MainToggleButton

local MainToggleStroke = Instance.new("UIStroke")
MainToggleStroke.Color = Color3.fromRGB(100, 100, 100)
MainToggleStroke.Thickness = 1
MainToggleStroke.Parent = MainToggleButton

-- Scrolling frame for debug sections
local DebugContainer = Instance.new("ScrollingFrame")
DebugContainer.Size = UDim2.new(1, -10, 1, -35)
DebugContainer.Position = UDim2.new(0, 5, 0, 30)
DebugContainer.BackgroundTransparency = 1
DebugContainer.ScrollBarThickness = 4
DebugContainer.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
DebugContainer.ClipsDescendants = true
DebugContainer.Parent = DebugFrame

-- UIListLayout for vertical stacking
local ListLayout = Instance.new("UIListLayout")
ListLayout.Padding = UDim.new(0, 4)
ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
ListLayout.Parent = DebugContainer

-- Format long values
local function formatVector3(vec)
    if typeof(vec) == "Vector3" then
        return string.format("(%.2f, %.2f, %.2f)", vec.X, vec.Y, vec.Z)
    end
    return tostring(vec)
end

-- Create debug section
local function createDebugSection(name, index)
    local SectionFrame = Instance.new("Frame")
    SectionFrame.Size = UDim2.new(1, 0, 0, 45) -- Fixed height for expanded
    SectionFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    SectionFrame.BackgroundTransparency = 0.4
    SectionFrame.BorderSizePixel = 0
    SectionFrame.LayoutOrder = index
    SectionFrame.ClipsDescendants = true -- Ensure text stays in frame
    SectionFrame.Parent = DebugContainer

    local SectionCorner = Instance.new("UICorner")
    SectionCorner.CornerRadius = UDim.new(0, 4)
    SectionCorner.Parent = SectionFrame

    local SectionStroke = Instance.new("UIStroke")
    SectionStroke.Color = Color3.fromRGB(80, 80, 80)
    SectionStroke.Thickness = 1
    SectionStroke.Parent = SectionFrame

    local ToggleButton = Instance.new("TextButton")
    ToggleButton.Size = UDim2.new(0, 18, 0, 18)
    ToggleButton.Position = UDim2.new(0, 5, 0, 5)
    ToggleButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    ToggleButton.Text = "-"
    ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleButton.TextSize = 12
    ToggleButton.Font = Enum.Font.Gotham
    ToggleButton.Parent = SectionFrame

    local ToggleButtonCorner = Instance.new("UICorner")
    ToggleButtonCorner.CornerRadius = UDim.new(0, 4)
    ToggleButtonCorner.Parent = ToggleButton

    local NameLabel = Instance.new("TextLabel")
    NameLabel.Size = UDim2.new(1, -60, 0, 18)
    NameLabel.Position = UDim2.new(0, 25, 0, 5)
    NameLabel.BackgroundTransparency = 1
    NameLabel.Text = name .. ":"
    NameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    NameLabel.TextSize = 12
    NameLabel.Font = Enum.Font.SourceSans
    NameLabel.TextXAlignment = Enum.TextXAlignment.Left
    NameLabel.TextScaled = true
    NameLabel.TextTruncate = Enum.TextTruncate.AtEnd
    NameLabel.Parent = SectionFrame

    local ValueLabel = Instance.new("TextLabel")
    ValueLabel.Size = UDim2.new(1, -10, 0, 18)
    ValueLabel.Position = UDim2.new(0, 5, 0, 23)
    ValueLabel.BackgroundTransparency = 1
    ValueLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
    ValueLabel.TextSize = 12
    ValueLabel.Font = Enum.Font.SourceSans
    ValueLabel.TextXAlignment = Enum.TextXAlignment.Left
    ValueLabel.TextScaled = true
    ValueLabel.TextTruncate = Enum.TextTruncate.AtEnd
    ValueLabel.Parent = SectionFrame

    local isCollapsed = false
    ToggleButton.MouseButton1Click:Connect(function()
        isCollapsed = not isCollapsed
        if isCollapsed then
            SectionFrame.Size = UDim2.new(1, 0, 0, 25)
            ToggleButton.Text = "+"
            ValueLabel.Visible = false
        else
            SectionFrame.Size = UDim2.new(1, 0, 0, 45)
            ToggleButton.Text = "-"
            ValueLabel.Visible = true
        end
        DebugContainer.CanvasSize = UDim2.new(0, 0, 0, ListLayout.AbsoluteContentSize.Y)
    end)

    -- Hover animation
    ToggleButton.MouseEnter:Connect(function()
        game:GetService("TweenService"):Create(ToggleButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(80, 80, 80)}):Play()
    end)
    ToggleButton.MouseLeave:Connect(function()
        game:GetService("TweenService"):Create(ToggleButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(60, 60, 60)}):Play()
    end)

    return ValueLabel
end

-- Create debug sections
local debugFields = {
    {name = "Ball Pos", value = function() return formatVector3(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.position or "N/A") end},
    {name = "Dot", value = function()
        if LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.position then
            local ball_position = AutoParry.ball.properties.position
            local character_position = LocalPlayer.Character.PrimaryPart.Position
            local direction_to_ball = (ball_position - character_position).Unit
            local velocity_direction = Player.Entity.properties.velocity.Unit
            return tostring(math.round(direction_to_ball:Dot(velocity_direction) * 100) / 100)
        end
        return "N/A"
    end},
    {name = "isCurved", value = function() return tostring(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.is_curved or false) end},
    {name = "isCurveds", value = function() return tostring(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.is_curveds or false) end},
    {name = "Ping", value = function() return tostring(Player.Entity.properties.ping or 0) .. " ms" end},
    {name = "AutoSpam", value = function() return tostring(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.auto_spam or false) end},
    {name = "Parry", value = function() return lastParryAttempt and "Attempted" or "None" end},
    {name = "Ball Velocity", value = function() return formatVector3(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.velocity or "N/A") end},
    {name = "Ball RotVelocity", value = function() return formatVector3(AutoParry.ball and AutoParry.ball.ball_entity and AutoParry.ball.ball_entity.RotVelocity or "N/A") end},
    {name = "Ball Rotation", value = function() return formatVector3(AutoParry.ball and AutoParry.ball.ball_entity and AutoParry.ball.ball_entity.CFrame.Position or "N/A") end},
    {name = "Ball Speed", value = function() return tostring(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.speed or "N/A") end},
}

local debugLabels = {}
for i, field in ipairs(debugFields) do
    debugLabels[field.name] = createDebugSection(field.name, i)
end

-- Update CanvasSize dynamically
ListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    DebugContainer.CanvasSize = UDim2.new(0, 0, 0, ListLayout.AbsoluteContentSize.Y)
end)

-- Minimize/maximize main frame
local isMinimized = false
MainToggleButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    if isMinimized then
        DebugFrame.Size = UDim2.new(0, 180, 0, 40)
        MainToggleButton.Text = "+"
        DebugContainer.Visible = false
    else
        DebugFrame.Size = UDim2.new(0, 180, 0, 280)
        MainToggleButton.Text = "-"
        DebugContainer.Visible = true
    end
end)

-- Hover animation for main toggle
MainToggleButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(MainToggleButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(80, 80, 80)}):Play()
end)
MainToggleButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(MainToggleButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(50, 50, 50)}):Play()
end)

-- Update debug info
local lastParryAttempt = false
RunService.Heartbeat:Connect(function()
    for _, field in ipairs(debugFields) do
        debugLabels[field.name].Text = field.value()
    end
end)

-- Track parry attempts
local originalPerformParry = AutoParry.perform_parry
AutoParry.perform_parry = function(...)
    lastParryAttempt = true
    task.spawn(function()
        task.wait(0.1) -- Reset after 100ms
        lastParryAttempt = false
    end)
    return originalPerformParry(...)
end

local originalPerformParryCapital = AutoParry.PerformParry
AutoParry.PerformParry = function(...)
    lastParryAttempt = true
    task.spawn(function()
        task.wait(0.1) -- Reset after 100ms
        lastParryAttempt = false
    end)
    return originalPerformParryCapital(...)
end

local function getValidPlayers()
    local players = {}
    local myPosition = LocalPlayer.Character and (LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character.PrimaryPart)
    if not myPosition then return players end
    myPosition = myPosition.Position

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local primaryPart = player.Character:FindFirstChild("HumanoidRootPart") or player.Character.PrimaryPart
            if primaryPart and primaryPart.Position then
                local direction = (primaryPart.Position - myPosition).Unit
                local viewVector = (LocalPlayer.Character:GetPrimaryPartCFrame().LookVector).Unit
                if direction:Dot(viewVector) > math.cos(math.rad(60)) then
                    table.insert(players, {
                        Player = player,
                        Character = player.Character,
                        PrimaryPart = primaryPart,
                        LastPosition = primaryPart.Position,
                        Velocity = primaryPart.AssemblyLinearVelocity or Vector3.zero
                    })
                end
            end
        end
    end
    return players
end

local function getSafeBall()
    local success, ball = pcall(function()
        return AutoParry.get_ball()
    end)
    return success and ball or nil
end

local function predictPosition(currentPos, velocity, time)
    return currentPos + (velocity * time)
end

local function isStuck(currentPos)
    if (currentPos - AIStuckCheck.lastPosition).Magnitude < 1.5 then
        AIStuckCheck.stuckDuration += 1
    else
        AIStuckCheck.stuckDuration = 0
    end
    AIStuckCheck.lastPosition = currentPos
    return AIStuckCheck.stuckDuration > 8
end

local function moveToPosition(character, targetPos, aggressive)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
    if not humanoid or not primaryPart then return end

    local direction = (targetPos - primaryPart.Position).Unit
    local distance = (targetPos - primaryPart.Position).Magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {character}

    local raycastResult = workspace:Raycast(
        primaryPart.Position,
        direction * 8,
        raycastParams
    )

    if raycastResult and raycastResult.Instance then
        if AICooldowns.jump <= 0 and humanoid.FloorMaterial ~= Enum.Material.Air then
            humanoid.Jump = true
            AICooldowns.jump = 0.6 + math.random() * 0.3
        end
    end

    if isStuck(primaryPart.Position) then
        humanoid.Jump = true
        if AICooldowns.dash <= 0 then
            humanoid:MoveTo(primaryPart.Position + (Vector3.new(math.random(-1,1), 0, math.random(-1,1)) * 15))
            AICooldowns.dash = 2 + math.random()
        end
    end

    if aggressive then
        humanoid:MoveTo(targetPos + (direction * 2))
    else
        humanoid:MoveTo(targetPos)
    end
end

local AIMethods = {
    AdvancedPro = function(character)
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not humanoid or not primaryPart then return end

        local ball = getSafeBall()
        local validPlayers = getValidPlayers()
        local target = nil

        if ball and (math.random() > 0.4 or #validPlayers == 0) then
            local predictionTime = 0.5 + math.random() * 0.3
            target = {
                Position = predictPosition(ball.Position, ball.AssemblyLinearVelocity or Vector3.zero, predictionTime),
                Type = "Ball"
            }
        elseif #validPlayers > 0 then
            if AICooldowns.targetSwitch <= 0 or not AITarget then
                AITarget = validPlayers[math.random(math.max(1, #validPlayers - 2), #validPlayers)]
                AICooldowns.targetSwitch = 2 + math.random() * 2
            end

            if AITarget and AITarget.PrimaryPart then
                local predictionTime = 0.4 + math.random() * 0.2
                target = {
                    Position = predictPosition(AITarget.PrimaryPart.Position, AITarget.Velocity, predictionTime),
                    Type = "Player"
                }
            end
        end

        if target then
            local idealDistance = math.random(8, 15)
            local toTarget = (target.Position - primaryPart.Position)
            local moveToPos = target.Position - (toTarget.Unit * idealDistance)

            local shouldJump = (primaryPart.Position - target.Position).Magnitude < 15
                and (target.Position.Y > primaryPart.Position.Y + 1.5)
                and humanoid.FloorMaterial ~= Enum.Material.Air
                and AICooldowns.jump <= 0

            if shouldJump then
                humanoid.Jump = true
                AICooldowns.jump = 0.8 + math.random() * 0.4
            end

            moveToPosition(character, moveToPos, true)
        else
            local wanderPos = primaryPart.Position + Vector3.new(math.random(-25,25), 0, math.random(-25,25))
            moveToPosition(character, wanderPos, false)
        end
    end,

    BallChaser = function(character)
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not humanoid or not primaryPart then return end

        for k, v in pairs(AICooldowns) do
            if v > 0 then AICooldowns[k] = v - 0.1 end
        end

        local ball = getSafeBall()
        if ball then
            local predictedPos = predictPosition(ball.Position, ball.AssemblyLinearVelocity or Vector3.zero, 0.5)
            local distance = (predictedPos - primaryPart.Position).Magnitude
            local timeToReach = distance / humanoid.WalkSpeed
            local moveToPos = predictPosition(ball.Position, ball.AssemblyLinearVelocity or Vector3.zero, timeToReach * 0.7)

            if (ball.Position - primaryPart.Position).Unit:Dot((ball.AssemblyLinearVelocity or Vector3.zero).Unit) > 0.7 then
                moveToPos = ball.Position
            end

            moveToPosition(character, moveToPos, true)

            if distance < 12 and AICooldowns.jump <= 0 then
                humanoid.Jump = true
                AICooldowns.jump = 0.5 + math.random() * 0.3
            end

            if distance > 15 and AICooldowns.dash <= 0 and math.random() > 0.6 then
                humanoid:MoveTo(moveToPos)
                AICooldowns.dash = 2 + math.random()
            end
        else
            AIMethods.AdvancedPro(character)
        end
    end,

    AggressiveHunter = function(character)
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not humanoid or not primaryPart then return end

        for k, v in pairs(AICooldowns) do
            if v > 0 then AICooldowns[k] = v - 0.1 end
        end

        local validPlayers = getValidPlayers()
        if #validPlayers > 0 then
            local closestPlayer = nil
            local closestDistance = math.huge

            for _, player in ipairs(validPlayers) do
                local distance = (primaryPart.Position - player.PrimaryPart.Position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end

            if closestPlayer then
                local predictedPos = predictPosition(
                    closestPlayer.PrimaryPart.Position,
                    closestPlayer.Velocity,
                    0.4
                )
                local flankDirection = (primaryPart.Position - predictedPos).Unit:Cross(Vector3.new(0, 1, 0))
                if math.random() > 0.5 then flankDirection = -flankDirection end
                local flankDistance = math.random(4, 10)
                local moveToPos = predictedPos + (flankDirection * flankDistance)

                if closestPlayer.PrimaryPart.Position.Y > primaryPart.Position.Y + 3 then
                    moveToPos = moveToPos + Vector3.new(0, 3, 0)
                end

                moveToPosition(character, moveToPos, true)

                if closestDistance < 15 and AICooldowns.jump <= 0 then
                    humanoid.Jump = math.random() > 0.2
                    AICooldowns.jump = 0.3 + math.random() * 0.2
                end

                if closestDistance > 10 and AICooldowns.dash <= 0 and math.random() > 0.5 then
                    humanoid:MoveTo(predictedPos)
                    AICooldowns.dash = 2 + math.random()
                end
            end
        else
            local wanderPos = primaryPart.Position + Vector3.new(math.random(-20, 20), 0, math.random(-20, 20))
            moveToPosition(character, wanderPos, false)
        end
    end
}

local function runAI()
    local lastUpdate = os.clock()
    while AIPlaying do
        local character = LocalPlayer.Character
        if character then
            local deltaTime = os.clock() - lastUpdate
            lastUpdate = os.clock()
            for k, v in pairs(AICooldowns) do
                AICooldowns[k] = math.max(0, v - deltaTime)
            end
            local success, err = pcall(function()
                if AIMethods[AICurrentMethod] then
                    AIMethods[AICurrentMethod](character)
                end
            end)
            if not success then
                warn("AI Error:", err)
                AICurrentMethod = "AdvancedPro"
                Config.ai_method = "AdvancedPro"
                WindUI:Notify({
                    Title = "AI Error",
                    Content = "Reverted to AdvancedPro due to error: " .. tostring(err),
                    Duration = 2,
                    Icon = "alert-triangle"
                })
            end
        end
        task.wait(0.1 + math.random() * 0.15)
    end
end

local tweenService = game:GetService("TweenService")
local cam = workspace.CurrentCamera
local player = game.Players.LocalPlayer

local PlayerGui = player:WaitForChild("PlayerGui", 10)
if not PlayerGui then
    warn("PlayerGui not found ngg")
    return
end
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "BallDirectionIndicatorGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Enabled = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = PlayerGui

local Arrow = Instance.new("ImageLabel")
Arrow.Name = "DirectionArrow"
Arrow.Size = UDim2.new(0, 50, 0, 70) 
Arrow.Position = UDim2.new(0.5, 0, 0.6, 0)
Arrow.BackgroundTransparency = 1
Arrow.Image = "rbxassetid://6664693765"
Arrow.ImageTransparency = 0
Arrow.ImageColor3 = Color3.new(1, 1, 1)
Arrow.Visible = false
Arrow.ZIndex = 100
Arrow.Parent = ScreenGui

local targetCounters = {}
local selfParryCounter = 0 -- Counter parry untuk LocalPlayer
local lastNotifyTime = {} -- Cooldown per player
local lastResetTime = tick()
local lastTarget = nil -- Lacak target sebelumnya

-- Fungsi buat cek apakah dalam game (bukan lobby)
local function isInGame()
    return LocalPlayer.Character and 
           LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and 
           workspace.Alive:FindFirstChild(LocalPlayer.Name)
end

-- Fungsi buat floating text
local function createFloatingText(parent, text, offset, isBall)
    if not parent then
        return nil
    end
    if parent:FindFirstChild("FloatingText") then
        parent.FloatingText:Destroy()
    end

    local BillboardGui = Instance.new("BillboardGui")
    BillboardGui.Name = "FloatingText"
    BillboardGui.Parent = parent
    BillboardGui.Adornee = parent
    BillboardGui.Size = UDim2.new(0, 100, 0, isBall and 20 or 40)
    BillboardGui.StudsOffset = offset or Vector3.new(0, isBall and 4.2 or 2, 0)
    BillboardGui.AlwaysOnTop = true
    BillboardGui.MaxDistance = 200 -- Jauh banget
    BillboardGui.ClipsDescendants = true

    local MainText = Instance.new("TextLabel")
    MainText.Name = "MainText"
    MainText.Size = UDim2.new(1, 0, 0.5, 0)
    MainText.Position = UDim2.new(0, 0, 0, 0)
    MainText.BackgroundTransparency = 1
    MainText.Text = text
    MainText.TextColor3 = Color3.fromRGB(255, 255, 255)
    MainText.TextSize = 14
    MainText.Font = Enum.Font.GothamBold
    MainText.TextScaled = true
    MainText.TextStrokeTransparency = 0.8
    MainText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    MainText.Parent = BillboardGui

    local StatusText = Instance.new("TextLabel")
    StatusText.Name = "StatusText"
    StatusText.Size = UDim2.new(1, 0, 0.5, 0)
    StatusText.Position = UDim2.new(0, 0, 0.5, 0)
    StatusText.BackgroundTransparency = 1
    StatusText.Text = ""
    StatusText.TextColor3 = Color3.fromRGB(255, 255, 255)
    StatusText.TextSize = 10
    StatusText.Font = Enum.Font.Gotham
    StatusText.TextScaled = true
    StatusText.TextStrokeTransparency = 0.8
    StatusText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    StatusText.Parent = BillboardGui

    return BillboardGui
end

-- Fungsi buat update warna dan status berdasarkan jarak
local function updatePlayerESP(player, billboard)
    if not Config.visuals_enabled or not isInGame() or not player:FindFirstChild("HumanoidRootPart") then
        return
    end

    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.HumanoidRootPart.Position).Magnitude
    local mainText = billboard.MainText
    local statusText = billboard.StatusText

    if distance < 10 then
        mainText.TextColor3 = Color3.fromRGB(255, 0, 0) -- Merah
        statusText.Text = "Too Close To Player"
        statusText.TextColor3 = Color3.fromRGB(255, 0, 0)
    elseif distance < 20 then
        mainText.TextColor3 = Color3.fromRGB(255, 255, 0) -- Kuning
        statusText.Text = "Mid Distance"
        statusText.TextColor3 = Color3.fromRGB(255, 255, 0)
    else
        mainText.TextColor3 = Color3.fromRGB(0, 255, 0) -- Hijau
        statusText.Text = "Far Distance"
        statusText.TextColor3 = Color3.fromRGB(0, 255, 0)
    end

    mainText.TextTransparency = 0
    mainText.TextStrokeTransparency = 0.8
    statusText.TextTransparency = 0
    statusText.TextStrokeTransparency = 0.8

    -- Cek clash/long parry berdasarkan jarak dan parry count
    local playerName = player.Name
    local lastNotify = lastNotifyTime[playerName] or 0
    if tick() - lastNotify >= 5 then
        if distance < 20 and targetCounters[playerName] and targetCounters[playerName] >= 4 then
            WindUI:Notify({
                Title = "ESP Alert",
                Content = playerName .. " Wanna Clash With You!",
                Duration = 0.5,
            })
            lastNotifyTime[playerName] = tick()
        elseif distance >= 20 and targetCounters[playerName] and targetCounters[playerName] >= 3 and selfParryCounter >= 3 then
            WindUI:Notify({
                Title = "ESP Alert",
                Content = playerName .. " Wanna Long Parry With You!",
                Duration = 0.5,
            })
            lastNotifyTime[playerName] = tick()
        end
    end
end

-- Visuals Connection
ConnectionsManager['visuals'] = RunService.Heartbeat:Connect(function()
    if not Config.visuals_enabled or not isInGame() then
        for _, player in pairs(workspace.Alive:GetChildren()) do
            if player:FindFirstChild("FloatingText") then
                player.FloatingText:Destroy()
            end
        end
        local ball = AutoParry.get_ball()
        if ball and ball:FindFirstChild("FloatingText") then
            ball.FloatingText:Destroy()
        end
        return
    end

    -- Reset target counter tiap 5 detik
    if tick() - lastResetTime >= 10 then
        targetCounters = {}
        selfParryCounter = 0
        lastResetTime = tick()
    end

    -- Floating text buat pemain
    for _, player in pairs(workspace.Alive:GetChildren()) do
        if player ~= LocalPlayer.Character and player:FindFirstChild("HumanoidRootPart") then
            local playerName = player.Name
            local billboard = player:FindFirstChild("FloatingText")
            if not billboard or billboard.MainText.Text ~= playerName then
                billboard = createFloatingText(player.HumanoidRootPart, playerName, Vector3.new(0, 2, 0), false)
            end
            updatePlayerESP(player, billboard)
        end
    end

    -- Floating text dan targeting buat bola
    local ball = AutoParry.get_ball()
    if ball then
        if not ball:FindFirstChild("FloatingText") then
            createFloatingText(ball, "Ball", Vector3.new(0, ball.Size.Y + 1.2, 0), true)
        end

        -- Cek targeting dengan cooldown
        local target = ball:GetAttribute("target")
        if target and target ~= lastTarget then -- Cuma trigger pas target berubah
            lastTarget = target
            if target == LocalPlayer.Name then
                local lastNotify = lastNotifyTime["self"] or 0
                if tick() - lastNotify >= 5 then
                    WindUI:Notify({
                        Title = "ESP Alert",
                        Content = "You are the target!",
                        Duration = 0.05,
                    })
                    lastNotifyTime["self"] = tick()
                    selfParryCounter = selfParryCounter + 1
                end
            elseif target ~= LocalPlayer.Name and workspace.Alive:FindFirstChild(target) then
                targetCounters[target] = (targetCounters[target] or 0) + 1
                local lastNotify = lastNotifyTime[target] or 0
                if tick() - lastNotify >= 5 then
                    if targetCounters[target] == 3 then
                        WindUI:Notify({
                            Title = "ESP Warning",
                            Content = target .. " is targeting you!",
                            Duration = 0.05,
                        })
                        lastNotifyTime[target] = tick()
                    end
                end
            end
        end
    else
        lastTarget = nil -- Reset kalau bola ilang
    end
end)

-- Handle respawn bola
workspace.Balls.ChildRemoved:Connect(function(child)
    is_respawned = false
    if child == AutoParry.ball.ball_entity then
        AutoParry.ball.ball_entity = nil
        AutoParry.ball.client_ball_entity = nil
        ConnectionsManager.disconnect('on_target_change')
        AutoParry.reset()
        if child:FindFirstChild("FloatingText") then
            child.FloatingText:Destroy()
        end
        targetCounters = {} -- Reset counter
        selfParryCounter = 0
        lastTarget = nil
    end
end)

workspace.Balls.ChildAdded:Connect(function()
    if is_respawned then
        return
    end
    is_respawned = true
    local ball_properties = AutoParry.ball.properties
    ball_properties.respawn_time = tick()
    AutoParry.ball.ball_entity = AutoParry.get_ball()
    AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()
    if Config.visuals_enabled and isInGame() then
        local ball = AutoParry.get_ball()
        if ball then
            createFloatingText(ball, "Ball", Vector3.new(0, ball.Size.Y + 1.2, 0), true)
        end
    end
    ConnectionsManager['on_target_change'] = AutoParry.ball.ball_entity:GetAttributeChangedSignal('target'):Connect(function()
        if target == LocalPlayer.Name then
            ball_properties.cooldown = false
            return
        end
        ball_properties.cooldown = false
        ball_properties.old_speed = ball_properties.speed
        ball_properties.last_position = ball_properties.position
        ball_properties.parries += 1
        task.delay(0.25, function()
            if ball_properties.parries > 0 then
                ball_properties.parries -= 1
            end
        end)
    end)
end)

local CustomAnnouncer = {
    enabled = false,
    custom_text = "VicoX Top" -- Default text
}

function CustomAnnouncer:updateAnnouncer()
    if not self.enabled then return end

    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local announcer = playerGui:WaitForChild("announcer")
    local winner = announcer:FindFirstChild("Winner")

    if winner then
        winner.Text = self.custom_text
    end

    
    if not ConnectionsManager['announcer_child_added'] then
        ConnectionsManager['announcer_child_added'] = announcer.ChildAdded:Connect(function(child)
            if child.Name == "Winner" and CustomAnnouncer.enabled then
                child.Text = CustomAnnouncer.custom_text
                
                ConnectionsManager['announcer_text_changed'] = child.Changed:Connect(function(property)
                    if property == "Text" and CustomAnnouncer.enabled then
                        child.Text = CustomAnnouncer.custom_text
                    end
                end)
            end
        end)
    end
end

local PlayerFollow = {
    selected_player = nil,
}

function PlayerFollow:getPlayerNames()
    local names = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(names, player.Name)
        end
    end
    table.sort(names) -- Sort for consistent dropdown order
    return names
end

function PlayerFollow:startFollowing()
    if not Config.player_follow or not Config.follow_target then return end

    local targetPlayer = Players:FindFirstChild(Config.follow_target)
    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character.PrimaryPart then return end

    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("Humanoid") then return end

    char.Humanoid:MoveTo(targetPlayer.Character.PrimaryPart.Position)
end

function PlayerFollow:updatePlayerList()
    local newOptions = self:getPlayerNames()
    local newOptionsString = table.concat(newOptions, ",")
    if newOptionsString ~= self.lastOptionsString then
        if self.dropdown then
            self.dropdown.Values = newOptions -- Update dropdown options
            if #newOptions > 0 then
                if not table.find(newOptions, Config.follow_target) then
                    Config.follow_target = newOptions[1] -- Default to first player if current target is invalid
                    self.dropdown.Value = Config.follow_target
                end
            else
                Config.follow_target = nil
            end
        end
        self.lastOptionsString = newOptionsString
    end
end

PlayerFollow.lastOptionsString = table.concat(PlayerFollow:getPlayerNames(), ",")

local BallTrail = nil
local PlayerTrail = nil
local TrailConnection = nil
local lastTrailUpdateTime = 0

local function CreateTrail(parent, color, name)
    if not parent or not parent:IsA("BasePart") then
        warn("CreateTrail: Invalid or missing parent for " .. tostring(name))
        return nil
    end

    local trail = Instance.new("Trail")
    trail.Name = name

    -- Dynamic color gradient with more keypoints for vibrant effect
    trail.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, color),
        ColorSequenceKeypoint.new(0.3, color:Lerp(Color3.fromRGB(255, 255, 255), 0.5)),
        ColorSequenceKeypoint.new(0.7, color:Lerp(Color3.fromRGB(255, 255, 0), 0.3)),
        ColorSequenceKeypoint.new(1, color:Lerp(Color3.new(0, 0, 0), 0.7))
    })

    -- Dynamic width with animation based on type
    local widthKeypoints = Config.trail_animation_type == "Pulse" and {
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.5, 0.5),
        NumberSequenceKeypoint.new(1, 0.2)
    } or Config.trail_animation_type == "Flicker" and {
        NumberSequenceKeypoint.new(0, 0.8),
        NumberSequenceKeypoint.new(0.25, 0.4),
        NumberSequenceKeypoint.new(0.5, 0.8),
        NumberSequenceKeypoint.new(0.75, 0.4),
        NumberSequenceKeypoint.new(1, 0.2)
    } or {
        NumberSequenceKeypoint.new(0, 0.8),
        NumberSequenceKeypoint.new(1, 0.2)
    }
    trail.WidthScale = NumberSequence.new(widthKeypoints)

    -- Smooth transparency with animation
    local transparencyKeypoints = Config.trail_animation_type == "Pulse" and {
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.5, 0.4),
        NumberSequenceKeypoint.new(1, 0.9)
    } or Config.trail_animation_type == "Flicker" and {
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.25, 0.5),
        NumberSequenceKeypoint.new(0.5, 0),
        NumberSequenceKeypoint.new(0.75, 0.5),
        NumberSequenceKeypoint.new(1, 0.9)
    } or {
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 0.8)
    }
    trail.Transparency = NumberSequence.new(transparencyKeypoints)

    -- Set texture if specified
    if Config.trail_texture == "Spark" then
        trail.Texture = "rbxassetid://299531902" -- Spark texture
    elseif Config.trail_texture == "Flame" then
        trail.Texture = "rbxassetid://243098098" -- Flame texture
    end
    trail.TextureLength = 2
    trail.Lifetime = Config.trail_animation_type == "Flicker" and 0.8 or 1.5
    trail.Enabled = true

    -- Create attachments
    local attachment0 = Instance.new("Attachment")
    attachment0.Name = name .. "Attachment0"
    attachment0.Parent = parent
    local attachment1 = Instance.new("Attachment")
    attachment1.Name = name .. "Attachment1"
    attachment1.Position = Vector3.new(0, -1.5, 0) -- Adjusted for visibility
    attachment1.Parent = parent

    trail.Attachment0 = attachment0
    trail.Attachment1 = attachment1
    trail.Parent = parent

    -- Add particle emitter if enabled
    if Config.trail_particle_enabled then
        local particle = Instance.new("ParticleEmitter")
        particle.Name = name .. "Particles"
        particle.Color = ColorSequence.new(color)
        particle.Size = NumberSequence.new(0.2)
        particle.Rate = Config.trail_particle_rate
        particle.Lifetime = NumberRange.new(0.5, 1)
        particle.Speed = NumberRange.new(2, 5)
        particle.SpreadAngle = Vector2.new(30, 30)
        particle.Texture = Config.trail_texture == "Spark" and "rbxassetid://299531902" or Config.trail_texture == "Flame" and "rbxassetid://243098098" or "rbxassetid://243660364" -- Default particle texture
        particle.Enabled = true
        particle.Parent = attachment0
        Debris:AddItem(particle, 5) -- Clean up particles after 5 seconds
    end

    return trail
end

-- Update ball trail with dynamic effects
local function UpdateBallTrail()
    if Config.ball_trail_enabled then
        local ball = AutoParry and AutoParry.get_ball and AutoParry:get_ball()
        if ball and ball:IsA("BasePart") and ball.Parent then
            if not BallTrail or BallTrail.Parent ~= ball then
                if BallTrail then
                    BallTrail:Destroy()
                    BallTrail = nil
                end
                BallTrail = CreateTrail(ball, Config.ball_trail_color, "BallTrail")
            end
            if BallTrail then
                -- Dynamic color based on ball speed
                local velocity = ball.Velocity.Magnitude
                local speedFactor = math.clamp(velocity / 50, 0, 1)
                local dynamicColor = Config.ball_trail_color:Lerp(Color3.fromRGB(255, 255, 255), speedFactor)
                BallTrail.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, dynamicColor),
                    ColorSequenceKeypoint.new(0.3, dynamicColor:Lerp(Color3.fromRGB(255, 255, 0), 0.5)),
                    ColorSequenceKeypoint.new(0.7, dynamicColor:Lerp(Color3.fromRGB(255, 0, 0), 0.3)),
                    ColorSequenceKeypoint.new(1, dynamicColor:Lerp(Color3.new(0, 0, 0), 0.7))
                })
                BallTrail.Enabled = true
            end
        else
            if BallTrail then
                BallTrail:Destroy()
                BallTrail = nil
            end
        end
    else
        if BallTrail then
            BallTrail:Destroy()
            BallTrail = nil
        end
    end
end

-- Update player trail with dynamic effects
local function UpdatePlayerTrail()
    if Config.player_trail_enabled then
        local character = LocalPlayer.Character
        local hrp = character and (character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart)
        if hrp and hrp:IsA("BasePart") and hrp.Parent then
            if not PlayerTrail or PlayerTrail.Parent ~= hrp then
                if PlayerTrail then
                    PlayerTrail:Destroy()
                    PlayerTrail = nil
                end
                PlayerTrail = CreateTrail(hrp, Config.player_trail_color, "PlayerTrail")
            end
            if PlayerTrail then
                -- Dynamic color based on time for pulsing effect
                local timeFactor = math.sin(tick() * 2) * 0.5 + 0.5
                local dynamicColor = Config.player_trail_color:Lerp(Color3.fromRGB(255, 255, 255), timeFactor)
                PlayerTrail.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, dynamicColor),
                    ColorSequenceKeypoint.new(0.3, dynamicColor:Lerp(Color3.fromRGB(0, 255, 255), 0.5)),
                    ColorSequenceKeypoint.new(0.7, dynamicColor:Lerp(Color3.fromRGB(0, 0, 255), 0.3)),
                    ColorSequenceKeypoint.new(1, dynamicColor:Lerp(Color3.new(0, 0, 0), 0.7))
                })
                PlayerTrail.Enabled = true
            end
        else
            if PlayerTrail then
                PlayerTrail:Destroy()
                PlayerTrail = nil
            end
        end
    else
        if PlayerTrail then
            PlayerTrail:Destroy()
            PlayerTrail = nil
        end
    end
end

local function StartTrailUpdate()
    if TrailConnection then
        TrailConnection:Disconnect()
        TrailConnection = nil
    end
    TrailConnection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime - lastTrailUpdateTime < 0.05 then return end -- Throttle updates to 20 FPS
        lastTrailUpdateTime = currentTime
        pcall(UpdateBallTrail)
        pcall(UpdatePlayerTrail)
    end)
end

local function StopTrailUpdate()
    if TrailConnection then
        TrailConnection:Disconnect()
        TrailConnection = nil
    end
    if BallTrail then
        BallTrail:Destroy()
        BallTrail = nil
    end
    if PlayerTrail then
        PlayerTrail:Destroy()
        PlayerTrail = nil
    end
end

if Config.ball_trail_enabled or Config.player_trail_enabled then
    task.spawn(StartTrailUpdate)
end

do
        local getServiceFunction = game.GetService
        
        local function getClonerefPermission()
            local permission = cloneref(getServiceFunction(game, "ReplicatedFirst"))
            return permission
        end
        
        AutoPlayModule.clonerefPermission = getClonerefPermission()
        
        if not AutoPlayModule.clonerefPermission then
            warn("cloneref is not available on your executor! There is a risk of getting detected.")
        end
        
        function AutoPlayModule.findCachedService(self, name)
            for index, value in self do
                if value.Name == name then
                    return value
                end
            end
            return
        end
        
        function AutoPlayModule.getService(self, name)
            local cachedService = AutoPlayModule.findCachedService(self, name)
        
            if cachedService then
                return cachedService
            end
        
            local service = getServiceFunction(game, name)
        
            if AutoPlayModule.clonerefPermission then
                service = cloneref(service)
            end
        
            table.insert(self, service)
            return service
        end
        
        AutoPlayModule.customService = setmetatable({}, {
            __index = AutoPlayModule.getService
        })
    end
    
    AutoPlayModule.playerHelper = {
        isAlive = function(player)
            local character = nil
        
            if player and player:IsA("Player") then
                character = player.Character
            end
        
            if not character then
                return false
            end
        
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChild("Humanoid")
        
            if not rootPart or not humanoid then
                return false
            end
        
            return humanoid.Health > 0
        end,
        
        inLobby = function(character)
            if not character then
                return false
            end
        
            return character.Parent == AutoPlayModule.customService.Workspace.Dead
        end,
        
        onGround = function(character)
            if not character then
                return false
            end
        
            return character.Humanoid.FloorMaterial ~= Enum.Material.Air
        end
    }
    
    function AutoPlayModule.isLimited()
        local passedTime = tick() - AutoPlayModule.LAST_GENERATION
        return passedTime < AutoPlayModule.CONFIG.GENERATION_THRESHOLD
    end
    
    function AutoPlayModule.percentageCheck(limit)
        if AutoPlayModule.isLimited() then
            return false
        end
    
        local percentage = math.random(100)
        AutoPlayModule.LAST_GENERATION = tick()
    
        return limit >= percentage
    end

    AutoPlayModule.ballUtils = {
        getBall = function()
            for _, object in AutoPlayModule.customService.Workspace.Balls:GetChildren() do
                if object:GetAttribute("realBall") then
                    AutoPlayModule.ball = object
                    return
                end
            end
        
            AutoPlayModule.ball = nil
        end,
        
        getDirection = function()
            if not AutoPlayModule.ball then
                return
            end
        
            local direction = (AutoPlayModule.customService.Players.LocalPlayer.Character.HumanoidRootPart.Position - AutoPlayModule.ball.Position).Unit
            return direction
        end,
        
        getVelocity = function()
            if not AutoPlayModule.ball then
                return
            end
        
            local zoomies = AutoPlayModule.ball:FindFirstChild("zoomies")
        
            if not zoomies then
                return
            end
        
            return zoomies.VectorVelocity
        end,
        
        getSpeed = function()
            local velocity = AutoPlayModule.ballUtils.getVelocity()
        
            if not velocity then
                return
            end
        
            return velocity.Magnitude
        end,
        
        isExisting = function()
            return AutoPlayModule.ball ~= nil
        end
    }
    
    AutoPlayModule.lerp = function(start, finish, alpha)
        return start + (finish - start) * alpha
    end
    
    AutoPlayModule.quadratic = function(start, middle, finish, alpha)
        local firstLerp = AutoPlayModule.lerp(start, middle, alpha)
        local secondLerp = AutoPlayModule.lerp(middle, finish, alpha)
    
        return AutoPlayModule.lerp(firstLerp, secondLerp, alpha)
    end
    
    AutoPlayModule.getCandidates = function(middle, theta, offsetLength)
        local firstCanditateX = math.cos(theta + math.pi / 2)
        local firstCanditateZ = math.sin(theta + math.pi / 2)
        local firstCandidate = middle + Vector3.new(firstCanditateX, 0, firstCanditateZ) * offsetLength
    
        local secondCanditateX = math.cos(theta - math.pi / 2)
        local secondCanditateZ = math.sin(theta - math.pi / 2)
        local secondCandidate = middle + Vector3.new(secondCanditateX, 0, secondCanditateZ) * offsetLength
    
        return firstCandidate, secondCandidate
    end
    
    AutoPlayModule.getControlPoint = function(start, finish)
        local middle = (start + finish) * 0.5
        local difference = start - finish
    
        if difference.Magnitude < 5 then
            return finish
        end
    
        local theta = math.atan2(difference.Z, difference.X)
        local offsetLength = difference.Magnitude * AutoPlayModule.CONFIG.OFFSET_FACTOR
    
        local firstCandidate, secondCandidate = AutoPlayModule.getCandidates(middle, theta, offsetLength)
        local dotValue = start - middle
    
        if (firstCandidate - middle):Dot(dotValue) < 0 then
            return firstCandidate
        else
            return secondCandidate
        end
    end
    
    AutoPlayModule.getCurve = function(start, finish, delta)
        AutoPlayModule.ELAPSED = AutoPlayModule.ELAPSED + delta
        local timeElapsed = math.clamp(AutoPlayModule.ELAPSED / AutoPlayModule.CONFIG.MOVEMENT_DURATION, 0, 1)
    
        if timeElapsed >= 1 then
            local distance = (start - finish).Magnitude
    
            if distance >= 10 then
                AutoPlayModule.ELAPSED = 0
            end
    
            AutoPlayModule.CONTROL_POINT = nil
            return finish
        end
    
        if not AutoPlayModule.CONTROL_POINT then
            AutoPlayModule.CONTROL_POINT = AutoPlayModule.getControlPoint(start, finish)
        end
    
        assert(AutoPlayModule.CONTROL_POINT, "CONTROL_POINT: Vector3 expected, got nil")
        return AutoPlayModule.quadratic(start, AutoPlayModule.CONTROL_POINT, finish, timeElapsed)
    end
    
    AutoPlayModule.map = {
        getFloor = function()
            local floor = AutoPlayModule.customService.Workspace:FindFirstChild("FLOOR")
            
            if not floor then
                for _, part in pairs(AutoPlayModule.customService.Workspace:GetDescendants()) do
                    if part:IsA("MeshPart") or part:IsA("BasePart") then
                        local size = part.Size
                        if size.X > 50 and size.Z > 50 and part.Position.Y < 5 then
                            return part
                        end
                    end
                end
            end
            
            return floor
        end
    }
    
    AutoPlayModule.getRandomPosition = function()
        local floor = AutoPlayModule.map.getFloor()
    
        if not floor or not AutoPlayModule.ballUtils.isExisting() then
            return
        end
    
        local ballDirection = AutoPlayModule.ballUtils.getDirection() * AutoPlayModule.CONFIG.DIRECTION
        local ballSpeed = AutoPlayModule.ballUtils.getSpeed()
    
        local speedThreshold = math.min(ballSpeed / 10, AutoPlayModule.CONFIG.MULTIPLIER_THRESHOLD)
        local speedMultiplier = AutoPlayModule.CONFIG.DEFAULT_DISTANCE + speedThreshold
        local negativeDirection = ballDirection * speedMultiplier
    
        local currentTime = os.time() / 1.2
        local sine = math.sin(currentTime) * AutoPlayModule.CONFIG.TRAVERSING
        local cosine = math.cos(currentTime) * AutoPlayModule.CONFIG.TRAVERSING
    
        local traversing = Vector3.new(sine, 0, cosine)
        local finalPosition = floor.Position + negativeDirection + traversing
    
        return finalPosition
    end
    
    
    AutoPlayModule.lobby = {
        isChooserAvailable = function()
            return AutoPlayModule.customService.Workspace.Spawn.NewPlayerCounter.GUI.SurfaceGui.Top.Options.Visible
        end,
        
        updateChoice = function(choice)
            AutoPlayModule.lobbyChoice = choice
        end,
        
        getMapChoice = function()
            local choice = AutoPlayModule.lobbyChoice or math.random(1, 3)
            local collider = AutoPlayModule.customService.Workspace.Spawn.NewPlayerCounter.Colliders:FindFirstChild(choice)
        
            return collider
        end,
        
        getPadPosition = function()
            if not AutoPlayModule.lobby.isChooserAvailable() then
                AutoPlayModule.lobbyChoice = nil
                return
            end
        
            local choice = AutoPlayModule.lobby.getMapChoice()
        
            if not choice then
                return
            end
        
            return choice.Position, choice.Name
        end
    }
    
    AutoPlayModule.movement = {
        removeCache = function()
            if AutoPlayModule.animationCache then
                AutoPlayModule.animationCache = nil
            end
        end,
        
        createJumpVelocity = function(player)
            local maxForce = math.huge
            local velocity = Instance.new("BodyVelocity")
            velocity.MaxForce = Vector3.new(maxForce, maxForce, maxForce)
            velocity.Velocity = Vector3.new(0, 80, 0)
            velocity.Parent = player.Character.HumanoidRootPart
        
            AutoPlayModule.customService.Debris:AddItem(velocity, 0.001)
            AutoPlayModule.customService.ReplicatedStorage.Remotes.DoubleJump:FireServer()
        end,
        
        playJumpAnimation = function(player)
            if not AutoPlayModule.animationCache then
                local doubleJumpAnimation = AutoPlayModule.customService.ReplicatedStorage.Assets.Tutorial.Animations.DoubleJump
                AutoPlayModule.animationCache = player.Character.Humanoid.Animator:LoadAnimation(doubleJumpAnimation)
            end
        
            if AutoPlayModule.animationCache then
                AutoPlayModule.animationCache:Play()
            end
        end,
        
        doubleJump = function(player)
            if AutoPlayModule.doubleJumped then
                return
            end
        
            if not AutoPlayModule.percentageCheck(AutoPlayModule.CONFIG.DOUBLE_JUMP_PERCENTAGE) then
                return
            end
        
            AutoPlayModule.doubleJumped = true
            AutoPlayModule.movement.createJumpVelocity(player)
            AutoPlayModule.movement.playJumpAnimation(player)
        end,
        
        jump = function(player)
            if not AutoPlayModule.CONFIG.JUMPING_ENABLED then
                return
            end
            
            if not AutoPlayModule.playerHelper.onGround(player.Character) then
                AutoPlayModule.movement.doubleJump(player)
                return
            end
        
            if not AutoPlayModule.percentageCheck(AutoPlayModule.CONFIG.JUMP_PERCENTAGE) then
                return
            end
        
            AutoPlayModule.doubleJumped = false
            player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end,
        
        move = function(player, playerPosition)
            player.Character.Humanoid:MoveTo(playerPosition)
        end,
        
        stop = function(player)
            local playerPosition = player.Character.HumanoidRootPart.Position
            player.Character.Humanoid:MoveTo(playerPosition)
        end
    }
    
    AutoPlayModule.signal = {
        connect = function(name, connection, callback)
            if not name then
                name = AutoPlayModule.customService.HttpService:GenerateGUID()
            end
        
            AutoPlayModule.signals[name] = connection:Connect(callback)
            return AutoPlayModule.signals[name]
        end,
        
        disconnect = function(name)
            if not name or not AutoPlayModule.signals[name] then
                return
            end
        
            AutoPlayModule.signals[name]:Disconnect()
            AutoPlayModule.signals[name] = nil
        end,
        
        stop = function()
            for name, connection in pairs(AutoPlayModule.signals) do
                if typeof(connection) ~= "RBXScriptConnection" then
                    continue
                end
        
                connection:Disconnect()
                AutoPlayModule.signals[name] = nil
            end
        end
    }
    
    AutoPlayModule.findPath = function(inLobby, delta)
        local rootPosition = AutoPlayModule.customService.Players.LocalPlayer.Character.HumanoidRootPart.Position
    
        if inLobby then
            local padPosition, padNumber = AutoPlayModule.lobby.getPadPosition()
            local choice = tonumber(padNumber)
            if choice then
                AutoPlayModule.lobby.updateChoice(choice)
                if getgenv().AutoVote then
                    game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.1.0"):WaitForChild("net"):WaitForChild("RE/UpdateVotes"):FireServer("FFA")
                end
            end
    
            if not padPosition then
                return
            end
    
            return AutoPlayModule.getCurve(rootPosition, padPosition, delta)
        end
    
        local randomPosition = AutoPlayModule.getRandomPosition()
    
        if not randomPosition then
            return
        end
    
        return AutoPlayModule.getCurve(rootPosition, randomPosition, delta)
    end
    
    
    AutoPlayModule.followPath = function(delta)
        if not AutoPlayModule.playerHelper.isAlive(AutoPlayModule.customService.Players.LocalPlayer) then
            AutoPlayModule.movement.removeCache()
            return
        end
    
        local inLobby = AutoPlayModule.customService.Players.LocalPlayer.Character.Parent == AutoPlayModule.customService.Workspace.Dead
        local path = AutoPlayModule.findPath(inLobby, delta)
    
        if not path then
            AutoPlayModule.movement.stop(AutoPlayModule.customService.Players.LocalPlayer)
            return
        end
    
        AutoPlayModule.movement.move(AutoPlayModule.customService.Players.LocalPlayer, path)
        AutoPlayModule.movement.jump(AutoPlayModule.customService.Players.LocalPlayer)
    end
    
    AutoPlayModule.finishThread = function()
        AutoPlayModule.signal.disconnect("auto-play")
        AutoPlayModule.signal.disconnect("synchronize")
        
        if not AutoPlayModule.playerHelper.isAlive(AutoPlayModule.customService.Players.LocalPlayer) then
            return
        end
        
        AutoPlayModule.movement.stop(AutoPlayModule.customService.Players.LocalPlayer)
    end
    
    AutoPlayModule.runThread = function()
        AutoPlayModule.signal.connect("auto-play", AutoPlayModule.customService.RunService.PostSimulation, AutoPlayModule.followPath)
        AutoPlayModule.signal.connect("synchronize", AutoPlayModule.customService.RunService.PostSimulation, AutoPlayModule.ballUtils.getBall)
    end





local function setupVisualRing()
    -- Configuration
    Config.visual_ring = false -- Default: disabled

    -- Ring untuk Spam Range
    local spamRing = Instance.new("Part")
    spamRing.Anchored = true
    spamRing.CanCollide = false
    spamRing.Transparency = 0.2
    spamRing.CastShadow = false
    spamRing.Size = Vector3.new(2, 2, 2) -- Ukuran dasar sesuai kode terbaru
    spamRing.Parent = Workspace

    local spamRingMesh = Instance.new("SpecialMesh", spamRing)
    spamRingMesh.MeshId = "rbxassetid://79874370541467" -- ID mesh dari kode terbaru
    spamRingMesh.TextureId = ""
    spamRingMesh.Scale = Vector3.new(1, 1, 1)

    -- Ring untuk Parry Range
    local parryRing = Instance.new("Part")
    parryRing.Anchored = true
    parryRing.CanCollide = false
    parryRing.Transparency = 0.3
    parryRing.CastShadow = false
    parryRing.Size = Vector3.new(2, 2, 2) -- Ukuran dasar sesuai kode terbaru
    parryRing.Parent = Workspace

    local parryRingMesh = Instance.new("SpecialMesh", parryRing)
    parryRingMesh.MeshId = "rbxassetid://105747096053609" -- ID mesh dari kode terbaru
    parryRingMesh.TextureId = ""
    parryRingMesh.Scale = Vector3.new(1, 1, 1)

    local function getCharacter()
        return LocalPlayer.Character or nil
    end

    local function getPrimaryPart()
        local char = getCharacter()
        return char and char:FindFirstChild("HumanoidRootPart") or nil
    end

    local function getActiveBall()
        local ballCont = Workspace:FindFirstChild("Balls")
        if not ballCont then 
            return nil 
        end
        for _, b in ipairs(ballCont:GetChildren()) do
            if not b.Anchored and b:IsA("BasePart") then 
                return b 
            end
        end
        return nil
    end

    ConnectionsManager['visual_ring'] = RunService.RenderStepped:Connect(function()
        if not Config.visual_ring then
            spamRingMesh.Scale = Vector3.new(0, 0, 0)
            parryRingMesh.Scale = Vector3.new(0, 0, 0)
            spamRing.Transparency = 1
            parryRing.Transparency = 1
            return
        end

        local prim = getPrimaryPart()
        local ball = getActiveBall()
        
        if prim and ball and AutoParry and AutoParry.ball and AutoParry.ball.properties then
            local spamRange = AutoParry.ball.properties.spam_range or 10 -- Fallback
            local parryRange = AutoParry.ball.properties.parry_range or 10 -- Fallback

            -- Spam Ring
            spamRingMesh.Scale = Vector3.new(spamRange, spamRange, spamRange) * 0.1
            local direction = ball.Velocity.Unit
            local lookAtPos = prim.Position + direction * 5
            spamRing.CFrame = CFrame.new(prim.Position + Vector3.new(0, 0.5, 0), lookAtPos) -- Offset kecil ke atas
            spamRing.Transparency = 0.2
            if AutoParry.ball.properties.auto_spam then
                spamRing.Color = Color3.new(1, 0, 0) -- Merah untuk auto_spam
                spamRingMesh.Scale = Vector3.new(30, 30, 30) * 8
            elseif not (AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character) then
                spamRing.Color = Color3.new(0, 1, 0) -- Hijau untuk kondisi normal
            elseif AutoParry.ball.properties.distance < AutoParry.ball.properties.parry_range then
                spamRing.Color = Color3.new(0, 0, 0) -- Hitam jika jarak < parry_range
            else
                spamRing.Color = Color3.new(1, 1, 1) -- Putih untuk kondisi lain
            end

            -- Parry Ring
            parryRingMesh.Scale = Vector3.new(parryRange, parryRange, parryRange) * 0.2 
            parryRing.CFrame = CFrame.new(prim.Position + Vector3.new(0, -0.5, 0), lookAtPos) -- Offset kecil ke bawah
            parryRing.Transparency = 0.3
            parryRing.Color = Color3.new(0, 1, 0) -- Hijau untuk parry range
            if AutoParry.ball.properties.auto_spam then
                parryRing.Color = Color3.new(1, 0, 0) -- Merah untuk auto_spam
                parryRingMesh.Scale = Vector3.new(30, 30, 30) * 5
            end
        else
            spamRingMesh.Scale = Vector3.new(0, 0, 0)
            parryRingMesh.Scale = Vector3.new(0, 0, 0)
            spamRing.Transparency = 1
            parryRing.Transparency = 1
        end
    end)

    local function cleanup()
        if spamRing and spamRing.Parent then
            spamRing:Destroy()
            spamRing = nil
        end
        if parryRing and parryRing.Parent then
            parryRing:Destroy()
            parryRing = nil
        end
        if ConnectionsManager['visual_ring'] then
            ConnectionsManager['visual_ring']:Disconnect()
            ConnectionsManager['visual_ring'] = nil
        end
    end

    local originalAbadone = ConnectionsManager.abadone
    ConnectionsManager.abadone = function()
        originalAbadone()
        cleanup()
    end
end

setupVisualRing()
         


local function setupPlushie()
  
    local plushie_temp = Instance.new("Folder")
    plushie_temp.Name = "PlushieTemp"
    plushie_temp.Parent = Workspace

    
    local plushie_data = {
        Miku = { 
            MeshId = "rbxassetid://7749007933", 
            TextureId = "rbxassetid://7749008046", 
            Scale = Vector3.new(0.2, 0.2, 0.2), -- Lebih kecil lagi
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        SpongeBob = { 
            MeshId = "rbxassetid://5343759781", 
            TextureId = "rbxassetid://5343759854", 
            Scale = Vector3.new(0.8, 0.8, 0.8), -- Tetap
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Patrick = { 
            MeshId = "rbxassetid://5730253467", 
            TextureId = "rbxassetid://5730253510", 
            Scale = Vector3.new(0.4, 0.4, 0.4), -- Lebih kecil lagi
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Sonic = { 
            MeshId = "rbxassetid://5458555841", 
            TextureId = "rbxassetid://5458555873", 
            Scale = Vector3.new(1, 1, 1), -- Tidak diubah
            Angles = CFrame.Angles(0, math.rad(90), 0) -- Tetap
        },
        Shion = { 
            MeshId = "rbxassetid://5701509472", 
            TextureId = "rbxassetid://5701509496", 
            Scale = Vector3.new(2, 2, 2), -- Lebih besar lagi
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Kaito = { 
            MeshId = "rbxassetid://7749025144", 
            TextureId = "rbxassetid://7749025177", 
            Scale = Vector3.new(0.2, 0.2, 0.2), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Reimu = { 
            MeshId = "rbxassetid://12189551557", 
            TextureId = "rbxassetid://12189551941", 
            Scale = Vector3.new(0.6, 0.6, 0.6), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Len = { 
            MeshId = "rbxassetid://7749022295", 
            TextureId = "rbxassetid://7749022336", 
            Scale = Vector3.new(0.2, 0.2, 0.2), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Bear = { 
            MeshId = "rbxassetid://12218321", 
            TextureId = "rbxassetid://12218077", 
            Scale = Vector3.new(1, 1, 1), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, math.rad(90), 0) -- Menghadap ke depan
        },
        Frieren = { 
            MeshId = "rbxassetid://18730983304", 
            TextureId = "rbxassetid://18730984922", 
            Scale = Vector3.new(5, 5, 5), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        }
    }

    -- Nama unik untuk setiap boneka
    local names_map = {
        Miku = "MikuPlushie",
        SpongeBob = "SpongeBobPlushie",
        Patrick = "PatrickPlushie",
        Sonic = "SonicPlushie",
        Shion = "ShionPlushie",
        Kaito = "KaitoPlushie",
        Reimu = "ReimuPlushie",
        Len = "LenPlushie",
        Bear = "BearPlushie",
        Frieren = "FrierenPlushie"
    }

    local function clear_all_plushies()
        if #plushie_temp:GetChildren() == 0 then
            return
        end
        for _, mesh in plushie_temp:GetChildren() do
            Debris:AddItem(mesh, 0)
        end
    end

    local function create_animation(part, tweenInfo, properties)
        local tween = TweenService:Create(part, tweenInfo, properties)
        tween:Play()
        return tween
    end

    local function getCharacter()
        return LocalPlayer.Character or nil
    end

    local function getPrimaryPart()
        local char = getCharacter()
        return char and char:FindFirstChild("HumanoidRootPart") or nil
    end

    ConnectionsManager['plushie'] = RunService.RenderStepped:Connect(function()
        if not Config.plushie_enabled then
            clear_all_plushies()
            return
        end

        if not getCharacter() or not getPrimaryPart() then
            clear_all_plushies()
            return
        end

        local selected_plushie = Config.plushie_type
        local protected_name = names_map[selected_plushie] or "DefaultPlushie"

        if plushie_temp:FindFirstChild(protected_name) then
            local plushie = plushie_temp[protected_name]
            local target_CFrame = getPrimaryPart().CFrame
                * CFrame.new(Vector3.new(-2 - math.cos(tick() / 2), 6.5 + math.cos(tick() / 2), -2 - math.sin(tick() / 2)))
                * (plushie_data[selected_plushie] and plushie_data[selected_plushie].Angles or CFrame.Angles(0, 0, 0))

            create_animation(plushie, TweenInfo.new(1.45), {
                CFrame = target_CFrame
            })
        else
            clear_all_plushies()

            if plushie_data[selected_plushie] then
                local plushie = Instance.new("Part")
                plushie.Anchored = true
                plushie.CanCollide = false
                plushie.Size = Vector3.new(2, 2, 2) -- Ukuran dasar
                plushie.Transparency = 0
                plushie.Name = protected_name
                plushie.Parent = plushie_temp

                local mesh = Instance.new("SpecialMesh", plushie)
                mesh.MeshId = plushie_data[selected_plushie].MeshId
                mesh.TextureId = plushie_data[selected_plushie].TextureId
                mesh.Scale = plushie_data[selected_plushie].Scale -- Skala khusus per boneka
            end
        end
    end)

    local function cleanup()
        clear_all_plushies()
        if plushie_temp and plushie_temp.Parent then
            plushie_temp:Destroy()
            plushie_temp = nil
        end
 
        if ConnectionsManager['plushie'] then
            ConnectionsManager['plushie']:Disconnect()
            ConnectionsManager['plushie'] = nil
        end
    end

    local originalAbadone = ConnectionsManager.abadone
    ConnectionsManager.abadone = function()
        originalAbadone()
        cleanup()
    end
end

setupPlushie() 


function Player:claim_rewards()
    if not Config.auto_rewards then return end
    repeat
        task.wait(1)
    until not AutoParry.ball.properties.auto_spam
    local net = ReplicatedStorage:WaitForChild("Packages")['_Index']['sleitnick_net@0.1.0'].net
    ReplicatedStorage:WaitForChild("Remote"):WaitForChild("RemoteEvent"):FireServer('ClaimLoginReward')
    task.defer(function()
        for day = 1, 30 do
            task.wait()
            ReplicatedStorage.Remote.RemoteFunction:InvokeServer('ClaimNewDailyLoginReward', day)
            net:WaitForChild("RE/SummerWheel/ProcessRoll"):FireServer()
            net:WaitForChild("RE/SummerWheel/ClaimReward"):FireServer()
            net:WaitForChild("RE/ProcessTournamentEventRoll"):FireServer()
            net:WaitForChild("RE/CyborgWheel/ProcessRoll"):FireServer()
            net:WaitForChild("RE/SynthWheel/ProcessRoll"):FireServer()
            net:WaitForChild("RE/ProcessTournamentRoll"):FireServer()
            net:WaitForChild("RE/RolledReturnCrate"):FireServer()
            net:WaitForChild("RE/ProcessLTMRoll"):FireServer()
        end
    end)
    task.defer(function()
        for reward = 1, 6 do
            net:WaitForChild("RF/ClaimPlaytimeReward"):InvokeServer(reward)
            net:WaitForChild("RE/ClaimSeasonPlaytimeReward"):FireServer(reward)
            ReplicatedStorage:WaitForChild("Remote"):WaitForChild("RemoteFunction"):InvokeServer('SpinWheel')
            net:WaitForChild("RE/SpinFinished"):FireServer()
        end
    end)
    task.defer(function()
        for reward = 1, 5 do
            net:WaitForChild("RF/RedeemQuestsType"):InvokeServer('SummerClashEvent', 'Daily', reward)
        end
    end)
    task.defer(function()
        for reward = 1, 4 do
            net:WaitForChild("RE/SummerWheel/ClaimStreakReward"):FireServer(reward)
        end
    end)
    -- New: Additional reward claiming
    task.defer(function()
        net:WaitForChild("RF/RedeemQuestsType"):InvokeServer("Battlepass", "Weekly")
        net:WaitForChild("RF/RedeemQuestsType"):InvokeServer("Battlepass", "Daily")
        net:WaitForChild("RF/ClaimAllDailyMissions"):InvokeServer("Daily")
        net:WaitForChild("RF/ClaimAllDailyMissions"):InvokeServer("Weekly")
        net:WaitForChild("RF/ClaimAllClanBPQuests"):InvokeServer()
        local joinTimestamp = tonumber(LocalPlayer:GetAttribute("JoinedTimestamp")) + 10
        for i = 1, 6 do
            while workspace:GetServerTimeNow() < joinTimestamp + (i * 300) + 1 do
                task.wait(1)
                if not Config.auto_rewards then
                    return
                end
            end
            net:WaitForChild("RF/ClaimPlaytimeReward"):InvokeServer(i)
        end
    end)
end



-- Disable Quantum Effects
ConnectionsManager['disable_quantum_effects'] = RunService.PostSimulation:Connect(function()
    local disable_quantum_enabled = Config.disable_quantum_effects
    if not disable_quantum_enabled then
        for _, v in pairs(getconnections(ReplicatedStorage.Remotes.QuantumArena.OnClientEvent)) do
            v:Enable()
        end
        return
    end
    task.spawn(function()
        while task.wait() and Config.disable_quantum_effects do
            for _, v in pairs(getconnections(ReplicatedStorage.Remotes.QuantumArena.OnClientEvent)) do
                v:Disable()
            end
        end
    end)
end)

-- Play a cool kill effect with dynamic animations
function play_kill_effect(Part)
    if not Part or not Part:IsA("BasePart") then
        warn("play_kill_effect: Invalid or missing Part")
        return
    end

    task.defer(function()
        local success, bell = pcall(function()
            return game:GetObjects("rbxassetid://17519762269")[1]
        end)
        if not success or not bell then
            if WindUI and WindUI.Notify then
                WindUI:Notify({
                    Title = "Kill Effect Error",
                    Content = "Failed to load bell model",
                    Duration = 5,
                    Icon = "alert-triangle"
                })
            end
            return
        end

        bell.Name = 'Yeat_BELL'
        bell.Parent = workspace

        -- Scale the bell
        local scaleFactor = Config.kill_effect_scale
        bell:ScaleTo(scaleFactor)

        -- Set initial position
        bell.Position = Part.Position + Vector3.new(0, 10, 0)

        -- Play sound if available
        local bellSound = bell:FindFirstChild("Sound")
        if bellSound then
            bellSound:Play()
        end

        local TweenService = game:GetService("TweenService")
        local animationType = Config.kill_effect_animation

        -- Add particle emitter for dramatic effect
        local particle = Instance.new("ParticleEmitter")
        particle.Name = "KillEffectParticles"
        particle.Color = ColorSequence.new(Color3.fromRGB(255, 215, 0))
        particle.Size = NumberSequence.new(0.5 * scaleFactor)
        particle.Rate = 20
        particle.Lifetime = NumberRange.new(0.5, 1)
        particle.Speed = NumberRange.new(5, 10)
        particle.SpreadAngle = Vector2.new(45, 45)
        particle.Texture = "rbxassetid://243660364" -- Sparkle particle
        particle.Parent = bell
        particle.Enabled = true
        Debris:AddItem(particle, 5)

        -- Animation based on type
        if animationType == "Spiral" then
            -- Spiral upward with rotation
            local tween1 = TweenService:Create(bell, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                Position = Part.Position + Vector3.new(0, 20, 0),
                Orientation = Vector3.new(0, 360, 0)
            })
            local tween2 = TweenService:Create(bell, TweenInfo.new(1.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
                Position = Part.Position + Vector3.new(0, 50, 0),
                Orientation = Vector3.new(0, 720, 0)
            })
            tween1:Play()
            task.delay(1, function()
                tween2:Play()
            end)
        elseif animationType == "Pulse" then
            -- Pulsing scale and upward movement
            local tween1 = TweenService:Create(bell, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 2, true), {
                CFrame = CFrame.new(Part.Position + Vector3.new(0, 15, 0)) * CFrame.Angles(0, math.rad(45), 0)
            })
            local tween2 = TweenService:Create(bell, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
                Size = Vector3.new(1, 1, 1) * scaleFactor * 1.5
            })
            local tween3 = TweenService:Create(bell, TweenInfo.new(2, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
                Position = Part.Position + Vector3.new(0, 40, 0)
            })
            tween1:Play()
            tween2:Play()
            task.delay(0.5, function()
                tween3:Play()
            end)
        else -- Linear
            -- Smooth upward movement with slight rotation
            local tween1 = TweenService:Create(bell, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                Position = Part.Position + Vector3.new(0, 20, 0),
                Orientation = Vector3.new(0, 90, 0)
            })
            local tween2 = TweenService:Create(bell, TweenInfo.new(1.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
                Position = Part.Position + Vector3.new(0, 50, 0),
                Orientation = Vector3.new(0, 180, 0)
            })
            tween1:Play()
            task.delay(1, function()
                tween2:Play()
            end)
        end

        -- Color transition
        local primaryPart = bell:IsA("Model") and bell.PrimaryPart or bell
        if primaryPart then
            local tweenColor = TweenService:Create(primaryPart, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                BrickColor = BrickColor.new("Really red")
            })
            tweenColor:Play()
        end

        -- Clean up
        Debris:AddItem(bell, 6)
    end)
end

-- Monitor player deaths for kill effect
task.defer(function()
    ConnectionsManager['kill_effect'] = workspace.Alive.ChildRemoved:Connect(function(child)
        if not Config.kill_effect then return end
        if not workspace.Dead:FindFirstChild(child.Name) then return end
        local hrp = child:FindFirstChild("HumanoidRootPart")
        if hrp then
            pcall(function()
                play_kill_effect(hrp)
            end)
        end
    end)
end)

-- Semi-Immortal Module
local function createSemiImmortalSystem()
    local SemiImmortal = {}
    
    function SemiImmortal.init()
        SemiImmortal.enabled = false
        SemiImmortal.notify = false
        SemiImmortal.heartbeatConnection = nil
        
        SemiImmortal.desyncData = {
            originalCFrame = nil,
            originalVelocity = nil
        }
        
        SemiImmortal.cache = {
            character = nil,
            hrp = nil,
            head = nil,
            headOffset = Vector3.new(0, 0, 0),
            aliveFolder = nil
        }
        
        SemiImmortal.constants = {
            emptyCFrame = CFrame.new(),
            radius = 25,
            baseHeight = 5,
            riseHeight = 30,
            cycleSpeed = 11.9,
            velocity = Vector3.new(1, 1, 1)
        }
        
        return SemiImmortal
    end
    
    function SemiImmortal:updateCache()
        local character = LocalPlayer.Character
        if character ~= self.cache.character then
            self.cache.character = character
            if character then
                self.cache.hrp = character:FindFirstChild("HumanoidRootPart")
                self.cache.head = character:FindFirstChild("Head")
                self.cache.aliveFolder = workspace.Alive
                if self.cache.hrp then
                    self.cache.headOffset = Vector3.new(0, self.cache.hrp.Size.Y * 0.5 + 0.5, 0)
                end
            else
                self.cache.hrp = nil
                self.cache.head = nil
            end
        end
    end
    
    function SemiImmortal:isInAliveFolder()
        return self.cache.aliveFolder and self.cache.character and self.cache.character.Parent == self.cache.aliveFolder
    end
    
    function SemiImmortal:calculateOrbitPosition(hrp)
        local angle = math.random(-2147483647, 2147483647) * 1000
        local cycle = math.floor(tick() * self.constants.cycleSpeed) % 2
        local yOffset = cycle == 0 and 0 or self.constants.riseHeight
        
        local pos = hrp.Position
        local yBase = pos.Y - hrp.Size.Y * 0.5 + self.constants.baseHeight + yOffset
        
        return CFrame.new(
            pos.X + math.cos(angle) * self.constants.radius,
            yBase,
            pos.Z + math.sin(angle) * self.constants.radius
        )
    end
    
    function SemiImmortal:performDesync()
        self:updateCache()
        
        if not self.enabled or not self.cache.hrp or not self:isInAliveFolder() then
            return
        end
        
        local hrp = self.cache.hrp
        self.desyncData.originalCFrame = hrp.CFrame
        self.desyncData.originalVelocity = hrp.AssemblyLinearVelocity
        
        hrp.CFrame = self:calculateOrbitPosition(hrp)
        hrp.AssemblyLinearVelocity = self.constants.velocity
        
        RunService.RenderStepped:Wait()
        
        hrp.CFrame = self.desyncData.originalCFrame
        hrp.AssemblyLinearVelocity = self.desyncData.originalVelocity
    end
    
    function SemiImmortal:sendNotification(text)
        if self.notify then
            WindUI:Notify({
                Title = "Semi-Immortal",
                Content = text,
                Duration = 5,
                Icon = "shield"
            })
        end
    end
    
    function SemiImmortal:toggle(enabled)
        if self.enabled == enabled then return end
        
        self.enabled = enabled
        Config.semi_immortal_enabled = enabled
        SaveConfig()
        
        if enabled then
            if not self.heartbeatConnection then
                self.heartbeatConnection = RunService.Heartbeat:Connect(function()
                    self:performDesync()
                end)
            end
        else
            if self.heartbeatConnection then
                self.heartbeatConnection:Disconnect()
                self.heartbeatConnection = nil
            end
            self.desyncData.originalCFrame = nil
            self.desyncData.originalVelocity = nil
        end
        
        self:sendNotification(enabled and "ON" or "OFF")
    end
    
    function SemiImmortal:setNotify(enabled)
        self.notify = enabled
        Config.semi_immortal_notify = enabled
        SaveConfig()
    end
    
    function SemiImmortal:setRadius(value)
        self.constants.radius = value
        Config.semi_immortal_radius = value
        SaveConfig()
    end
    
    function SemiImmortal:setHeight(value)
        self.constants.riseHeight = value
        Config.semi_immortal_height = value
        SaveConfig()
    end
    
    return SemiImmortal
end

-- Rain System Module
local function createRainSystem()
    local RainSystem = {}
    
    function RainSystem.init()
        RainSystem.Particles = {}
        RainSystem.MaxParticles = 5000
        RainSystem.SpawnArea = 500
        RainSystem.FallSpeed = 25
        RainSystem.SpawnHeight = 100
        RainSystem.SpawnRate = 3
        RainSystem.ParticleColor = Color3.fromRGB(100, 200, 255)
        RainSystem.Enabled = false
        
        RainSystem.ParticleFolder = Instance.new("Folder")
        RainSystem.ParticleFolder.Name = "RainParticles"
        RainSystem.ParticleFolder.Parent = workspace
        
        return RainSystem
    end
    
    function RainSystem:createParticle()
        local particle = Instance.new("Part")
        particle.Name = "RainParticle"
        particle.Size = Vector3.new(0.9, 0.9, 0.9)
        particle.Shape = Enum.PartType.Ball
        particle.Material = Enum.Material.Neon
        particle.Color = self.ParticleColor
        particle.CanCollide = false
        particle.Anchored = true
        particle.Transparency = 0
        particle.CastShadow = false
        particle.Parent = self.ParticleFolder
        
        local light = Instance.new("PointLight")
        light.Brightness = 2.5
        light.Range = 10
        light.Color = self.ParticleColor
        light.Parent = particle
        
        local trail = Instance.new("Trail")
        trail.Lifetime = 0.5
        trail.MinLength = 0.1
        trail.FaceCamera = true
        trail.LightEmission = 0.8
        trail.Color = ColorSequence.new(self.ParticleColor)
        trail.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.4),
            NumberSequenceKeypoint.new(1, 1)
        })
        trail.WidthScale = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 1),
            NumberSequenceKeypoint.new(1, 0)
        })
        
        local attachment0 = Instance.new("Attachment", particle)
        local attachment1 = Instance.new("Attachment", particle)
        attachment1.Position = Vector3.new(0, -0.6, 0)
        
        trail.Attachment0 = attachment0
        trail.Attachment1 = attachment1
        trail.Parent = particle
        
        return particle
    end
    
    function RainSystem:getPlayerPosition()
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            return character.HumanoidRootPart.Position
        end
        return workspace.CurrentCamera.CFrame.Position
    end
    
    function RainSystem:spawnParticle()
        if not self.Enabled or #self.Particles >= self.MaxParticles then return end
        
        local player_pos = self:getPlayerPosition()
        local random_x = player_pos.X + math.random(-self.SpawnArea, self.SpawnArea)
        local random_z = player_pos.Z + math.random(-self.SpawnArea, self.SpawnArea)
        local spawn_y = player_pos.Y + self.SpawnHeight
        
        local particle = self:createParticle()
        particle.Position = Vector3.new(random_x, spawn_y, random_z)
        
        table.insert(self.Particles, {
            Part = particle,
            Velocity = Vector3.new(math.random(-2, 2), -self.FallSpeed, math.random(-2, 2)),
            RotationSpeed = Vector3.new(math.random(-3, 3), math.random(-3, 3), math.random(-3, 3)),
            FloatAmplitude = math.random(2, 5),
            FloatFrequency = math.random(2, 4),
            TimeAlive = 0
        })
    end
    
    function RainSystem:update(delta_time)
        local player_pos = self:getPlayerPosition()
        
        for i = #self.Particles, 1, -1 do
            local particle_data = self.Particles[i]
            local particle = particle_data.Part
            
            if not particle or not particle.Parent then
                table.remove(self.Particles, i)
                continue
            end
            
            particle_data.TimeAlive = particle_data.TimeAlive + delta_time
            
            local float_x = math.sin(particle_data.TimeAlive * particle_data.FloatFrequency) * particle_data.FloatAmplitude * delta_time
            local float_z = math.cos(particle_data.TimeAlive * particle_data.FloatFrequency) * particle_data.FloatAmplitude * delta_time
            
            local new_position = particle.Position + Vector3.new(
                particle_data.Velocity.X * delta_time + float_x,
                particle_data.Velocity.Y * delta_time,
                particle_data.Velocity.Z * delta_time + float_z
            )
            
            particle.Position = new_position
            particle.Orientation = particle.Orientation + particle_data.RotationSpeed
            
            local distance_to_player = (new_position - player_pos).Magnitude
            if distance_to_player > self.SpawnArea * 1.5 or new_position.Y < player_pos.Y - 20 then
                particle:Destroy()
                table.remove(self.Particles, i)
            end
        end
    end
    
    function RainSystem:clearAll()
        for i = #self.Particles, 1, -1 do
            if self.Particles[i].Part then
                self.Particles[i].Part:Destroy()
            end
            table.remove(self.Particles, i)
        end
    end
    
    function RainSystem:updateColors()
        for _, particle_data in ipairs(self.Particles) do
            local particle = particle_data.Part
            if particle and particle.Parent then
                particle.Color = self.ParticleColor
                local light = particle:FindFirstChildOfClass("PointLight")
                if light then light.Color = self.ParticleColor end
                local trail = particle:FindFirstChildOfClass("Trail")
                if trail then trail.Color = ColorSequence.new(self.ParticleColor) end
            end
        end
    end
    
    return RainSystem
end

local SemiImmortalModule = createSemiImmortalSystem()
local WalkableSemiImmortal = SemiImmortalModule.init()

local RainSystemModule = createRainSystem()
local ParticleSystem = RainSystemModule.init()

LocalPlayer.CharacterRemoving:Connect(function()
    WalkableSemiImmortal.cache.character = nil
    WalkableSemiImmortal.cache.hrp = nil
    WalkableSemiImmortal.cache.head = nil
    WalkableSemiImmortal.cache.aliveFolder = nil
end)

local hooks = {}
hooks.oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if not WalkableSemiImmortal.enabled or checkcaller() or key ~= "CFrame" or
       not WalkableSemiImmortal.cache.hrp or not WalkableSemiImmortal:isInAliveFolder() then
        return hooks.oldIndex(self, key)
    end
    
    if self == WalkableSemiImmortal.cache.hrp then
        return WalkableSemiImmortal.desyncData.originalCFrame or WalkableSemiImmortal.constants.emptyCFrame
    elseif self == WalkableSemiImmortal.cache.head and WalkableSemiImmortal.desyncData.originalCFrame then
        return WalkableSemiImmortal.desyncData.originalCFrame + WalkableSemiImmortal.cache.headOffset
    end
    
    return hooks.oldIndex(self, key)
end))

local spawn_timer = 0
local spawn_interval = 0.04
RunService.Heartbeat:Connect(function(delta_time)
    if ParticleSystem.Enabled then
        spawn_timer = spawn_timer + delta_time
        if spawn_timer >= spawn_interval then
            for i = 1, ParticleSystem.SpawnRate do
                ParticleSystem:spawnParticle()
            end
            spawn_timer = 0
        end
    end
    ParticleSystem:update(delta_time)
end)

-- Plasma Trails System
local PlasmaTrails = {
    Active = false,
    Enabled = false,
    TrailAttachments = {},
    NumTrails = 8,
    TrailColor = Color3.fromRGB(0, 255, 255)
}

local Plasma = {}

function Plasma.create_trails(ball)
    if PlasmaTrails.Active then return end
    
    PlasmaTrails.Active = true
    PlasmaTrails.TrailAttachments = {}
    
    for i = 1, PlasmaTrails.NumTrails do
        local angle = (i / PlasmaTrails.NumTrails) * math.pi * 2
        local radius = math.random(150, 250) / 100
        local height = math.random(-150, 150) / 100
        
        local offset1 = Vector3.new(
            math.cos(angle) * radius,
            height + math.sin(angle * 3) * 0.8,
            math.sin(angle) * radius
        )
        
        local offset2 = Vector3.new(
            math.cos(angle + math.pi * 0.7) * radius * 1.3,
            -height + math.cos(angle * 2.5) * 0.8,
            math.sin(angle + math.pi * 0.7) * radius * 1.3
        )
        
        local attachment0 = Instance.new("Attachment")
        attachment0.Name = "PlasmaAttachment0_" .. i
        attachment0.Position = offset1
        attachment0.Parent = ball
        
        local attachment1 = Instance.new("Attachment")
        attachment1.Name = "PlasmaAttachment1_" .. i
        attachment1.Position = offset2
        attachment1.Parent = ball
        
        local trail = Instance.new("Trail")
        trail.Name = "PlasmaTrail_" .. i
        trail.Attachment0 = attachment0
        trail.Attachment1 = attachment1
        trail.Lifetime = 0.6
        trail.MinLength = 0
        trail.FaceCamera = true
        trail.LightEmission = 1
        trail.LightInfluence = 0
        trail.Texture = "rbxassetid://5029929719"
        trail.TextureMode = Enum.TextureMode.Stretch
        
        local base_color = PlasmaTrails.TrailColor
        trail.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, base_color),
            ColorSequenceKeypoint.new(0.5, Color3.new(
                math.min(base_color.R * 1.3, 1),
                math.min(base_color.G * 1.3, 1),
                math.min(base_color.B * 1.3, 1)
            )),
            ColorSequenceKeypoint.new(1, base_color)
        })
        
        trail.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.2),
            NumberSequenceKeypoint.new(0.3, 0),
            NumberSequenceKeypoint.new(0.7, 0.3),
            NumberSequenceKeypoint.new(1, 1)
        })
        
        trail.WidthScale = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.1),
            NumberSequenceKeypoint.new(0.3, 0.25),
            NumberSequenceKeypoint.new(0.7, 0.15),
            NumberSequenceKeypoint.new(1, 0.02)
        })
        
        trail.Parent = ball
        
        table.insert(PlasmaTrails.TrailAttachments, {
            attachment0 = attachment0,
            attachment1 = attachment1,
            trail = trail,
            baseAngle = angle,
            angle = 0,
            speed = math.random(15, 30) / 10,
            spiralSpeed = math.random(25, 45) / 10,
            radiusMultiplier = math.random(80, 130) / 100,
            pulseOffset = math.random() * math.pi * 2,
            baseRadius = radius,
            baseHeight = height,
            chaosSpeed = math.random(10, 20) / 10
        })
    end
end

function Plasma.animate_trails(ball, delta_time)
    if not PlasmaTrails.Active then return end
    
    local time = tick()
    
    for _, trail_data in ipairs(PlasmaTrails.TrailAttachments) do
        trail_data.angle = trail_data.angle + trail_data.speed * delta_time
        
        local spiral_angle = trail_data.angle * trail_data.spiralSpeed
        local pulse = math.sin(time * 4 + trail_data.pulseOffset) * 0.4 + 1
        local twist = math.sin(trail_data.angle * 3) * 0.7
        local chaos = math.sin(time * trail_data.chaosSpeed + trail_data.pulseOffset) * 0.5
        
        local radius1 = trail_data.baseRadius * trail_data.radiusMultiplier * pulse
        local radius2 = trail_data.baseRadius * 1.3 * trail_data.radiusMultiplier * pulse
        
        local spiral_offset1 = Vector3.new(
            math.cos(spiral_angle) * 0.6,
            math.sin(spiral_angle * 2) * 0.6,
            math.sin(spiral_angle) * 0.6
        )
        
        local spiral_offset2 = Vector3.new(
            math.sin(spiral_angle * 1.3) * 0.5,
            math.cos(spiral_angle * 1.7) * 0.5,
            math.cos(spiral_angle * 1.1) * 0.5
        )
        
        trail_data.attachment0.Position = Vector3.new(
            math.cos(trail_data.baseAngle + trail_data.angle) * radius1,
            trail_data.baseHeight + math.sin((trail_data.baseAngle + trail_data.angle) * 3) * 0.8 + twist + chaos,
            math.sin(trail_data.baseAngle + trail_data.angle) * radius1
        ) + spiral_offset1
        
        trail_data.attachment1.Position = Vector3.new(
            math.cos(trail_data.baseAngle + trail_data.angle + math.pi * 0.7) * radius2,
            -trail_data.baseHeight + math.cos((trail_data.baseAngle + trail_data.angle) * 2.5) * 0.8 - twist - chaos,
            math.sin(trail_data.baseAngle + trail_data.angle + math.pi * 0.7) * radius2
        ) + spiral_offset2
        
        local brightness = (math.sin(time * 5 + trail_data.pulseOffset) * 0.4 + 0.6)
        trail_data.trail.LightEmission = brightness
    end
end

function Plasma.cleanup_trails(ball)
    if not ball then return end
    
    for _, obj in pairs(ball:GetChildren()) do
        if obj.Name:match("Plasma") then
            obj:Destroy()
        end
    end
    
    PlasmaTrails.Active = false
    PlasmaTrails.TrailAttachments = {}
end

function Plasma.update_trail_colors(ball)
    if not ball then return end
    
    for _, obj in pairs(ball:GetChildren()) do
        if obj:IsA("Trail") and obj.Name:match("PlasmaTrail") then
            local base_color = PlasmaTrails.TrailColor
            obj.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, base_color),
                ColorSequenceKeypoint.new(0.5, Color3.new(
                    math.min(base_color.R * 1.3, 1),
                    math.min(base_color.G * 1.3, 1),
                    math.min(base_color.B * 1.3, 1)
                )),
                ColorSequenceKeypoint.new(1, base_color)
            })
        end
    end
end

local function getPlasmaBall()
    local balls = Workspace:FindFirstChild('Balls')
    if not balls then return nil end
    
    for _, ball in pairs(balls:GetChildren()) do
        if not ball:GetAttribute('realBall') then
            ball.CanCollide = false
            return ball
        end
    end
    return nil
end


local last_plasma_ball = nil

ConnectionsManager['plasma_trails'] = RunService.Heartbeat:Connect(function(delta_time)
    if PlasmaTrails.Enabled then
        local ball = getPlasmaBall()
        
        if ball and ball ~= last_plasma_ball then
            if last_plasma_ball then
                Plasma.cleanup_trails(last_plasma_ball)
            end
            Plasma.create_trails(ball)
            last_plasma_ball = ball
        elseif not ball and last_plasma_ball then
            Plasma.cleanup_trails(last_plasma_ball)
            last_plasma_ball = nil
        end
        
        if ball and PlasmaTrails.Active then
            Plasma.animate_trails(ball, delta_time)
        end
    else
        if last_plasma_ball then
            Plasma.cleanup_trails(last_plasma_ball)
            last_plasma_ball = nil
        end
    end
end)

local originalAbadone = ConnectionsManager.abadone
ConnectionsManager.abadone = function()
    originalAbadone()
    
    
    if last_plasma_ball then
        Plasma.cleanup_trails(last_plasma_ball)
        last_plasma_ball = nil
    end
    
    
    if ConnectionsManager['plasma_trails'] then
        ConnectionsManager['plasma_trails']:Disconnect()
        ConnectionsManager['plasma_trails'] = nil
    end
    
    if ConnectionsManager['plasma_rainbow'] then
        ConnectionsManager['plasma_rainbow']:Disconnect()
        ConnectionsManager['plasma_rainbow'] = nil
    end
end

local SelfEffect = {
    Enabled = false,
    EffectType = "Magic Circle",
    Color = Color3.fromRGB(255, 255, 255),
    Size = 3,
    Speed = 1,
    Brightness = 1,
    CurrentEffect = nil,
    Connection = nil
}

local function cleanupExistingEffects(character)
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    for _, child in pairs(hrp:GetChildren()) do
        if child.Name:match("SelfEffect_") then
            child:Destroy()
        end
    end
    
    local particles = hrp:FindFirstChild("SubtleParticles")
    if particles then particles:Destroy() end
end

local function createAdvancedMagicCircle(character)
    cleanupExistingEffects(character)
    
    local hrp = character.HumanoidRootPart
    local effectFolder = Instance.new("Folder")
    effectFolder.Name = "SelfEffect_MagicCircle"
    effectFolder.Parent = hrp
    
    local rings = {}
    local ringColors = {
        SelfEffect.Color,
        SelfEffect.Color:Lerp(Color3.new(1, 1, 1), 0.3),
        SelfEffect.Color:Lerp(Color3.new(0, 0, 0), 0.3)
    }
    
    for i = 1, 3 do
        local ring = Instance.new("Part")
        ring.Name = "MagicRing_" .. i
        ring.Size = Vector3.new(SelfEffect.Size * (0.7 + i * 0.4), 0.05, SelfEffect.Size * (0.7 + i * 0.4))
        ring.Shape = Enum.PartType.Cylinder
        ring.Material = Enum.Material.Neon
        ring.Color = ringColors[i]
        ring.Transparency = 0.4 + i * 0.2
        ring.CanCollide = false
        ring.Anchored = true
        ring.Parent = effectFolder
        
        local ringLight = Instance.new("PointLight")
        ringLight.Brightness = SelfEffect.Brightness * (1.2 - i * 0.3)
        ringLight.Range = 4 - i
        ringLight.Color = ring.Color
        ringLight.Parent = ring
        
        table.insert(rings, ring)
    end
    
    local floatingRunes = {}
    local runeSymbols = {"âœ¦", "âœ§", "â–", "âœ¶", "âœ´", "âœ³", "âˆ", "â‰", "âš¡", "â„", "??", "ðŸ’§"}
    local runeColors = {
        SelfEffect.Color,
        SelfEffect.Color:Lerp(Color3.new(1, 1, 0), 0.5),
        SelfEffect.Color:Lerp(Color3.new(1, 0, 1), 0.5)
    }
    
    for i = 1, 12 do
        local rune = Instance.new("Part")
        rune.Name = "Rune_" .. i
        rune.Size = Vector3.new(0.3, 0.3, 0.3)
        rune.Shape = Enum.PartType.Ball
        rune.Material = Enum.Material.Glass
        rune.Color = runeColors[(i % 3) + 1]
        rune.Transparency = 0.2
        rune.CanCollide = false
        rune.Anchored = true
        rune.Parent = effectFolder
        
        local runeLight = Instance.new("PointLight")
        runeLight.Brightness = SelfEffect.Brightness * 1.5
        runeLight.Range = 3
        runeLight.Color = rune.Color
        runeLight.Parent = rune
        
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "RuneSymbol"
        billboard.Size = UDim2.new(1.5, 0, 1.5, 0)
        billboard.StudsOffset = Vector3.new(0, 0.6, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = rune
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = runeSymbols[i] or "âœ¦"
        label.TextColor3 = rune.Color:Lerp(Color3.new(1, 1, 1), 0.5)
        label.TextSize = 18
        label.Font = Enum.Font.SourceSansBold
        label.Parent = billboard
        
        table.insert(floatingRunes, {
            Part = rune,
            Light = runeLight,
            Billboard = billboard,
            BaseAngle = (i / 12) * math.pi * 2,
            HeightOffset = math.random() * 2 - 1,
            Speed = 0.8 + math.random() * 0.6,
            ColorIndex = (i % 3) + 1
        })
    end
    
    local centerGlow = Instance.new("Part")
    centerGlow.Name = "CenterGlow"
    centerGlow.Size = Vector3.new(0.5, 0.5, 0.5)
    centerGlow.Shape = Enum.PartType.Ball
    centerGlow.Material = Enum.Material.Neon
    centerGlow.Color = SelfEffect.Color
    centerGlow.Transparency = 0.3
    centerGlow.CanCollide = false
    centerGlow.Anchored = true
    centerGlow.Parent = effectFolder
    
    local centerLight = Instance.new("PointLight")
    centerLight.Name = "CenterLight"
    centerLight.Brightness = SelfEffect.Brightness * 2
    centerLight.Range = 6
    centerLight.Color = SelfEffect.Color
    centerLight.Parent = centerGlow
    
    local energyBeams = {}
    for i = 1, 6 do
        local beam = Instance.new("Part")
        beam.Name = "EnergyBeam_" .. i
        beam.Size = Vector3.new(0.03, 1.5, 0.03)
        beam.Material = Enum.Material.Neon
        beam.Color = SelfEffect.Color:Lerp(Color3.new(1, 1, 1), 0.2)
        beam.Transparency = 0.3
        beam.CanCollide = false
        beam.Anchored = true
        beam.Parent = effectFolder
        
        local beamLight = Instance.new("PointLight")
        beamLight.Brightness = SelfEffect.Brightness * 1.2
        beamLight.Range = 3
        beamLight.Color = beam.Color
        beamLight.Parent = beam
        
        table.insert(energyBeams, beam)
    end
    
    return {
        Folder = effectFolder,
        Rings = rings,
        FloatingRunes = floatingRunes,
        CenterGlow = centerGlow,
        CenterLight = centerLight,
        EnergyBeams = energyBeams,
        StartTime = tick(),
        Rotation = 0
    }
end

local function createAdvancedAura(character)
    cleanupExistingEffects(character)
    
    local hrp = character.HumanoidRootPart
    local effectFolder = Instance.new("Folder")
    effectFolder.Name = "SelfEffect_Aura"
    effectFolder.Parent = hrp
    
    local auraLayers = {}
    local auraColors = {
        SelfEffect.Color,
        SelfEffect.Color:Lerp(Color3.new(1, 1, 1), 0.2),
        SelfEffect.Color:Lerp(Color3.new(0, 0, 0), 0.2),
        SelfEffect.Color:Lerp(Color3.new(1, 0, 0), 0.3)
    }
    
    for i = 1, 4 do
        local aura = Instance.new("Part")
        aura.Name = "AuraLayer_" .. i
        local size = SelfEffect.Size * (0.6 + i * 0.35)
        aura.Size = Vector3.new(size, size, size)
        aura.Shape = Enum.PartType.Ball
        aura.Material = Enum.Material.ForceField
        aura.Color = auraColors[i]
        aura.Transparency = 0.2 + (i-1) * 0.2
        aura.CanCollide = false
        aura.Anchored = true
        aura.Parent = effectFolder
        
        local auraLight = Instance.new("PointLight")
        auraLight.Brightness = SelfEffect.Brightness * (1.5 - (i-1) * 0.3)
        auraLight.Range = 7 - (i-1) * 1.5
        auraLight.Color = aura.Color
        auraLight.Parent = aura
        
        table.insert(auraLayers, {
            Part = aura,
            Light = auraLight,
            BaseSize = size,
            PulseOffset = math.random() * math.pi * 2
        })
    end
    
    local floatingOrbs = {}
    local orbColors = {
        SelfEffect.Color,
        SelfEffect.Color:Lerp(Color3.new(1, 1, 0), 0.4),
        SelfEffect.Color:Lerp(Color3.new(0, 1, 1), 0.4),
        SelfEffect.Color:Lerp(Color3.new(1, 0, 1), 0.4)
    }
    
    for i = 1, 8 do
        local orb = Instance.new("Part")
        orb.Name = "FloatingOrb_" .. i
        orb.Size = Vector3.new(0.35, 0.35, 0.35)
        orb.Shape = Enum.PartType.Ball
        orb.Material = Enum.Material.Neon
        orb.Color = orbColors[(i % 4) + 1]
        orb.Transparency = 0.1
        orb.CanCollide = false
        orb.Anchored = true
        orb.Parent = effectFolder
        
        local orbLight = Instance.new("PointLight")
        orbLight.Brightness = SelfEffect.Brightness * 1.8
        orbLight.Range = 4
        orbLight.Color = orb.Color
        orbLight.Parent = orb
        
        table.insert(floatingOrbs, {
            Part = orb,
            Light = orbLight,
            BaseAngle = (i / 8) * math.pi * 2,
            HeightOffset = math.random() * 2.5 - 1.25,
            Speed = 1 + math.random() * 1.2,
            SpiralSpeed = 0.4 + math.random() * 0.3,
            ColorIndex = (i % 4) + 1
        })
    end
    
    local energyCrystals = {}
    for i = 1, 5 do
        local crystal = Instance.new("Part")
        crystal.Name = "EnergyCrystal_" .. i
        crystal.Size = Vector3.new(0.25, 0.5, 0.25)
        crystal.Material = Enum.Material.Glass
        crystal.Color = SelfEffect.Color:Lerp(Color3.new(1, 1, 1), 0.3)
        crystal.Transparency = 0.15
        crystal.CanCollide = false
        crystal.Anchored = true
        crystal.Parent = effectFolder
        
        local crystalLight = Instance.new("PointLight")
        crystalLight.Brightness = SelfEffect.Brightness * 2
        crystalLight.Range = 3.5
        crystalLight.Color = crystal.Color
        crystalLight.Parent = crystal
        
        table.insert(energyCrystals, {
            Part = crystal,
            Light = crystalLight,
            BaseAngle = (i / 5) * math.pi * 2,
            VerticalOffset = math.random() * 1.5 - 0.75,
            RotationSpeed = 0.6 + math.random() * 0.8,
            FloatSpeed = 0.7 + math.random() * 0.5
        })
    end
    
    local subtleParticles = Instance.new("ParticleEmitter")
    subtleParticles.Name = "SubtleParticles"
    subtleParticles.Parent = hrp
    subtleParticles.Color = ColorSequence.new(SelfEffect.Color)
    subtleParticles.Size = NumberSequence.new(0.15)
    subtleParticles.Transparency = NumberSequence.new(0.5)
    subtleParticles.Lifetime = NumberRange.new(0.8, 1.2)
    subtleParticles.Rate = 12
    subtleParticles.Speed = NumberRange.new(1, 2.5)
    subtleParticles.SpreadAngle = Vector2.new(30, 30)
    subtleParticles.Enabled = true
    
    return {
        Folder = effectFolder,
        AuraLayers = auraLayers,
        FloatingOrbs = floatingOrbs,
        EnergyCrystals = energyCrystals,
        SubtleParticles = subtleParticles,
        StartTime = tick(),
        Rotation = 0
    }
end

local function updateAdvancedMagicCircle(effectData, deltaTime)
    if not effectData or not effectData.Folder or not effectData.Folder.Parent then
        return
    end
    
    local hrp = effectData.Folder.Parent
    local time = tick() - effectData.StartTime
    
    effectData.Rotation = effectData.Rotation + deltaTime * SelfEffect.Speed
    
    for i, ring in ipairs(effectData.Rings) do
        if ring and ring.Parent then
            local pulse = 1 + math.sin(time * 1.8 + i) * 0.08
            local ringSize = SelfEffect.Size * (0.7 + i * 0.4) * pulse
            
            ring.Size = Vector3.new(ringSize, 0.05, ringSize)
            
            local rotation = effectData.Rotation * (0.4 + i * 0.15)
            if i % 2 == 0 then rotation = -rotation end
            
            ring.CFrame = hrp.CFrame
                * CFrame.new(0, -0.9 - i * 0.08, 0)
                * CFrame.Angles(math.pi/2, rotation, 0)
            
            ring.Transparency = 0.4 + i * 0.2 + math.sin(time * 1.5 + i) * 0.1
        end
    end
    
    for _, runeData in ipairs(effectData.FloatingRunes) do
        if runeData.Part and runeData.Part.Parent then
            local orbitAngle = effectData.Rotation * runeData.Speed + runeData.BaseAngle
            local spiralAngle = time * 1.2 + runeData.BaseAngle
            
            local radius = SelfEffect.Size * 1.3 + math.sin(spiralAngle) * 0.3
            local x = math.cos(orbitAngle) * radius
            local y = runeData.HeightOffset + math.sin(spiralAngle * 1.5) * 0.8
            local z = math.sin(orbitAngle) * radius
            
            runeData.Part.CFrame = hrp.CFrame
                * CFrame.new(x, y, z)
                * CFrame.Angles(0, time * 1.5, 0)
            
            if runeData.Light and runeData.Light.Parent then
                local pulse = 0.8 + math.sin(time * 2 + runeData.BaseAngle) * 0.2
                runeData.Light.Brightness = SelfEffect.Brightness * 1.5 * pulse
            end
        end
    end
    
    if effectData.CenterGlow and effectData.CenterGlow.Parent then
        effectData.CenterGlow.CFrame = hrp.CFrame * CFrame.new(0, -0.7, 0)
        if effectData.CenterLight then
            effectData.CenterLight.Brightness = SelfEffect.Brightness * 1.8 + math.sin(time * 2) * 0.3
        end
    end
    
    for i, beam in ipairs(effectData.EnergyBeams) do
        if beam and beam.Parent then
            local angle = effectData.Rotation * 0.6 + (i / 6) * math.pi * 2
            local radius = SelfEffect.Size * 0.6
            
            beam.CFrame = hrp.CFrame
                * CFrame.new(
                    math.cos(angle) * radius,
                    -0.8 + math.sin(time * 1.2 + i) * 0.3,
                    math.sin(angle) * radius
                )
                * CFrame.Angles(0, angle, 0)
            
            beam.Transparency = 0.3 + math.sin(time * 1.5 + i) * 0.2
        end
    end
end

local function updateAdvancedAura(effectData, deltaTime)
    if not effectData or not effectData.Folder or not effectData.Folder.Parent then
        return
    end
    
    local hrp = effectData.Folder.Parent
    local time = tick() - effectData.StartTime
    
    effectData.Rotation = effectData.Rotation + deltaTime * SelfEffect.Speed * 0.8
    
    for _, auraData in ipairs(effectData.AuraLayers) do
        if auraData.Part and auraData.Part.Parent then
            local pulse = 1 + math.sin(time * 1.2 + auraData.PulseOffset) * 0.1
            local size = auraData.BaseSize * pulse
            
            auraData.Part.Size = Vector3.new(size, size, size)
            auraData.Part.CFrame = hrp.CFrame * CFrame.new(0, -0.4, 0)
            
            if auraData.Light and auraData.Light.Parent then
                auraData.Light.Brightness = SelfEffect.Brightness * (1.3 - auraData.PulseOffset * 0.1) + math.sin(time * 1.8 + auraData.PulseOffset) * 0.2
            end
        end
    end
    
    for _, orbData in ipairs(effectData.FloatingOrbs) do
        if orbData.Part and orbData.Part.Parent then
            local spiralAngle = time * orbData.SpiralSpeed
            local orbitAngle = effectData.Rotation * orbData.Speed + orbData.BaseAngle
            
            local x = math.cos(orbitAngle) * (SelfEffect.Size * 1.1)
            local y = orbData.HeightOffset + math.sin(spiralAngle) * 1.2
            local z = math.sin(orbitAngle) * (SelfEffect.Size * 1.1)
            
            orbData.Part.CFrame = hrp.CFrame
                * CFrame.new(x, y, z)
                * CFrame.Angles(0, time * 2, 0)
            
            if orbData.Light and orbData.Light.Parent then
                local pulse = 0.9 + math.sin(time * 2.5 + orbData.BaseAngle) * 0.1
                orbData.Light.Brightness = SelfEffect.Brightness * 1.6 * pulse
            end
        end
    end
    
    for _, crystalData in ipairs(effectData.EnergyCrystals) do
        if crystalData.Part and crystalData.Part.Parent then
            local floatAngle = time * crystalData.FloatSpeed + crystalData.BaseAngle
            local orbitAngle = effectData.Rotation * 0.7 + crystalData.BaseAngle
            
            local radius = SelfEffect.Size * 1.6
            local x = math.cos(orbitAngle) * radius
            local y = crystalData.VerticalOffset + math.sin(floatAngle) * 0.9
            local z = math.sin(orbitAngle) * radius
            
            crystalData.Part.CFrame = hrp.CFrame
                * CFrame.new(x, y, z)
                * CFrame.Angles(time * crystalData.RotationSpeed, 0, math.pi/4)
            
            if crystalData.Light and crystalData.Light.Parent then
                crystalData.Light.Brightness = SelfEffect.Brightness * 1.8 + math.sin(time * 3 + crystalData.BaseAngle) * 0.4
            end
        end
    end
    
    if effectData.SubtleParticles and effectData.SubtleParticles.Parent then
        effectData.SubtleParticles.Rate = 10 + math.sin(time) * 2
    end
end

function SelfEffect:cleanup()
    local player = LocalPlayer
    if player and player.Character then
        cleanupExistingEffects(player.Character)
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local particles = hrp:FindFirstChild("SubtleParticles")
            if particles then particles:Destroy() end
        end
    end
    SelfEffect.CurrentEffect = nil
end

function SelfEffect:update(deltaTime)
    if not SelfEffect.Enabled then
        if SelfEffect.CurrentEffect then
            SelfEffect:cleanup()
        end
        return
    end
    
    local player = LocalPlayer
    if not player or not player.Character then
        SelfEffect:cleanup()
        return
    end
    
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local effectName = "SelfEffect_" .. SelfEffect.EffectType
    local existingEffect = hrp:FindFirstChild(effectName)
    
    if not existingEffect then
        if SelfEffect.EffectType == "Magic Circle" then
            SelfEffect.CurrentEffect = createAdvancedMagicCircle(player.Character)
        elseif SelfEffect.EffectType == "Aura" then
            SelfEffect.CurrentEffect = createAdvancedAura(player.Character)
        end
    elseif SelfEffect.CurrentEffect then
        if SelfEffect.EffectType == "Magic Circle" then
            updateAdvancedMagicCircle(SelfEffect.CurrentEffect, deltaTime)
        elseif SelfEffect.EffectType == "Aura" then
            updateAdvancedAura(SelfEffect.CurrentEffect, deltaTime)
        end
    end
end

function SelfEffect:start()
    if not SelfEffect.Connection then
        SelfEffect.Connection = RunService.Heartbeat:Connect(function(deltaTime)
            SelfEffect:update(deltaTime)
        end)
    end
end

function SelfEffect:stop()
    if SelfEffect.Connection then
        SelfEffect.Connection:Disconnect()
        SelfEffect.Connection = nil
    end
    SelfEffect:cleanup()
end

SelfEffect:start()


Tabs.Home:Paragraph({
    Title = "VicoX - BladeBall (V.Premium-Moderate)",
    Desc = "hello... im back. i guess?",
    Image = "https://play-lh.googleusercontent.com/7cIIPlWm4m7AGqVpEsIfyL-HW4cQla4ucXfcQalMft1TMIYQIlf2vqgmthlZgbNAQoaQ",
    ImageSize = 42,
    Thumbnail = "rbxassetid://124408123120792",
    ThumbnailSize = 120
})

Tabs.Home:Paragraph({
    Title = "Features Here! ðŸ”¥",
    Desc = [[
        â€¢ AutoParry: Automatically parry the ball with insane timing, making you a pro! (Good ping = more OP)
        â€¢ AutoSpam: Spam skills effortlessly, just turn it on and confuse your opponents!
        â€¢ AutoCurve: Make your parry smoother with curve movements, featuring 12 methods!
        â€¢ Skin Changer: Change sword skins to your liking, flex custom skins to stand out!
        â€¢ Background Music: Play with music, choose from 15 cool tracks (Lo-Fi, Vaporwave, etc.) + adjust volume & loop.
        â€¢ Ball Direction Indicator: Know where the ball is going, no more falling for traps!
        â€¢ Visualizer V2: See parry range with cool visuals, making gameplay more tactical.
        â€¢ Camera Lock To Ball: Camera locks onto the ball, choose ThirdPerson, TopDown, or SideView modes!
        â€¢ Text Debug: Ball & player info displayed on-screen, perfect for analysis enthusiasts.
        â€¢ Ball & Player Trail: Add colorful trails to the ball and character, with custom colorpicker!
        â€¢ No Render & Smart Render: Lighten the game, focus on gameplay without lag.
        â€¢ Parry Sound: Add cool sound effects when parrying, choose from 7 types or input custom IDs.
        â€¢ World Filters: Change BladeBallâ€™s vibe, from fog, saturation, to hue shift.
        â€¢ Night Mode: Play in a dark atmosphere, super aesthetic!
        â€¢ Custom Sky: Swap the sky with 18 options, from Default to DaBaby, lol.
        â€¢ Open Crates: Automatically open Sword & Explosion Crates, get rare items!
        â€¢ Strafe & Speed: Agile movements, adjust speed to your preference.
        â€¢ Fly: Freely fly in the arena, supports mobile & PC with joystick/WASD!
        â€¢ Personnel Detector: Detect mods from afar, plus Auto Leave for safety.
        â€¢ Gravity Control: Play with gravity, adjust strength for more fun!
        â€¢ Player Cosmetics: Use Headless or Korblox, make your character stand out.
        â€¢ FOV Camera: Adjust field of view, for wider or more focused vision.
        â€¢ Ability Vulnerability: Add strategy with modes like Quad Jump or Quasar.
        â€¢ AI Play (V1 & V2): Let AI play for you, from BallChaser to AggressiveHunter!
        â€¢ Auto Farm Orbit: Farm coins automatically with cool movements like Helix or Figure8.
        â€¢ Config Save/Load: Save all settings, no need to reset every time you play.
        â€¢ Emotes: Flex custom animations like Dance or Floss while dominating!
        â€¢ Auto Requeue: Auto-join Duels, Ranked, or LTM queues for non-stop grinding!

         And Other All features work (but, you know, fully Script). Heartbeat-based, CMIIW ðŸ¤ž
        Check out new features in other tabs!
    ]],
    Image = "rbxassetid://124408123120792",
    ImageSize = 45
})

Tabs.Home:Button({
    Title = "Dialog Of Owner",
    Callback = function()
        Window:Dialog({
            Title = "[VicoX] Big BladeBall Update",
            Content = "V.Exclusive Version",
            Icon = "bird",
            Buttons = {
                {
                    Title = "[Rudert]\n ... month after month.",
                    Icon = "bird",
                    Variant = "Tertiary",
                    Callback = function()
                        print("i was waiting for so long")
                    end,
                },
                {
                    Title = "[E4X]\n -..",
                    Icon = "bird",
                    Variant = "Tertiary",
                    Callback = function()
                        print("hm")
                    end,
                },
                {
                    Title = "[Fx]\n -",
                    Icon = "bird",
                    Variant = "Secondary",
                    Callback = function()
                        print("mhm")
                    end,
                },
                {
                    Title = "[GhX]\n -.",
                    Icon = "bird",
                    Variant = "Secondary",
                    Callback = function()
                        print("mhm")
                    end,
                },
                {
                    Title = "[Nurysium]\nNot Respond",
                    Icon = "bird",
                    Variant = "Primary",
                    Callback = function() 
                        print(":[]")
                    end,
                }
            }
        })
    end,
})

Tabs.Special:Paragraph({
    Title = "Special Functions",
    Desc = "Advanced and cosmetic features to enhance your gameplay.",
    Image = "rbxassetid://124408123120792",
    ImageSize = 48,
    Color = Color3.fromHex("#8A2BE2")
})

-- Group untuk Immortal (tanpa local)
ImmortalGroup = Tabs.Special:Group({})
ImmortalGroup:Toggle({
    Title = "Walkable Semi-Immortal",
    Flag = "SemiImmortal_SAVE",
    Icon = "shield",
    Desc = "Makes you incredibly hard to hit while remaining mobile.",
    Value = Config.semi_immortal or false,
    Callback = function(value)
        -- LOGIKA LENGKAP
        WalkableSemiImmortal:toggle(value)
    end
})

ImmortalGroup:Space()

ImmortalGroup:Toggle({
    Title = "Notify on Parry",
    Flag = "SemiImmortalNotify_SAVE",
    Value = Config.semi_immortal_notify or false,
    Callback = function(value)
        -- LOGIKA LENGKAP
        WalkableSemiImmortal:setNotify(value)
    end
})

Tabs.Special:Divider()

-- Section untuk Immortal Settings (tanpa local)
ImmortalSettings = Tabs.Special:Section({
    Title = "Immortal Settings",
    Box = true,
    BoxBorder = true,
    Opened = true
})

ImmortalSettings:Slider({
    Title = "Immortal Radius",
    Flag = "SemiImmortalRadius_SAVE",
    Icon = "circle",
    Value = { Min = 0, Max = 100, Default = Config.semi_immortal_radius or 25 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        WalkableSemiImmortal:setRadius(value)
    end
})

ImmortalSettings:Slider({
    Title = "Immortal Height",
    Flag = "SemiImmortalHeight_SAVE",
    Icon = "arrow-up",
    Value = { Min = 0, Max = 60, Default = Config.semi_immortal_height or 30 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        WalkableSemiImmortal:setHeight(value)
    end
})

Tabs.Special:Divider()

-- Section untuk Plushie (tanpa local)
PlushieSection = Tabs.Special:Section({
    Title = "Plushie Companion",
    Desc = "Equip a cute plushie to follow you around.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

PlushieSection:Toggle({
    Title = "Enable Plushie",
    Flag = "Plushie_SAVE",
    Icon = "gift",
    Value = Config.plushie_enabled,
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.plushie_enabled = value
        SaveConfig() -- Simpan perubahan
        WindUI:Notify({
            Title = "Plushie",
            Content = value and "Plushie enabled." or "Plushie disabled.",
            Duration = 1.5,
            Icon = "gift"
        })
    end
})

PlushieSection:Dropdown({
    Title = "Select Plushie",
    Flag = "PlushieSelect_SAVE",
    Values = {"Miku", "SpongeBob", "Patrick", "Sonic", "Shion", "Kaito", "Reimu", "Len", "Bear", "Frieren"},
    Value = Config.plushie_type,
    Callback = function(option)
        -- LOGIKA LENGKAP
        Config.plushie_type = option
        SaveConfig() -- Simpan perubahan
        WindUI:Notify({
            Title = "Plushie Selected",
            Content = "Plushie changed to " .. option,
            Duration = 1.5,
            Icon = "rotate-cw"
        })
    end
})

Tabs.Special:Divider()

-- Section untuk Skin Changer (tanpa local)
SkinChangerSection = Tabs.Special:Section({
    Title = "Skin Changer",
    Desc = "Customize your sword's appearance.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

SkinChangerSection:Toggle({
    Title = "Enable Skin Changer",
    Flag = "SkinChanger_SAVE",
    Icon = "sword",
    Value = Config.skinChanger or false,
    Callback = function(value)
        -- LOGIKA LENGKAP
        getgenv().skinChanger = value
        Config.skinChanger = value
        SaveConfig() -- Simpan perubahan
        if value then
            getgenv().updateSword()
            WindUI:Notify({
                Title = "Skin Changer",
                Content = "Skin Changer enabled.",
                Duration = 1.5,
                Icon = "sword"
            })
        end
    end
})

SkinChangerSection:Space()

-- Group untuk detail Skin Changer (tanpa local)
SkinDetailGroup = Tabs.Special:Group({})

SkinDetailGroup:Toggle({
    Title = "Change Sword Model",
    Flag = "ChangeSwordModel_SAVE",
    Icon = "package",
    Value = Config.changeSwordModel ~= nil and Config.changeSwordModel or true,
    Callback = function(value)
        -- LOGIKA LENGKAP
        getgenv().changeSwordModel = value
        Config.changeSwordModel = value
        SaveConfig() -- Simpan perubahan
        if getgenv().skinChanger and value then
            getgenv().updateSword()
        end
        WindUI:Notify({
            Title = "Sword Model",
            Content = "Sword model change " .. (value and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "package"
        })
    end
})

SkinDetailGroup:Toggle({
    Title = "Change Sword Animation",
    Flag = "ChangeSwordAnimation_SAVE",
    Icon = "play",
    Value = Config.changeSwordAnimation ~= nil and Config.changeSwordAnimation or true,
    Callback = function(value)
        -- LOGIKA LENGKAP
        getgenv().changeSwordAnimation = value
        Config.changeSwordAnimation = value
        SaveConfig() -- Simpan perubahan
        if getgenv().skinChanger and value then
            getgenv().updateSword()
        end
        WindUI:Notify({
            Title = "Sword Animation",
            Content = "Sword animation change " .. (value and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "play"
        })
    end
})

SkinDetailGroup:Toggle({
    Title = "Change Sword FX",
    Flag = "ChangeSwordFX_SAVE",
    Icon = "sparkles",
    Value = Config.changeSwordFX ~= nil and Config.changeSwordFX or true,
    Callback = function(value)
        -- LOGIKA LENGKAP
        getgenv().changeSwordFX = value
        Config.changeSwordFX = value
        SaveConfig() -- Simpan perubahan
        if getgenv().skinChanger and value then
            getgenv().updateSword()
        end
        WindUI:Notify({
            Title = "Sword FX",
            Content = "Sword FX change " .. (value and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "sparkles"
        })
    end
})

SkinChangerSection:Space()

SkinChangerSection:Input({
    Title = "All-in-One Sword Name",
    Flag = "SkinChangerAllInOne_SAVE",
    Icon = "swords",
    Placeholder = "e.g., Ace, Zeus...",
    Value = Config.swordModel or "",
    Callback = function(input)
        -- LOGIKA LENGKAP
        if input ~= "" then
            getgenv().swordModel = input
            getgenv().swordAnimations = input
            getgenv().swordFX = input
            Config.swordModel = input
            Config.swordAnimations = input
            Config.swordFX = input
            SaveConfig() -- Simpan perubahan
            if getgenv().skinChanger then
                getgenv().updateSword()
                WindUI:Notify({
                    Title = "Skin Changer",
                    Content = "Set all sword properties to: " .. input,
                    Duration = 2,
                    Icon = "swords"
                })
            end
        end
    end
})

SkinChangerSection:Space()

SkinChangerSection:Button({
    Title = "Apply Separated Settings",
    Icon = "refresh-cw",
    Justify = "Center",
    Callback = function()      
        -- LOGIKA LENGKAP
        getgenv().updateSword()
        WindUI:Notify({
            Title = "Skin Changer",
            Content = "Applied all separated settings.",
            Duration = 1.5,
            Icon = "check"
        })       
    end
})

Tabs.Special:Divider()

-- Section untuk Music (tanpa local)
MusicSection = Tabs.Special:Section({
    Title = "Background Music",
    Desc = "Play your favorite tunes while you dominate.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

MusicSection:Toggle({
    Title = "Enable Music",
    Flag = "BackgroundMusic_SAVE",
    Icon = "music",
    Value = Config.background_music or false,
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.background_music = value
        SaveConfig() -- Simpan perubahan
        if value then
            playSound()
        else
            currentSound:Stop()
            WindUI:Notify({
                Title = "Background Music",
                Content = "Music stopped.",
                Duration = 1.5,
                Icon = "music"
            })
        end
    end
})

MusicSection:Dropdown({
    Title = "Select Song",
    Flag = "BackgroundMusicSelectSong_SAVE",
    Icon = "list-music",
    Values = {
        "back it up", "Sweep", "Bounce", "Everybody Wants To Rule The World",
        "Missing Money", "Sour Grapes", "Erwachen", "Grasp the Light",
        "Beyond the Shadows", "Rise to the Horizon", "Echoes of the Candy Kingdom",
        "Speed", "Lo-fi Chill A", "Lo-fi Ambient", "Tears in the Rain"
    },
    Value = Config.selected_song or "back it up",
    Callback = function(value)
        -- LOGIKA LENGKAP
        selectedSound = value
        Config.selected_song = value
        SaveConfig() -- Simpan perubahan
        if currentSound.Playing then
            playSound()
        else
            WindUI:Notify({
                Title = "Song Selected",
                Content = "Selected: " .. value,
                Duration = 1.5,
                Icon = "list-music"
            })
        end
    end
})

MusicSection:Space()

-- Group untuk kontrol musik (tanpa local)
MusicControlGroup = Tabs.Special:Group({})

MusicControlGroup:Toggle({
    Title = "Loop Song",
    Flag = "BackgroundMusicLoop_SAVE",
    Icon = "repeat",
    Value = Config.loop_song or false,
    Callback = function(value)
        -- LOGIKA LENGKAP
        currentSound.Looped = value
        Config.loop_song = value
        SaveConfig() -- Simpan perubahan
        WindUI:Notify({
            Title = "Loop Song",
            Content = value and "Loop enabled" or "Loop disabled",
            Duration = 1.5,
            Icon = "repeat"
        })
    end
})

MusicControlGroup:Slider({
    Title = "Volume",
    Flag = "BackgroundMusicVolume_SAVE",
    Icon = "volume-high",   
    Value = { Min = 1, Max = 5, Default = Config.music_volume or 3 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        currentSound.Volume = value
        Config.music_volume = value
        SaveConfig() -- Simpan perubahan
        WindUI:Notify({
            Title = "Volume",
            Content = "Volume set to " .. string.format("%.1f", value),
            Duration = 1.5,
            Icon = "volume-high"
        })
    end
})

Tabs.Blatant:Paragraph({
    Title = "GAME: BLADEBALL",
    Desc = "Dominate the arena with these powerful tools.",
    Image = "rbxassetid://124408123120792",
    ImageSize = 48,
    Thumbnail = "https://tr.rbxcdn.com/180DAY-59af3523ad8898216dbe1043788837bf/768/432/Image/Webp/noFilter",
    ThumbnailSize = 120,
    Buttons = {
        {
            Title = "Reset Parry (If bug)",
            Variant = "Primary",
            Callback = function() AutoParry.reset() end,
            Icon = "refresh-ccw",
        }
    }
})

-- Section untuk Parry Utama
BlatantMainSection = Tabs.Blatant:Section({
    Title = "Main Auto Parry & Spam",
    Box = true,
    BoxBorder = true,
    Opened = true
})

BlatantMainSection:Toggle({
    Title = "Auto Parry",
    Flag = "AutoParry_SAVE",
    Icon = "swords",
    Value = Config.auto_parry,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.auto_parry = state
        SaveConfig()
        WindUI:Notify({
            Title = "Auto Parry",
            Content = "Auto Parry " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "swords"
        })
    end
})

BlatantMainSection:Dropdown({
    Title = "Parry Mode",
    Flag = "AutoParryMode_SAVE",
    Desc = "(Blatant for power, Legit for subtlety)",
    Values = {"Legit", "Blatant"},
    Value = Config.parry_mode or "Blatant",
    Callback = function(option)
        -- LOGIKA LENGKAP
        parry_mode = option
        Config.parry_mode = option
        SaveConfig()
        WindUI:Notify({
            Title = "Parry Mode",
            Content = "Parry Mode changed to " .. option,
            Duration = 1.5,
            Icon = "rotate-cw"
        })
    end
})

BlatantMainSection:Divider()

BlatantMainSection:Slider({
    Title = "Spam Speed",
    Value = { Min = 1, Max = 100, Default = Config.spam_speed or 13 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        getgenv().speeddo = value
        Config.spam_speed = value
        SaveConfig()
        WindUI:Notify({
            Title = "Spam Speed",
            Content = "Spam Speed set to " .. value,
            Duration = 1.5,
            Icon = "sliders-horizontal"
        })
    end
})

BlatantMainSection:Divider()

BlatantMainSection:Toggle({
    Title = "Triggerbot Helper",
    Flag = "TriggerBot_SAVE",
    Desc = "Automatically parry when the ball is in range and conditions are met.",
    Icon = "crosshair",
    Value = Config.triggerbot,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.triggerbot = state
        SaveConfig()
        if state then
            if not ConnectionsManager["triggerbot"] then
                ConnectionsManager["triggerbot"] = RunService.PostSimulation:Connect(function()
                    -- Logika triggerbot yang panjang dan lengkap
                    local character = LocalPlayer.Character
                    if not character or not character:FindFirstChild("HumanoidRootPart") or character.Parent == workspace.Dead then
                        return
                    end

                    local ball = AutoParry.get_ball()
                    if not ball or not AutoParry.ball.ball_entity then
                        return
                    end

                    local ball_properties = AutoParry.ball.properties
                    local singularityCape = character.PrimaryPart:FindFirstChild('SingularityCape')
                    if singularityCape then
                        return
                    end

                    local ping_threshold = math.clamp(Player.Entity.properties.ping / 10, 15, 20)
                    local parry_range = (ping_threshold + ball_properties.speed) * 2 / math.pi

                    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
                        if ball_properties.distance > parry_range then
                            return
                        end
                        
                        ball_properties.is_curved = AutoParry.is_curved()
                        ball_properties.is_curveds = AutoParry.is_curveds()
                        if ball_properties.is_curved or ball_properties.is_curveds then
                            return
                        end

                        if (tick() - ball_properties.last_hit) < (1 - math.clamp(ping_threshold / 100, 0.1, 0.7)) then
                            return
                        end

                        task.spawn(function() AutoParry:PerformParry() end)
                        ball_properties.last_hit = tick()
                    end
                end)
            end
        else
            if ConnectionsManager["triggerbot"] then
                ConnectionsManager["triggerbot"]:Disconnect()
                ConnectionsManager["triggerbot"] = nil
            end
        end
        WindUI:Notify({
            Title = "Triggerbot",
            Content = "Triggerbot " .. (state and "enabled" or "disabled"),
            Duration = 2,
            Icon = "crosshair"
        })
    end
})

BlatantMainSection:Toggle({
    Title = "Auto Ability",
    Flag = "AutoAbility_SAVE",
    Value = Config.auto_ability or false,
    Callback = function(state)
        -- LOGIKA LENGKAP
        AutoAbility.enabled = state
        Config.auto_ability = state
        SaveConfig()
        WindUI:Notify({
            Title = "Auto Ability",
            Content = "Auto Ability " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
        })
    end
})

BlatantMainSection:Divider()

BlatantMainSection:Dropdown({
    Title = "Parry Method",
    Flag = "ParryMethodeFire_SAVE",
    Desc = "Use 'Hook' for stability. 'getgc' might be patched.",
    Values = { "getgc", "Hook" },
    Value = Config.selected_parry_method or "Hook",
    Callback = function(option)
        -- LOGIKA LENGKAP
        SelectedParryMethod = option
        Config.selected_parry_method = option
        SaveConfig()
        WindUI:Notify({
            Title = "Parry Method",
            Content = "Parry Method changed to " .. option,
            Duration = 1.5,
            Icon = "rotate-cw"
        })
    end
})

BlatantMainSection:Toggle({
    Title = "Manual Spam",
    Flag = "ManualSpam_SAVE",
    Icon = "swords",
    Value = Config.manual_spam,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.manual_spam = state
        SaveConfig()
        if state then
            ManualSpam() 
        else
            if ManualSpamGui then
                ManualSpam()
            end
        end
        WindUI:Notify({
            Title = "Manual Spam",
            Content = "Manual Spam " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "swords"
        })
    end
})

Tabs.Blatant:Divider()

-- Section untuk Rotasi
BlatantRotationSection = Tabs.Blatant:Section({
    Title = "Player Rotation",
    Box = true,
    BoxBorder = true,
    Opened = false
})

BlatantRotationSection:Toggle({
    Title = "Rotation",
    Flag = "Rotation_SAVE",
    Icon = "rotate-cw",
    Value = Config.auto_parry_rotation,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.auto_parry_rotation = state
        SaveConfig()
        WindUI:Notify({
            Title = "Rotation",
            Content = "Rotation " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "rotate-cw"
        })
    end
})

BlatantRotationSection:Slider({
    Title = "Rotation Acuity",
    Flag = "RotationAcuity_SAVE",
    Icon = "sliders-horizontal",
    Value = { Min = 0, Max = 100, Default = Config.auto_parry_rotation_acuity or 5 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.auto_parry_rotation_acuity = value
        SaveConfig()
        WindUI:Notify({
            Title = "Rotation Acuity",
            Content = "Acuity set to " .. value,
            Duration = 1.5,
            Icon = "sliders-horizontal"
        })
    end
})

Tabs.Blatant:Divider()

-- Section untuk Curve
BlatantCurveSection = Tabs.Blatant:Section({
    Title = "Curve Parry",
    Desc = "Make your parry less predictable with curve movements.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

BlatantCurveSection:Dropdown({
    Title = "Curve Method",
    Flag = "CurveMethodeParry_SAVE",
    Icon = "chevrons-up-down",
    Values = { "Linear", "Backwards", "Random", "Accelerated", "Right", "Left", "Up", "Down", "Normal", "FollowCamera", "Forward", "Circular" },
    Value = Config.curve_method,
    Callback = function(option)
        -- LOGIKA LENGKAP
        Config.curve_method = option
        SaveConfig()
        WindUI:Notify({
            Title = "Curve Method",
            Content = "Curve Method set to " .. option,
            Duration = 1.5,
            Icon = "chevrons-up-down"
        })
    end
})

Tabs.Blatant:Divider()

-- Section untuk No Slow
BlatantMiscSection = Tabs.Blatant:Section({
    Title = "Miscellaneous",
    Box = true,
    BoxBorder = true,
    Opened = false
})

BlatantMiscSection:Toggle({
    Title = "No Slow",
    Flag = "NoSlow_SAVE",
    Icon = "zap",
    Value = Config.no_slow,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.no_slow = state
        SaveConfig()
        WindUI:Notify({
            Title = "No Slow",
            Content = "No Slow " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "zap"
        })
    end
})

Tabs.Visuals:Paragraph({
    Title = "Visual Enhancements",
    Desc = "Customize your world and effects. See the game your way.",
    Image = "rbxassetid://129260712070622",
    ImageSize = 48,
    Color = Color3.fromHex("#00BFFF")
})

VisualsPlasmaSection = Tabs.Visuals:Section({
    Title = "Plasma Ball Trails",
    Desc = "Add stunning, animated trails to the ball.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

VisualsPlasmaSection:Toggle({
    Title = "Enable Plasma Trails",
    Flag = "PlasmaTrails_SAVE",
    Icon = "zap",
    Value = Config.plasma_trails_enabled,
    Callback = function(state)
        PlasmaTrails.Enabled = state
        Config.plasma_trails_enabled = state
        SaveConfig()
        
        if not state and last_plasma_ball then
            Plasma.cleanup_trails(last_plasma_ball)
            last_plasma_ball = nil
        end
        
        WindUI:Notify({
            Title = "Plasma Trails",
            Content = "Plasma Trails " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "zap"
        })
    end
})

VisualsPlasmaSection:Slider({
    Title = "Number of Trails",
    Flag = "PlasmaTrailsCount_SAVE",
    Icon = "hash",
    Value = { Min = 2, Max = 16, Default = Config.plasma_trails_count or 8 },
    Callback = function(value)
        PlasmaTrails.NumTrails = value
        Config.plasma_trails_count = value
        SaveConfig()
        
        if last_plasma_ball and PlasmaTrails.Enabled then
            Plasma.cleanup_trails(last_plasma_ball)
            Plasma.create_trails(last_plasma_ball)
        end
        
        WindUI:Notify({
            Title = "Plasma Trails",
            Content = "Number of trails set to " .. value,
            Duration = 1.5,
            Icon = "hash"
        })
    end
})

VisualsPlasmaSection:Colorpicker({
    Title = "Trail Color",
    Flag = "PlasmaTrailsColor_SAVE",
    Icon = "palette",
    Value = Config.plasma_trails_color,
    Callback = function(color)
        PlasmaTrails.TrailColor = color
        Config.plasma_trails_color = color
        SaveConfig()
        
        if last_plasma_ball then
            Plasma.update_trail_colors(last_plasma_ball)
        end
        
        WindUI:Notify({
            Title = "Plasma Trails",
            Content = "Trail color updated",
            Duration = 1.5,
            Icon = "palette"
        })
    end
})

VisualsPlasmaSection:Divider()

VisualsPlasmaPresetsGroup = Tabs.Visuals:Group({})
local colorPresets = {
    ["Cyan"] = Color3.fromRGB(0, 255, 255),
    ["Red"] = Color3.fromRGB(255, 50, 50),
    ["Green"] = Color3.fromRGB(0, 255, 0),
    ["Rainbow"] = Color3.fromRGB(255, 0, 0)
}

for presetName, color in pairs(colorPresets) do
    VisualsPlasmaPresetsGroup:Button({
        Title = presetName,
        Icon = "palette",
        Callback = function()
            PlasmaTrails.TrailColor = color
            Config.plasma_trails_color = color
            SaveConfig()
            if last_plasma_ball then
                Plasma.update_trail_colors(last_plasma_ball)
            end
            WindUI:Notify({
                Title = "Plasma Trails",
                Content = "Color preset: " .. presetName,
                Duration = 1.5,
                Icon = "palette"
            })
            print('Applying color preset: ' .. presetName)
        end
    })
end

VisualsPlasmaSection:Toggle({
    Title = "Rainbow Mode",
    Flag = "PlasmaRainbowMode_SAVE",
    Icon = "rainbow",
    Value = Config.plasma_rainbow_mode,
    Callback = function(state)
        Config.plasma_rainbow_mode = state
        SaveConfig()
        print('Rainbow mode is now ' .. tostring(state))
        WindUI:Notify({
            Title = "Plasma Trails",
            Content = "Rainbow mode " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "rainbow"
        })
    end
})

if not ConnectionsManager['plasma_rainbow'] then
    ConnectionsManager['plasma_rainbow'] = RunService.Heartbeat:Connect(function()
        if Config.plasma_rainbow_mode and PlasmaTrails.Enabled then
            local hue = (tick() * 0.5) % 1
            PlasmaTrails.TrailColor = Color3.fromHSV(hue, 1, 1)
            if last_plasma_ball then
                Plasma.update_trail_colors(last_plasma_ball)
            end
        end
    end)
end

Tabs.Visuals:Divider()

VisualsParticleSection = Tabs.Visuals:Section({
    Title = "Particle Rain",
    Desc = "Make it rain with custom particles.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

VisualsParticleSection:Toggle({
    Title = "Enable Particle Rain",
    Flag = "ParticleRain_SAVE",
    Icon = "cloud-rain",
    Value = Config.particle_rain_enabled or false,
    Callback = function(state)
        ParticleSystem.Enabled = state
        Config.particle_rain_enabled = state
        SaveConfig()
        if not state then ParticleSystem:clearAll() end
        WindUI:Notify({
            Title = "Particle Rain",
            Content = "Particle Rain " .. (state and "enabled" or "disabled"),
            Duration = 2,
            Icon = "cloud-rain"
        })
    end
})

VisualsParticleSection:Slider({
    Title = "Max Particles",
    Flag = "MaxParticles_SAVE",
    Icon = "hash",
    Value = { Min = 100, Max = 20000, Default = Config.particle_rain_max or 5000 },
    Callback = function(value)
        ParticleSystem.MaxParticles = value
        Config.particle_rain_max = value
        SaveConfig()
    end
})

VisualsParticleSection:Slider({
    Title = "Spawn Rate",
    Flag = "SpawnRate_SAVE",
    Icon = "zap",
    Value = { Min = 1, Max = 25, Default = Config.particle_rain_rate or 3 },
    Callback = function(value)
        ParticleSystem.SpawnRate = value
        Config.particle_rain_rate = value
        SaveConfig()
    end
})

VisualsParticleSection:Slider({
    Title = "Fall Speed",
    Flag = "FallSpeed_SAVE",
    Icon = "arrow-down",
    Value = { Min = 5, Max = 150, Default = Config.particle_rain_fall_speed or 25 },
    Callback = function(value)
        ParticleSystem.FallSpeed = value
        Config.particle_rain_fall_speed = value
        SaveConfig()
        for _, particle_data in ipairs(ParticleSystem.Particles) do
            particle_data.Velocity = Vector3.new(particle_data.Velocity.X, -value, particle_data.Velocity.Z)
        end
    end
})

VisualsParticleSection:Colorpicker({
    Title = "Particle Color",
    Flag = "ParticleColor_SAVE",
    Icon = "palette",
    Value = Config.particle_rain_color or Color3.fromRGB(100, 200, 255),
    Callback = function(color)
        ParticleSystem.ParticleColor = color
        Config.particle_rain_color = color
        SaveConfig()
        ParticleSystem:updateColors()
    end
})

Tabs.Visuals:Divider()

VisualsSelfEffectSection = Tabs.Visuals:Section({
    Title = "Self Effect",
    Desc = "Add a cool effect around your character.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

VisualsSelfEffectSection:Toggle({
    Title = "Enable Self Effect",
    Flag = "SelfEffect_SAVE",
    Icon = "sparkles",
    Value = Config.self_effect,
    Callback = function(state)
        SelfEffect.Enabled = state
        Config.self_effect = state
        SaveConfig()
        if not state then SelfEffect:cleanup() end
        WindUI:Notify({
            Title = "Self Effect",
            Content = "Self Effect " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "sparkles"
        })
    end
})

VisualsSelfEffectSection:Dropdown({
    Title = "Effect Type",
    Flag = "SelfEffectType_SAVE",
    Icon = "chevrons-up-down",
    Values = {"Magic Circle", "Aura"},
    Value = Config.self_effect_type or "Aura",
    Callback = function(value)
        SelfEffect.EffectType = value
        Config.self_effect_type = value
        SaveConfig()
        SelfEffect:cleanup()
        WindUI:Notify({
            Title = "Self Effect",
            Content = "Effect type: " .. value,
            Duration = 1.5,
            Icon = "sparkles"
        })
    end
})

VisualsSelfEffectGroup = Tabs.Visuals:Group({})
VisualsSelfEffectGroup:Colorpicker({
    Title = "Effect Color",
    Flag = "SelfEffectColor_SAVE",
    Icon = "palette",
    Value = Config.self_effect_color,
    Callback = function(color)
        SelfEffect.Color = color
        Config.self_effect_color = color
        SaveConfig()
    end
})

VisualsSelfEffectGroup:Slider({
    Title = "Effect Size",
    Flag = "SelfEffectSize_SAVE",
    Icon = "maximize",
    Value = { Min = 1, Max = 10, Default = Config.self_effect_size or 5 },
    Callback = function(value)
        SelfEffect.Size = value
        Config.self_effect_size = value
        SaveConfig()
    end
})

VisualsSelfEffectGroup:Slider({
    Title = "Animation Speed",
    Flag = "SelfEffectSpeed_SAVE",
    Icon = "zap",
    Value = { Min = 0.5, Max = 3, Default = Config.self_effect_speed or 1 },
    Callback = function(value)
        SelfEffect.Speed = value
        Config.self_effect_speed = value
        SaveConfig()
    end
})

Tabs.Visuals:Divider()

VisualsMonitorSection = Tabs.Visuals:Section({
    Title = "Ball Visualizer",
    Desc = "See the ball's position and lag with a visual indicator.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

VisualsMonitorSection:Toggle({
    Title = "Visualizer Monitor",
    Flag = "VisualizerMonitorBall_SAVE",
    Icon = "eye",
    Value = Config.visualize,
    Callback = function(state)
        Config.visualize = state
        SaveConfig()
        if state then
            if not ConnectionsManager["visualizer"] then
                task.defer(function()
                    local visualizePart = Instance.new("Part", workspace)
                    visualizePart.Name = "VicoX_VisualizerPart"
                    visualizePart.Material = Enum.Material.ForceField
                    visualizePart.CanCollide = false
                    visualizePart.Shape = Enum.PartType.Ball
                    visualizePart.Anchored = true
                    visualizePart.Size = Vector3.new(2, 2, 2)
                    visualizePart.Color = Color3.fromRGB(0, 255, 0)
                    visualizerData = { part = visualizePart }
                    ConnectionsManager["visualizer"] = RunService.RenderStepped:Connect(function()
                        if not visualizerData or not visualizerData.part then return end

                        local ball = AutoParry.get_ball()
                        if not ball then
                            visualizerData.part.Transparency = 1
                            return
                        end

                        local ballPosition = ball.Position
                        local player = LocalPlayer
                        if not player or not player:FindFirstChild("HumanoidRootPart") then
                            visualizerData.part.Transparency = 1
                            return
                        end

                        local playerPosition = player.HumanoidRootPart.Position
                        local distance = (ballPosition - playerPosition).Magnitude
                        local maxDistance = 50
                        local minSize = 2
                        local maxSize = 7
                        local size = maxSize - (maxSize - minSize) * (distance / maxDistance)
                        size = math.clamp(size, minSize, maxSize)
                        local lagDistance = (visualizerData.part.Position - ballPosition).Magnitude

                        if lagDistance < 0.5 then
                            visualizePart.Color = Color3.fromRGB(0, 255, 0)
                        elseif lagDistance < 2 then
                            visualizePart.Color = Color3.fromRGB(255, 255, 0)
                        else
                            visualizePart.Color = Config.plasma_rainbow_mode and Color3.fromHSV((tick() * 0.5) % 1, 1, 1) or Color3.fromRGB(255, 0, 0)
                        end

                        visualizerData.part.Transparency = 0
                        visualizePart.Position = ballPosition
                        visualizerData.part.Size = Vector3.new(size, size, size)
                    end)
                end)
            end
        else
            if ConnectionsManager["visualizer"] then
                ConnectionsManager["visualizer"]:Disconnect()
                ConnectionsManager["visualizer"] = nil
            end
            if visualizerData and visualizerData.part then
                visualizerData.part:Destroy()
                visualizerData.part = nil
            end
        end
        WindUI:Notify({
            Title = "Visualizer",
            Content = "Visualizer " .. (state and "enabled" or "disabled"),
            Duration = 2,
            Icon = "eye"
        })
    end
})

Tabs.Visuals:Divider()

VisualsTrailSection = Tabs.Visuals:Section({
    Title = "Ball & Player Trails",
    Desc = "Add colorful trails to the ball and your character.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

VisualsTrailGroup = Tabs.Visuals:Group({})
VisualsTrailGroup:Toggle({
    Title = "Ball Trail",
    Flag = "BallTrail_SAVE",
    Icon = "sparkles",
    Value = Config.ball_trail_enabled,
    Callback = function(state)
        Config.ball_trail_enabled = state
        SaveConfig()
        if state or Config.player_trail_enabled then
            task.spawn(StartTrailUpdate)
        else
            task.spawn(StopTrailUpdate)
        end
        WindUI:Notify({
            Title = "Ball Trail",
            Content = "Ball Trail " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "sparkles"
        })
    end
})

VisualsTrailGroup:Colorpicker({
    Title = "Ball Trail Color",
    Flag = "BallTrailColor_SAVE",
    Icon = "palette",
    Value = Config.ball_trail_color,
    Callback = function(color)
        Config.ball_trail_color = color
        SaveConfig()
    end
})

VisualsTrailGroup:Space()

VisualsTrailGroup:Toggle({
    Title = "Player Trail",
    Flag = "PlayerTrail_SAVE",
    Icon = "sparkles",
    Value = Config.player_trail_enabled,
    Callback = function(state)
        Config.player_trail_enabled = state
        SaveConfig()
        if state or Config.ball_trail_enabled then
            if StartTrailUpdate then
                StartTrailUpdate()
            end
        else
            if StopTrailUpdate then
                StopTrailUpdate()
            end
        end
        WindUI:Notify({
            Title = "Player Trail",
            Content = "Player Trail " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "sparkles"
        })
    end
})

VisualsTrailGroup:Colorpicker({
    Title = "Player Trail Color",
    Flag = "PlayerTrailColor_SAVE",
    Icon = "palette",
    Value = Config.player_trail_color,
    Callback = function(color)
        Config.player_trail_color = color
        SaveConfig()
        if UpdatePlayerTrail then
            UpdatePlayerTrail()
        end
        WindUI:Notify({
            Title = "Player Trail Color",
            Content = "Color set to " .. tostring(color),
            Duration = 1.5,
            Icon = "palette"
        })
    end
})

Tabs.Visuals:Divider()

-- Section untuk UI Scaling
UIScalingSection = Tabs.Visuals:Section({
    Title = "UI Scaling",
    Desc = "Adjust the overall size of the user interface.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

UIScalingSection:Slider({
    Title = "UI Scale",
    Flag = "UIScale_SAVE",
    Icon = "maximize-2",
    Value = { Min = 0.5, Max = 1.5, Default = Config.ui_scale or 1.0, Prec = 2 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Window:SetUIScale(value)
        Config.ui_scale = value
        SaveConfig()
        WindUI:Notify({
            Title = "UI Scale",
            Content = "UI Scale set to " .. value,
            Duration = 2,
            Icon = "maximize-2"
        })
    end
})

UIScalingSection:Button({
    Title = "Reset Scale to Default",
    Icon = "refresh-cw",
    Justify = "Center",
    Callback = function()
        -- LOGIKA LENGKAP
        Window:SetUIScale(1.0)
        Config.ui_scale = 1.0
        SaveConfig()
        WindUI:Notify({
            Title = "UI Scale Reset",
            Content = "UI scale has been reset to default.",
            Duration = 2,
            Icon = "refresh-cw"
        })
    end
})

Tabs.Visuals:Divider()

-- Section untuk World Effects
VisualsWorldSection = Tabs.Visuals:Section({
    Title = "World Effects & Rendering",
    Box = true,
    BoxBorder = true,
    Opened = false
})

VisualsWorldGroup = Tabs.Visuals:Group({})
VisualsWorldGroup:Toggle({
    Title = "Visual ESP",
    Flag = "VisualEspV1_SAVE",
    Value = Config.visuals_enabled,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.visuals_enabled = state
        SaveConfig()
        WindUI:Notify({
            Title = "Visual ESP",
            Content = "Visual ESP " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
        })
    end
})

VisualsWorldGroup:Toggle({
    Title = "No Render",
    Flag = "NoRender_SAVE",
    Icon = "eye-off",
    Value = Config.no_render,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.no_render = state
        SaveConfig()
        WindUI:Notify({
            Title = "No Render",
            Content = "No Render " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "eye-off"
        })
    end
})

VisualsWorldGroup:Toggle({
    Title = "Smart No Render",
    Flag = "SmartNoRender_SAVE",
    Icon = "brain",
    Value = Config.smart_no_render,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.smart_no_render = state
        SaveConfig()
        WindUI:Notify({
            Title = "Smart No Render",
            Content = "Smart No Render " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "brain"
        })
    end
})

VisualsWorldGroup:Toggle({
    Title = "Parry Sound",
    Flag = "ParrySound_SAVE",
    Icon = "music",
    Value = Config.sound_effect_enabled,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.sound_effect_enabled = state
        SaveConfig()
        WindUI:Notify({
            Title = "Parry Sound",
            Content = "Parry Sound " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "music"
        })
    end
})

Tabs.Worlds:Paragraph({
    Title = "World Enhancements",
    Desc = "Change the atmosphere and appearance of your world.",
    Color = Color3.fromHex("#228B22") -- Warna hijau forest
})

-- Section untuk Night Mode
WorldsAtmosphereSection = Tabs.Worlds:Section({
    Title = "Atmosphere & Lighting",
    Desc = "Control the time of day and lighting.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

WorldsAtmosphereSection:Toggle({
    Title = "Night Mode",
    Flag = "NightMode_SAVE",
    Icon = "moon",
    Value = Config.night_mode,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.night_mode = state
        SaveConfig()
        -- Anda bisa menambahkan logika untuk mengubah Lighting.ClockTime di sini jika perlu
        WindUI:Notify({
            Title = "Night Mode",
            Content = "Night Mode " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "moon"
        })
    end
})

Tabs.Worlds:Divider()

-- Section untuk Skybox
WorldsSkySection = Tabs.Worlds:Section({
    Title = "Custom Skybox",
    Desc = "Replace the default sky with custom textures.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

WorldsSkySection:Toggle({
    Title = "Enable Custom Sky",
    Flag = "CustomSky_SAVE",
    Icon = "cloud",
    Value = Config.custom_sky,
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.custom_sky = value
        SaveConfig()
        local Lighting = game:GetService("Lighting")
        local Sky = Lighting:FindFirstChildOfClass("Sky")
        if value then
            if not Sky then
                Sky = Instance.new("Sky", Lighting)
            end
            -- Apply the last selected skybox
            local selectedOption = Config.custom_sky_selector or "Default"
            local data = skyboxData[selectedOption]
            if data then
                local skyFaces = {"SkyboxBk", "SkyboxDn", "SkyboxFt", "SkyboxLf", "SkyboxRt", "SkyboxUp"}
                for index, face in ipairs(skyFaces) do
                    Sky[face] = "rbxassetid://" .. data[index]
                end
                Lighting.GlobalShadows = false
            end
        else
            if Sky then
                Sky:Destroy()
            end
            Lighting.GlobalShadows = true
        end
        WindUI:Notify({
            Title = "Custom Sky",
            Content = "Custom Sky " .. (value and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "cloud"
        })
    end
})

WorldsSkySection:Divider()

WorldsSkySection:Dropdown({
    Title = "Select Sky",
    Flag = "SkySelect_SAVE",
    Icon = "cloud-drizzle",
    Values = {
        "Default", "Vaporwave", "Redshift", "Desert", "DaBaby", "Minecraft",
        "SpongeBob", "Skibidi", "Blaze", "Pussy Cat", "Among Us", "Space Wave",
        "Space Wave2", "Turquoise Wave", "Dark Night", "Bright Pink",
        "White Galaxy", "Blue Galaxy"
    },
    Value = Config.custom_sky_selector,
    Callback = function(selectedOption)
        -- LOGIKA LENGKAP
        Config.custom_sky_selector = selectedOption
        SaveConfig()
        if not Config.custom_sky then
            WindUI:Notify({
                Title = "Custom Sky",
                Content = "Enable Custom Sky to apply " .. selectedOption,
                Duration = 1.5,
                Icon = "cloud"
            })
            return
        end
        local data = skyboxData[selectedOption]
        if not data then
            WindUI:Notify({
                Title = "Skybox Error",
                Content = "Sky option not found: " .. tostring(selectedOption),
                Duration = 1.5,
                Icon = "alert-triangle"
            })
            return
        end
        local Lighting = game:GetService("Lighting")
        local Sky = Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", Lighting)
        local skyFaces = {"SkyboxBk", "SkyboxDn", "SkyboxFt", "SkyboxLf", "SkyboxRt", "SkyboxUp"}
        local success, err = pcall(function()
            for index, face in ipairs(skyFaces) do
                Sky[face] = "rbxassetid://" .. data[index]
            end
            Lighting.GlobalShadows = false
        end)
        if not success then
            WindUI:Notify({
                Title = "Skybox Error",
                Content = "Failed to load " .. selectedOption .. " skybox: " .. tostring(err),
                Duration = 1.5,
                Icon = "alert-triangle"
            })
            return
        end
        WindUI:Notify({
            Title = "Select Sky",
            Content = "Skybox set to " .. selectedOption,
            Duration = 1.5,
            Icon = "cloud-drizzle"
        })
    end
})

Tabs.Worlds:Divider()

-- Section untuk World Filters (jika ada)
WorldsFiltersSection = Tabs.Worlds:Section({
    Title = "World Filters",
    Desc = "Apply post-processing effects to the world.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

WorldsFiltersGroup = Tabs.Worlds:Group({})
WorldsFiltersGroup:Toggle({
    Title = "Fog",
    Flag = "Fog_SAVE",
    Icon = "cloud",
    Value = Config.fog_enabled or false,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.fog_enabled = state
        SaveConfig()
        local Lighting = game:GetService("Lighting")
        Lighting.FogEnd = state and 100 or 100000 -- Contoh nilai
        Lighting.FogColor = state and Color3.fromRGB(200, 200, 200) or Color3.new(1,1,1)
        WindUI:Notify({
            Title = "Fog",
            Content = "Fog " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "cloud"
        })
    end
})

WorldsFiltersGroup:Slider({
    Title = "Saturation",
    Flag = "Saturation_SAVE",
    Icon = "droplet",
    Value = { Min = -1, Max = 2, Default = Config.saturation_level or 0 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.saturation_level = value
        SaveConfig()
        local Lighting = game:GetService("Lighting")
        local colorCorrection = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        colorCorrection.Saturation = value
        WindUI:Notify({
            Title = "Saturation",
            Content = "Saturation set to " .. value,
            Duration = 1.5,
            Icon = "droplet"
        })
    end
})

WorldsFiltersGroup:Slider({
    Title = "Brightness",
    Flag = "Brightness_SAVE",
    Icon = "sun",
    Value = { Min = 0, Max = 3, Default = Config.brightness_level or 1 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.brightness_level = value
        SaveConfig()
        local Lighting = game:GetService("Lighting")
        local colorCorrection = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        colorCorrection.Brightness = value
        WindUI:Notify({
            Title = "Brightness",
            Content = "Brightness set to " .. value,
            Duration = 1.5,
            Icon = "sun"
        })
    end
})

WorldsFiltersGroup:Slider({
    Title = "Contrast",
    Flag = "Contrast_SAVE",
    Icon = "sliders",
    Value = { Min = 0, Max = 2, Default = Config.contrast_level or 1 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.contrast_level = value
        SaveConfig()
        local Lighting = game:GetService("Lighting")
        local colorCorrection = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        colorCorrection.Contrast = value
        WindUI:Notify({
            Title = "Contrast",
            Content = "Contrast set to " .. value,
            Duration = 1.5,
            Icon = "sliders"
        })
    end
})

Tabs.Misc:Paragraph({
    Title = "Utility & Tools",
    Desc = "Additional features to enhance your gameplay and convenience.",
    Image = "rbxassetid://129260712070622",
    ImageSize = 48,
    Color = Color3.fromHex("#4682B4") -- Warna biru baja
})

-- Section untuk Ping Booster
MiscPingSection = Tabs.Misc:Section({
    Title = "Network Optimizer",
    Desc = "Tools to potentially improve your network performance.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

MiscPingSection:Button({
    Title = "Load Ping Booster UI",
    Icon = "network-wired",
    Callback = function()
        -- LOGIKA LENGKAP
        local success, result = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/RudertTiktok/OXJSOKAJSKSHS/refs/heads/main/pingOptimizerByRudert.txt"))()
        end)

        if success then
            WindUI:Notify({
                Title = "Ping Booster",
                Content = "Ping Booster UI loaded successfully!",
                Duration = 5,
                Icon = "network-wired"
            })
        else
            WindUI:Notify({
                Title = "Ping Booster",
                Content = "Failed to load Ping Booster UI: " .. tostring(result),
                Duration = 7,
                Icon = "alert-octagon"
            })
        end
    end
})

Tabs.Misc:Divider()

-- Section untuk Auto Rewards
MiscRewardsSection = Tabs.Misc:Section({
    Title = "Automation",
    Desc = "Automate repetitive tasks for you.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

MiscRewardsSection:Toggle({
    Title = "Auto Rewards",
    Flag = "AutoRewards_SAVE",
    Icon = "gift",
    Value = Config.auto_rewards,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.auto_rewards = state
        SaveConfig()
        WindUI:Notify({
            Title = "Auto Rewards",
            Content = "Auto Rewards " .. (state and "enabled" or "disabled"),
            Duration = 2,
            Icon = "gift"
        })
    end
})

Tabs.Misc:Divider()

-- Section untuk Quantum Arena
MiscQuantumSection = Tabs.Misc:Section({
    Title = "Arena Settings",
    Desc = "Toggle specific arena effects.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

MiscQuantumSection:Toggle({
    Title = "Disable Quantum Effects",
    Flag = "DisableQuantumEffects_SAVE",
    Value = Config.disable_quantum_effects,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.disable_quantum_effects = state
        SaveConfig()
        WindUI:Notify({
            Title = "Quantum Effects",
            Content = "Quantum Effects " .. (state and "disabled" or "enabled"),
            Duration = 2,
            Icon = "alert-triangle"
        })
    end
})

Tabs.Misc:Divider()

-- Section untuk Announcer
MiscAnnouncerSection = Tabs.Misc:Section({
    Title = "Custom Announcer",
    Desc = "Replace the default announcer with your own text.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

MiscAnnouncerSection:Toggle({
    Title = "Enable Custom Announcer",
    Flag = "CustomAnnouncer_SAVE",
    Value = Config.custom_announcer or false,
    Callback = function(state)
        -- LOGIKA LENGKAP
        CustomAnnouncer.enabled = state
        Config.custom_announcer = state
        SaveConfig()
        if state then
            CustomAnnouncer:updateAnnouncer()
        else
            if ConnectionsManager['announcer_text_changed'] then
                ConnectionsManager['announcer_text_changed']:Disconnect()
                ConnectionsManager['announcer_text_changed'] = nil
            end
        end
        WindUI:Notify({
            Title = "Custom Announcer",
            Content = "Custom Announcer " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
        })
    end
})

MiscAnnouncerSection:Space()

MiscAnnouncerSection:Input({
    Title = "Custom Announcer Text",
    Flag = "CustomAnnouncerText_SAVE",
    Placeholder = "Enter custom announcer text...",
    Value = Config.announcer_text or "",
    Callback = function(text)
        -- LOGIKA LENGKAP
        CustomAnnouncer.custom_text = text
        Config.announcer_text = text
        SaveConfig()
        if CustomAnnouncer.enabled then
            CustomAnnouncer:updateAnnouncer()
        end
        WindUI:Notify({
            Title = "Custom Announcer Text",
            Content = "Text set to: " .. text,
            Duration = 1.5,
        })
    end
})

Tabs.Misc:Divider()

-- Section untuk Crate
MiscCrateSection = Tabs.Misc:Section({
    Title = "Crate Opener",
    Desc = "Instantly open your crates without clicking.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

MiscCrateGroup = Tabs.Misc:Group({})
MiscCrateGroup:Button({
    Title = "Open Sword Crate",
    Icon = "package",
    Callback = function()
        -- LOGIKA LENGKAP
        local result = getSword()
        if result == "Error" then
            WindUI:Notify({
                Title = "Sword Crate",
                Content = "Failed to open sword crate!",
                Duration = 1.5,
                Icon = "alert-triangle"
            })
        else
            WindUI:Notify({
                Title = "Sword Crate",
                Content = "Opened sword crate: " .. tostring(result),
                Duration = 1.5,
                Icon = "package"
            })
        end
    end
})

MiscCrateGroup:Button({
    Title = "Open Explosion Crate",
    Icon = "package",
    Callback = function()
        -- LOGIKA LENGKAP
        local result = getExplosion()
        if result == "Error" then
            WindUI:Notify({
                Title = "Explosion Crate",
                Content = "Failed to open explosion crate!",
                Duration = 1.5,
                Icon = "alert-triangle"
            })
        else
            WindUI:Notify({
                Title = "Explosion Crate",
                Content = "Opened explosion crate: " .. tostring(result),
                Duration = 1.5,
                Icon = "package"
            })
        end
    end
})

Tabs.Misc:Divider()

-- Section untuk Strafe
MiscStrafeSection = Tabs.Misc:Section({
    Title = "Movement",
    Desc = "Modify your character's movement.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

MiscStrafeSection:Toggle({
    Title = "Strafe",
    Flag = "Strafe_SAVE",
    Icon = "move",
    Value = Config.strafe,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.strafe = state
        SaveConfig()
        WindUI:Notify({
            Title = "Strafe",
            Content = "Strafe " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "move"
        })
    end
})

MiscStrafeSection:Slider({
    Title = "Strafe Speed",
    Icon = "gauge",
    Value = { Min = 0, Max = 100, Default = Config.strafe_speed or 16 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.strafe_speed = value
        SaveConfig()
        WindUI:Notify({
            Title = "Strafe Speed",
            Content = "Strafe Speed set to " .. value,
            Duration = 1.5,
            Icon = "gauge"
        })
    end
})

Tabs.Misc:Divider()

-- Section untuk Fly
MiscFlySection = Tabs.Misc:Section({
    Title = "Flight",
    Desc = "Gain the ability to fly around the map.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

MiscFlySection:Toggle({
    Title = "Fly (Mobile & PC Compatible)",
    Icon = "cloud",
    Value = Config.fly_enabled or false,
    Callback = function(state)
        -- LOGIKA LENGKAP UNTUK FLY (TIDAK DI SINGKAT)
        local flyConnection, resetterConnection, ragdollHandler, screenGui, flyControlsContainer
        local toggleButton, forwardButton, backButton, leftButton, rightButton, upButton, downButton, uiToggleButton
        local inputFlags = { forward = false, back = false, left = false, right = false, up = false, down = false }
        local uiVisible = true
        local dpadSize = UDim2.new(0, 60, 0, 60)
        
        local function createButton(parent, name, text, pos, size)
            local btn = Instance.new("TextButton")
            btn.Name = name
            btn.Text = text
            btn.Size = size
            btn.Position = pos
            btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            btn.TextColor3 = Color3.fromRGB(255, 255, 255)
            btn.Font = Enum.Font.GothamBold
            btn.TextScaled = true
            btn.BackgroundTransparency = 0.2
            btn.Parent = parent
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = btn
            return btn
        end
        
        local function tweenFlyControls(visible)
            local tweenTime = 0.5
            for _, btn in pairs(flyControlsContainer:GetChildren()) do
                if btn:IsA("TextButton") then
                    local targetBackgroundTransparency = visible and 0.2 or 1
                    local targetTextTransparency = visible and 0 or 1
                    local tweenInfo = TweenInfo.new(tweenTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    local tween = TweenService:Create(btn, tweenInfo, { BackgroundTransparency = targetBackgroundTransparency, TextTransparency = targetTextTransparency })
                    tween:Play()
                end
            end
        end
        
        local function addTouchEvents(button, flagName)
            button.MouseButton1Down:Connect(function() inputFlags[flagName] = true end)
            button.MouseButton1Up:Connect(function() inputFlags[flagName] = false end)
            button.MouseLeave:Connect(function() inputFlags[flagName] = false end)
            button.TouchTap:Connect(function() inputFlags[flagName] = not inputFlags[flagName] end) -- Support tap
        end
        
        if state then
            getgenv().FlyEnabled = true
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local hrp = char:WaitForChild("HumanoidRootPart")
            local humanoid = char:WaitForChild("Humanoid")
            
            if not hrp or not humanoid then
                WindUI:Notify({
                    Title = "Fly Error",
                    Content = "Character not loaded!",
                    Duration = 1.5,
                    Icon = "alert-triangle"
                })
                return
            end
            
            -- Angkat karakter biar nggak stuck
            hrp.CFrame = hrp.CFrame + Vector3.new(0, 5, 0)
            
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            bodyVelocity.MaxForce = Vector3.new(50000, 50000, 50000)
            bodyVelocity.Parent = hrp
            
            local bodyGyro = Instance.new("BodyGyro")
            bodyGyro.CFrame = hrp.CFrame
            bodyGyro.MaxTorque = Vector3.new(50000, 50000, 50000)
            bodyGyro.P = 50000
            bodyGyro.Parent = hrp
            
            humanoid.PlatformStand = true
            
            ragdollHandler = humanoid.StateChanged:Connect(function(oldState, newState)
                if getgenv().FlyEnabled then
                    if newState == Enum.HumanoidStateType.Physics or newState == Enum.HumanoidStateType.Ragdoll then
                        task.defer(function()
                            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                            humanoid:ChangeState(Enum.HumanoidStateType.Running)
                        end)
                    end
                end
            end)
            
            resetterConnection = RunService.Heartbeat:Connect(function()
                if not getgenv().FlyEnabled then return end
                if bodyGyro and bodyGyro.Parent then
                    bodyGyro.P = 50000
                    bodyGyro.MaxTorque = Vector3.new(50000, 50000, 50000)
                end
                if bodyVelocity and bodyVelocity.Parent then
                    bodyVelocity.MaxForce = Vector3.new(50000, 50000, 50000)
                end
                humanoid.PlatformStand = true
                if not bodyGyro.Parent or not bodyVelocity.Parent then
                    if bodyGyro then bodyGyro:Destroy() end
                    if bodyVelocity then bodyVelocity:Destroy() end
                    bodyGyro = Instance.new("BodyGyro")
                    bodyGyro.P = 50000
                    bodyGyro.MaxTorque = Vector3.new(50000, 50000, 50000)
                    bodyGyro.Parent = hrp
                    bodyVelocity = Instance.new("BodyVelocity")
                    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                    bodyVelocity.MaxForce = Vector3.new(50000, 50000, 50000)
                    bodyVelocity.Parent = hrp
                end
            end)
            
            
            screenGui = Instance.new("ScreenGui")
            screenGui.Name = "VicoX_FlyScreenGui"
            screenGui.ResetOnSpawn = false
            screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
            
            flyControlsContainer = Instance.new("Frame")
            flyControlsContainer.Name = "FlyControlsContainer"
            flyControlsContainer.Size = UDim2.new(1, 0, 1, 0)
            flyControlsContainer.BackgroundTransparency = 1
            flyControlsContainer.Parent = screenGui
            
            forwardButton = createButton(flyControlsContainer, "ForwardButton", "â†‘", UDim2.new(0, 70, 1, -190), dpadSize)
            backButton = createButton(flyControlsContainer, "BackButton", "â†“", UDim2.new(0, 70, 1, -70), dpadSize)
            leftButton = createButton(flyControlsContainer, "LeftButton", "â†", UDim2.new(0, 10, 1, -130), dpadSize)
            rightButton = createButton(flyControlsContainer, "RightButton", "â†’", UDim2.new(0, 130, 1, -130), dpadSize)
            upButton = createButton(flyControlsContainer, "UpButton", "Up", UDim2.new(1, -110, 1, -190), dpadSize)
            downButton = createButton(flyControlsContainer, "DownButton", "Down", UDim2.new(1, -110, 1, -70), dpadSize)
            uiToggleButton = createButton(flyControlsContainer, "UIToggleButton", "Hide UI", UDim2.new(0, 10, 0, 10), UDim2.new(0, 100, 0, 50))
            
            addTouchEvents(forwardButton, "forward")
            addTouchEvents(backButton, "back")
            addTouchEvents(leftButton, "left")
            addTouchEvents(rightButton, "right")
            addTouchEvents(upButton, "up")
            addTouchEvents(downButton, "down")
            
            uiToggleButton.MouseButton1Click:Connect(function()
                uiVisible = not uiVisible
                tweenFlyControls(uiVisible)
                uiToggleButton.Text = uiVisible and "Hide UI" or "Show UI"
            end)
            
            flyConnection = RunService.Heartbeat:Connect(function()
                if not getgenv().FlyEnabled then return end
                local moveDirection = Vector3.new(0, 0, 0)
                local camCF = workspace.CurrentCamera.CFrame
                
                if inputFlags.forward then moveDirection = moveDirection + camCF.LookVector end
                if inputFlags.back then moveDirection = moveDirection - camCF.LookVector end
                if inputFlags.left then moveDirection = moveDirection - camCF.RightVector end
                if inputFlags.right then moveDirection = moveDirection + camCF.RightVector end
                if inputFlags.up then moveDirection = moveDirection + Vector3.new(0, 1, 0) end
                if inputFlags.down then moveDirection = moveDirection - Vector3.new(0, 1, 0) end
                
                -- Kontrol PC (WASD/E/Q)
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    moveDirection = moveDirection + camCF.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    moveDirection = moveDirection - camCF.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    moveDirection = moveDirection - camCF.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    moveDirection = moveDirection + camCF.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.E) then
                    moveDirection = moveDirection + Vector3.new(0, 1, 0)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.Q) then
                    moveDirection = moveDirection - Vector3.new(0, 1, 0)
                end
                
                if moveDirection.Magnitude > 0 then
                    moveDirection = moveDirection.Unit
                end
                bodyVelocity.Velocity = moveDirection * (getgenv().FlySpeed or 30)
                bodyGyro.CFrame = camCF
            end)
            
            WindUI:Notify({
                Title = "Fly",
                Content = "Fly enabled! Use joystick to move, Up/Down to ascend/descend.",
                Duration = 4,
                Icon = "cloud"
            })
        else
            getgenv().FlyEnabled = false
            
            if flyConnection then
                flyConnection:Disconnect()
                flyConnection = nil
            end
            
            if resetterConnection then
                resetterConnection:Disconnect()
                resetterConnection = nil
            end
            
            if ragdollHandler then
                ragdollHandler:Disconnect()
                ragdollHandler = nil
            end
            
            if screenGui then
                screenGui:Destroy()
                screenGui = nil
            end
            
            local char = LocalPlayer.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                local humanoid = char:FindFirstChild("Humanoid")
                
                if humanoid then
                    humanoid.PlatformStand = false
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                end
                
                if hrp then
                    for _, v in ipairs(hrp:GetChildren()) do
                        if v:IsA("BodyGyro") or v:IsA("BodyVelocity") then
                            v:Destroy()
                        end
                    end
                end
            end
            
            WindUI:Notify({
                Title = "Fly",
                Content = "Fly disabled!",
                Duration = 1.5,
                Icon = "cloud"
            })
        end
        
        LocalPlayer.CharacterAdded:Connect(function(newChar)
            if getgenv().FlyEnabled then
                char = newChar
                hrp = newChar:WaitForChild("HumanoidRootPart")
                humanoid = newChar:WaitForChild("Humanoid")
                bodyVelocity.Parent = nil
                bodyGyro.Parent = nil
                humanoid.PlatformStand = false
                getgenv().FlyEnabled = false
                if flyConnection then flyConnection:Disconnect() end
                if resetterConnection then resetterConnection:Disconnect() end
                if ragdollHandler then ragdollHandler:Disconnect() end
                if screenGui then screenGui:Destroy() end
                WindUI:Notify({
                    Title = "Fly",
                    Content = "Fly disabled due to respawn!",
                    Duration = 1.5,
                    Icon = "cloud"
                })
            end
        end)
    end
})

Tabs.Misc:Divider()

-- Section untuk Personnel Detector
MiscDetectorSection = Tabs.Misc:Section({
    Title = "Player Detection",
    Desc = "Detect other players and automatically leave the server.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

MiscDetectorGroup = Tabs.Misc:Group({})
MiscDetectorGroup:Toggle({
    Title = "Personnel Detector",
    Flag = "PersonnelDetector_SAVE",
    Value = Config.personnel_detector,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.personnel_detector = state
        SaveConfig()
        WindUI:Notify({
            Title = "Personnel Detector",
            Content = "Personnel Detector " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
        })
    end
})

MiscDetectorGroup:Toggle({
    Title = "Auto Leave on Detection",
    Flag = "AutoLeave_SAVE",
    Icon = "log-out",
    Value = Config.personnel_detector_auto_leave,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.personnel_detector_auto_leave = state
        SaveConfig()
        WindUI:Notify({
            Title = "Auto Leave",
            Content = "Auto Leave " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "log-out"
        })
    end
})

Tabs.Misc:Divider()

-- Section untuk Gravity
MiscGravitySection = Tabs.Misc:Section({
    Title = "World Physics",
    Desc = "Alter the world's gravity.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

MiscGravitySection:Toggle({
    Title = "Custom Gravity",
    Flag = "Gravity_SAVE",
    Value = Config.gravity,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.gravity = state
        SaveConfig()
        if state then
            workspace.Gravity = Config.gravity_strength or 50
        else
            workspace.Gravity = 196.2 -- Kembalikan ke default Roblox
        end
        WindUI:Notify({
            Title = "Gravity",
            Content = "Gravity " .. (state and "enabled" or "disabled"),
            Duration = 2,
        })
    end
})

MiscGravitySection:Slider({
    Title = "Gravity Strength",
    Flag = "GravityStrength_SAVE",
    Icon = "sliders-horizontal",
    Value = { Min = 0, Max = 100, Default = Config.gravity_strength or 50 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.gravity_strength = value
        SaveConfig()
        if Config.gravity then
            workspace.Gravity = value
        end
        WindUI:Notify({
            Title = "Gravity Strength",
            Content = "Gravity Strength set to " .. value,
            Duration = 1.5,
            Icon = "sliders-horizontal"
        })
    end
})


Tabs.Players:Paragraph({
    Title = "Player Customization",
    Desc = "Modify your character's appearance and camera.",
    Image = "rbxassetid://129260712070622",
    ImageSize = 48,
    Color = Color3.fromHex("#FFD700") 
})

-- Section untuk Player Follow
PlayersFollowSection = Tabs.Players:Section({
    Title = "Player Follow",
    Desc = "Automatically follow a selected player.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

PlayersFollowSection:Toggle({
    Title = "Enable Player Follow",
    Flag = "PlayerFollow_SAVE",
    Value = Config.player_follow,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.player_follow = state
        SaveConfig()
        if state then
            -- Start following connection
            ConnectionsManager['player_follow'] = RunService.Heartbeat:Connect(function()
                PlayerFollow:startFollowing()
            end)
            -- Start player list update connection
            local updateTimer = 0
            ConnectionsManager['player_list_update'] = RunService.Heartbeat:Connect(function(dt)
                updateTimer = updateTimer + dt
                if updateTimer >= 10 then
                    PlayerFollow:updatePlayerList()
                    updateTimer = 0
                end
            end)
            WindUI:Notify({
                Title = "Player Follow",
                Content = "Player Follow enabled",
                Duration = 1.5,
                Icon = "user"
            })
        else
            -- Disconnect follow and update connections
            if ConnectionsManager['player_follow'] then
                ConnectionsManager['player_follow']:Disconnect()
                ConnectionsManager['player_follow'] = nil
            end
            if ConnectionsManager['player_list_update'] then
                ConnectionsManager['player_list_update']:Disconnect()
                ConnectionsManager['player_list_update'] = nil
            end
            WindUI:Notify({
                Title = "Player Follow",
                Content = "Player Follow disabled",
                Duration = 2,
                Icon = "user"
            })
        end
    end
})

PlayersFollowSection:Divider()

local initialPlayerNames = PlayerFollow:getPlayerNames()
PlayersFollowSection:Dropdown({
    Title = "Follow Target",
    Values = initialPlayerNames,
    Value = Config.follow_target or (#initialPlayerNames > 0 and initialPlayerNames[1] or nil),
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.follow_target = value
        SaveConfig()
        WindUI:Notify({
            Title = "Follow Target",
            Content = value and "Now following: " .. value or "No target selected",
            Duration = 1.5,
            Icon = "user"
        })
    end
})

Tabs.Players:Divider()

-- Section untuk Cosmetics
PlayersCosmeticsSection = Tabs.Players:Section({
    Title = "Player Cosmetics",
    Desc = "Change your avatar's appearance with popular cosmetics.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

PlayersCosmeticsSection:Toggle({
    Title = "Player Cosmetics (Headless & Korblox)",
    Flag = "PlayerCosmestic_SAVE",
    Icon = "user-check",
    Value = Config.player_cosmetics or false,
    Callback = function(value)
        -- LOGIKA LENGKAP (Fungsi Cosmetics sangat panjang, jadi saya akan memasukkannya semua di sini)
        SaveConfig()
        _G.PlayerCosmeticsCleanup = _G.PlayerCosmeticsCleanup or {}
        local players = game:GetService("Players")
        local lp = players.LocalPlayer

        local function applyKorblox(character)
            local rightLeg = character:FindFirstChild("RightLeg") or character:FindFirstChild("Right Leg")
            if not rightLeg then
                warn("Right leg not found on character")
                return
            end
            for _, child in pairs(rightLeg:GetChildren()) do
                if child:IsA("SpecialMesh") then
                    child:Destroy()
                end
            end
            local specialMesh = Instance.new("SpecialMesh")
            specialMesh.MeshId = "rbxassetid://101851696"
            specialMesh.TextureId = "rbxassetid://115727863"
            specialMesh.Scale = Vector3.new(1, 1, 1)
            specialMesh.Parent = rightLeg
        end

        local function saveRightLegProperties(char)
            if char then
                local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("Right Leg")
                if rightLeg then
                    local originalMesh = rightLeg:FindFirstChildOfClass("SpecialMesh")
                    if originalMesh then
                        _G.PlayerCosmeticsCleanup.originalMeshId = originalMesh.MeshId
                        _G.PlayerCosmeticsCleanup.originalTextureId = originalMesh.TextureId
                        _G.PlayerCosmeticsCleanup.originalScale = originalMesh.Scale
                    else
                        _G.PlayerCosmeticsCleanup.hadNoMesh = true
                    end
                    _G.PlayerCosmeticsCleanup.rightLegChildren = {}
                    for _, child in pairs(rightLeg:GetChildren()) do
                        if child:IsA("SpecialMesh") then
                            table.insert(_G.PlayerCosmeticsCleanup.rightLegChildren, {
                                ClassName = child.ClassName,
                                Properties = {
                                    MeshId = child.MeshId,
                                    TextureId = child.TextureId,
                                    Scale = child.Scale
                                }
                            })
                        end
                    end
                end
            end
        end

        local function restoreRightLeg(char)
            if char then
                local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("Right Leg")
                if rightLeg and _G.PlayerCosmeticsCleanup.rightLegChildren then
                    for _, child in pairs(rightLeg:GetChildren()) do
                        if child:IsA("SpecialMesh") then
                            child:Destroy()
                        end
                    end
                    if _G.PlayerCosmeticsCleanup.hadNoMesh then
                        return
                    end
                    for _, childData in ipairs(_G.PlayerCosmeticsCleanup.rightLegChildren) do
                        if childData.ClassName == "SpecialMesh" then
                            local newMesh = Instance.new("SpecialMesh")
                            newMesh.MeshId = childData.Properties.MeshId
                            newMesh.TextureId = childData.Properties.TextureId
                            newMesh.Scale = childData.Properties.Scale
                            newMesh.Parent = rightLeg
                        end
                    end
                end
            end
        end

        if value then
            CosmeticsActive = true
            Config = Config or {}
            Config.Headless = true
            if lp.Character then
                local head = lp.Character:FindFirstChild("Head")
                if head and getgenv().Config.Headless then
                    _G.PlayerCosmeticsCleanup.headTransparency = head.Transparency
                    local decal = head:FindFirstChildOfClass("Decal")
                    if decal then
                        _G.PlayerCosmeticsCleanup.faceDecalId = decal.Texture
                        _G.PlayerCosmeticsCleanup.faceDecalName = decal.Name
                    end
                end
                saveRightLegProperties(lp.Character)
                applyKorblox(lp.Character)
            end
            _G.PlayerCosmeticsCleanup.characterAddedConn = lp.CharacterAdded:Connect(function(char)
                local head = char:FindFirstChild("Head")
                if head and getgenv().Config.Headless then
                    _G.PlayerCosmeticsCleanup.headTransparency = head.Transparency
                    local decal = head:FindFirstChildOfClass("Decal")
                    if decal then
                        _G.PlayerCosmeticsCleanup.faceDecalId = decal.Texture
                        _G.PlayerCosmeticsCleanup.faceDecalName = decal.Name
                    end
                end
                saveRightLegProperties(char)
                applyKorblox(char)
            end)
            if Config.Headless then
                headLoop = task.spawn(function()
                    while CosmeticsActive do
                        local char = lp.Character
                        if char then
                            local head = char:FindFirstChild("Head")
                            if head then
                                head.Transparency = 1
                                local decal = head:FindFirstChildOfClass("Decal")
                                if decal then
                                    decal:Destroy()
                                end
                            end
                        end
                        task.wait(0.1)
                    end
                end)
            end
        else
            CosmeticsActive = false
            if _G.PlayerCosmeticsCleanup.characterAddedConn then
                _G.PlayerCosmeticsCleanup.characterAddedConn:Disconnect()
                _G.PlayerCosmeticsCleanup.characterAddedConn = nil
            end
            if headLoop then
                task.cancel(headLoop)
                headLoop = nil
            end
            local char = lp.Character
            if char then
                local head = char:FindFirstChild("Head")
                if head and _G.PlayerCosmeticsCleanup.headTransparency ~= nil then
                    head.Transparency = _G.PlayerCosmeticsCleanup.headTransparency
                    if _G.PlayerCosmeticsCleanup.faceDecalId then
                        local newDecal = head:FindFirstChildOfClass("Decal") or Instance.new("Decal", head)
                        newDecal.Name = _G.PlayerCosmeticsCleanup.faceDecalName or "face"
                        newDecal.Texture = _G.PlayerCosmeticsCleanup.faceDecalId
                        newDecal.Face = Enum.NormalId.Front
                    end
                end
                restoreRightLeg(char)
            end
            _G.PlayerCosmeticsCleanup = {}
        end
        WindUI:Notify({
            Title = "Player Cosmetics",
            Content = "Cosmetics " .. (value and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "user-check"
        })
    end
})

Tabs.Players:Divider()

-- Section untuk FOV Camera
PlayersCameraSection = Tabs.Players:Section({
    Title = "Camera Settings",
    Desc = "Adjust your field of view.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

PlayersCameraSection:Toggle({
    Title = "Enable FOV Control",
    Flag = "CameraFOV_SAVE",
    Icon = "camera",
    Value = Config.camera,
    Callback = function(state)     
        -- LOGIKA LENGKAP
        Config.camera = state
        SaveConfig()
        WindUI:Notify({
            Title = "FOV Control",
            Content = "FOV Control " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "camera"
        })
    end
})

PlayersCameraSection:Slider({
    Title = "Field Of View",    
    Icon = "maximize",
    Value = { Min = 0, Max = 120, Default = Config.field_of_view or 50 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.field_of_view = value
        getgenv().Config.field_of_view = value
        SaveConfig()
        WindUI:Notify({
            Title = "Field Of View",
            Content = "Field Of View set to " .. value,
            Duration = 1.5,
            Icon = "maximize"
        })
    end
})

Tabs.Players:Divider()

-- Section untuk Ability Vulnerability
PlayersAbilitySection = Tabs.Players:Section({
    Title = "Ability Vulnerability",
    Desc = "Modify how abilities affect you.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

PlayersAbilitySection:Toggle({
    Title = "Enable Ability Vulnerability",
    Flag = "AbilityVurnerability_SAVE",
    Icon = "shield-off",
    Value = Config.ability_vulnerability,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.ability_vulnerability = state
        SaveConfig()
        WindUI:Notify({
            Title = "Ability Vulnerability",
            Content = "Ability Vulnerability " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "shield-off"
        })
    end
})

PlayersAbilitySection:Dropdown({
    Title = "Vulnerability Mode",
    Flag = "AbilityVurnerabilityMode_SAVE",
    Icon = "chevrons-up-down",
    Values = { "Continuity Zero", "Quad Jump", "Quasar" },
    Value = Config.ability_vulnerability_mode or "Quad Jump",
    Callback = function(option)
        -- LOGIKA LENGKAP
        Config.ability_vulnerability_mode = option
        SaveConfig()
        WindUI:Notify({
            Title = "Ability Vulnerability Mode",
            Content = "Mode set to " .. option,
            Duration = 1.5,
            Icon = "chevrons-up-down"
        })
    end
})


Tabs.Farm:Paragraph({
    Title = "Automation & Farming",
    Desc = "Automate gameplay and farm resources effortlessly.",
    Image = "rbxassetid://129260712070622",
    ImageSize = 48,
    Color = Color3.fromHex("#32CD32") -- Warna hijau lime
})

-- Section untuk Auto Requeue
FarmRequeueSection = Tabs.Farm:Section({
    Title = "Auto Requeue",
    Desc = "Automatically rejoin queues after a match ends.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

local autoDuelsRequeueEnabled = false
FarmRequeueSection:Toggle({
    Title = "Auto Duels Requeue",
    Flag = "AutoDuelsRequeue_SAVE",
    Desc = "Automatically requeues for Duels.",
    Value = Config.auto_duels_requeue or false,
    Callback = function(value)
        -- LOGIKA LENGKAP
        autoDuelsRequeueEnabled = value
        Config.auto_duels_requeue = value
        SaveConfig()
        if value then
            task.spawn(function()
                while autoDuelsRequeueEnabled do
                    local success, err = pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.1.0"):WaitForChild("net"):WaitForChild("RE/PlayerWantsRematch"):FireServer()
                    end)
                    if not success then
                        WindUI:Notify({
                            Title = "Auto Duels Requeue",
                            Content = "Error: " .. tostring(err),
                            Duration = 2,
                            Icon = "alert"
                        })
                    end
                    task.wait(5)
                end
            end)
            WindUI:Notify({
                Title = "Auto Duels Requeue",
                Content = "Started auto requeue for duels!",
                Duration = 2,
                Icon = "refresh"
            })
        else
            WindUI:Notify({
                Title = "Auto Duels Requeue",
                Content = "Stopped auto requeue for duels!",
                Duration = 2,
                Icon = "refresh"
            })
        end
    end
})

local validRankedPlaceIds = { 13772394625, 14915220621 }
local selectedQueue = Config.selected_queue or "FFA"
local autoRequeueEnabled = false
FarmRequeueSection:Toggle({
    Title = "Auto Ranked Requeue",
    Flag = "AutoRankedRequeue_SAVE",
    Desc = "Automatically requeues for Ranked matches.",
    Value = Config.auto_ranked_requeue or false,
    Callback = function(value)
        -- LOGIKA LENGKAP
        autoRequeueEnabled = value
        Config.auto_ranked_requeue = value
        SaveConfig()
        if value then
            if not table.find(validRankedPlaceIds, game.PlaceId) then
                autoRequeueEnabled = false
                WindUI:Notify({
                    Title = "Auto Ranked Requeue",
                    Content = "Invalid place ID for Ranked mode!",
                    Duration = 2,
                    Icon = "alert-triangle"
                })
                return
            end
            task.spawn(function()
                while autoRequeueEnabled do
                    local success, err = pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("JoinQueue"):FireServer("Ranked", selectedQueue, "Normal")
                    end)
                    if not success then
                        WindUI:Notify({
                            Title = "Auto Ranked Requeue",
                            Content = "Error: " .. tostring(err),
                            Duration = 2,
                            Icon = "alert"
                        })
                    end
                    task.wait(5)
                end
            end)
            WindUI:Notify({
                Title = "Auto Ranked Requeue",
                Content = "Started auto requeue for Ranked!",
                Duration = 2,
                Icon = "refresh"
            })
        else
            WindUI:Notify({
                Title = "Auto Ranked Requeue",
                Content = "Stopped auto requeue for Ranked!",
                Duration = 2,
                Icon = "refresh"
            })
        end
    end
})

FarmRequeueSection:Dropdown({
    Title = "Select Queue Type",
    Flag = "SelectQueueType_SAVE",
    Values = { "FFA", "Duo" },
    Value = selectedQueue,
    Callback = function(selectedOption)
        -- LOGIKA LENGKAP
        selectedQueue = selectedOption
        Config.selected_queue = selectedOption
        SaveConfig()
        WindUI:Notify({
            Title = "Queue Type",
            Content = "Set queue type to: " .. selectedOption,
            Duration = 1.5,
            Icon = "list"
        })
    end
})

local autoLTMRequeueEnabled = false
local validLTMPlaceId = 13772394625
FarmRequeueSection:Toggle({
    Title = "Auto LTM Requeue",
    Flag = "AutoLTMRequeue_SAVE",
    Desc = "Automatically requeues for Limited Time Modes.",
    Value = Config.auto_ltm_requeue or false,
    Callback = function(value)
        -- LOGIKA LENGKAP
        autoLTMRequeueEnabled = value
        Config.auto_ltm_requeue = value
        SaveConfig()
        if value then
            if game.PlaceId ~= validLTMPlaceId then
                autoLTMRequeueEnabled = false
                WindUI:Notify({
                    Title = "Auto LTM Requeue",
                    Content = "Invalid place ID for LTM mode!",
                    Duration = 2,
                    Icon = "alert-triangle"
                })
                return
            end
            task.spawn(function()
                while autoLTMRequeueEnabled do
                    local success, result = pcall(function()
                        return game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.1.0"):WaitForChild("net"):WaitForChild("RF/JoinTournamentEventQueue"):InvokeServer({})
                    end)
                    if not success then
                        WindUI:Notify({
                            Title = "Auto LTM Requeue",
                            Content = "Error: " .. tostring(result),
                            Duration = 2,
                            Icon = "alert"
                        })
                    end
                    task.wait(5)
                end
            end)
            WindUI:Notify({
                Title = "Auto LTM Requeue",
                Content = "Started auto requeue for LTM!",
                Duration = 2,
                Icon = "refresh"
            })
        else
            WindUI:Notify({
                Title = "Auto LTM Requeue",
                Content = "Stopped auto requeue for LTM!",
                Duration = 2,
                Icon = "refresh"
            })
        end
    end
})

Tabs.Farm:Divider()

-- Section untuk AI
FarmAISection = Tabs.Farm:Section({
    Title = "AI Play (V1 & V2)",
    Desc = "Let an AI play the game for you with different behaviors.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

FarmAISection:Toggle({
    Title = "AI Play V1 (Rage)",
    Flag = "AiPlayV1_SAVE",
    Icon = "bot",
    Value = Config.ai_play,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.ai_play = state
        AIPlaying = state
        SaveConfig()
        if AIPlaying then
            if AICoroutine then
                task.cancel(AICoroutine)
                AICoroutine = nil
            end
            AICoroutine = task.spawn(runAI)
            ConnectionsManager['ai_play'] = AICoroutine
        else
            if AICoroutine then
                task.cancel(AICoroutine)
                AICoroutine = nil
                ConnectionsManager['ai_play'] = nil
            end
        end
        WindUI:Notify({
            Title = "AI Play V1",
            Content = "AI Play V1 " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "bot"
        })
    end
})

FarmAISection:Divider()

FarmAISection:Dropdown({
    Title = "AI V1 Behavior", 
    Flag = "AiBehavior_SAVE",
    Values = {"AdvancedPro", "BallChaser", "AggressiveHunter"},
    Value = Config.ai_method,
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.ai_method = value
        AICurrentMethod = value
        AITarget = nil
        SaveConfig()
        WindUI:Notify({
            Title = "AI V1 Behavior",
            Content = "AI Behavior set to " .. value,
            Duration = 1.5,            
        })
    end
})

FarmAISection:Divider()

FarmAISection:Toggle({
    Title = "AI Play V2 (Completed)",
    Flag = "AiPlayV2_SAVE",
    Value = Config.auto_play or false,
    Callback = function(state)
        -- LOGIKA LENGKAP
        Config.auto_play = state
        SaveConfig()
        if state then
            AutoPlayModule.runThread()
            WindUI:Notify({
                Title = "Auto Play V2",
                Content = "Auto Play V2 enabled",
                Duration = 1.5,
                Icon = "play"
            })
        else
            AutoPlayModule.finishThread()
            WindUI:Notify({
                Title = "Auto Play V2",
                Content = "Auto Play V2 disabled",
                Duration = 1.5,
                Icon = "play"
            })
        end
    end
})

FarmAISection:Toggle({
    Title = "Enable Jumping (V2)",
    Flag = "EnableJumpingAi_SAVE",
    Value = Config.jumping_enabled ~= nil and Config.jumping_enabled or true,
    Callback = function(state)        
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.JUMPING_ENABLED = state
        Config.jumping_enabled = state
        SaveConfig()
        WindUI:Notify({
            Title = "Jumping",
            Content = "Jumping " .. (state and "enabled" or "disabled"),
            Duration = 1.5,
            Icon = "arrow-up"
        })
    end
})

FarmAISection:Divider()

FarmAISlidersGroup = Tabs.Farm:Group({})
FarmAISlidersGroup:Slider({
    Title = "Distance From Ball",   
    Flag = "DistanceFromBall_SAVE",
    Value = { Min = 5, Max = 100, Default = Config.default_distance or 30 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        Config.default_distance = value
        AutoPlayModule.CONFIG.DEFAULT_DISTANCE = value
        SaveConfig()
        WindUI:Notify({
            Title = "Distance From Ball",
            Content = "Set to " .. value,
            Duration = 1.5,
            Icon = "ruler"
        })
    end
})

FarmAISlidersGroup:Slider({
    Title = "Speed Multiplier",   
    Flag = "SpeedMultiplier_SAVE",
    Value = { Min = 10, Max = 200, Default = Config.speed_multiplier or 70 },
    Callback = function(value)        
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.MULTIPLIER_THRESHOLD = value
        Config.speed_multiplier = value
        SaveConfig()
        WindUI:Notify({
            Title = "Speed Multiplier",
            Content = "Set to " .. value,
            Duration = 1.5,
            Icon = "speedometer"
        })
    end
})

FarmAISlidersGroup:Slider({
    Title = "Traversing",
    Flag = "Transversing_SAVE",
    Min = 0,
    Max = 100,
    Value = { Min = 0, Max = 100, Default = Config.traversing or 25 },
    Callback = function(value)        
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.TRAVERSING = value
        Config.traversing = value
        SaveConfig()
        WindUI:Notify({
            Title = "Traversing",
            Content = "Set to " .. value,
            Duration = 1.5,
            Icon = "move"
        })
    end
})

FarmAISlidersGroup:Slider({
    Title = "Direction",
    Flag = "Direction_SAVE",
    Min = -1,
    Max = 1,
    Value = { Min = -1, Max = 1, Default = Config.direction or 1 },
    Callback = function(value)       
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.DIRECTION = value
        Config.direction = value
        SaveConfig()
        WindUI:Notify({
            Title = "Direction",
            Content = "Set to " .. value,
            Duration = 1.5,
            Icon = "arrow-right"
        })
    end
})

FarmAISlidersGroup:Slider({
    Title = "Offset Factor",
    Flag = "OffsetFactor_SAVE",
    Min = 0.1,
    Max = 1,
    Value = { Min = 0.1, Max = 1, Default = Config.offset_factor or 0.7 },
    Callback = function(value)        
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.OFFSET_FACTOR = value
        Config.offset_factor = value
        SaveConfig()
        WindUI:Notify({
            Title = "Offset Factor",
            Content = "Set to " .. value,
            Duration = 1.5,
            Icon = "adjust"
        })
    end
})

FarmAISlidersGroup:Slider({
    Title = "Movement Duration",    
    Flag = "MovementDuration_SAVE",
    Value = { Min = 0.1, Max = 1, Default = Config.movement_duration or 0.8 },
    Callback = function(value)        
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.MOVEMENT_DURATION = value
        Config.movement_duration = value
        SaveConfig()
        WindUI:Notify({
            Title = "Movement Duration",
            Content = "Set to " .. value,
            Duration = 1.5,
            Icon = "timer"
        })
    end
})

FarmAISlidersGroup:Slider({
    Title = "Generation Threshold",
    Flag = "GenerationThreshold_SAVE",
    Min = 0.1,
    Max = 0.5,
    Value = { Min = 0.1, Max = 0.5, Default = Config.generation_threshold or 0.25 },
    Callback = function(value)        
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.GENERATION_THRESHOLD = value
        Config.generation_threshold = value
        SaveConfig()
        WindUI:Notify({
            Title = "Generation Threshold",
            Content = "Set to " .. value,
            Duration = 1.5,
            Icon = "clock"
        })
    end
})

FarmAISlidersGroup:Slider({
    Title = "Jump Chance",    
    Flag = "JumpChance_SAVE",
    Value = { Min = 0, Max = 100, Default = Config.jump_percentage or 50 },
    Callback = function(value)        
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.JUMP_PERCENTAGE = value
        Config.jump_percentage = value
        SaveConfig()
        WindUI:Notify({
            Title = "Jump Chance",
            Content = "Set to " .. value .. "%",
            Duration = 1.5,
            Icon = "arrow-up"
        })
    end
})

FarmAISlidersGroup:Slider({
    Title = "Double Jump Chance",   
    Flag = "DoubleJumpChance_SAVE",
    Value = { Min = 0, Max = 100, Default = Config.double_jump_percentage or 50 },
    Callback = function(value)       
        -- LOGIKA LENGKAP
        AutoPlayModule.CONFIG.DOUBLE_JUMP_PERCENTAGE = value
        Config.double_jump_percentage = value
        SaveConfig()
        WindUI:Notify({
            Title = "Double Jump Chance",
            Content = "Set to " .. value .. "%",
            Duration = 1.5,
            Icon = "arrow-up"
        })
    end
})

Tabs.Farm:Divider()

-- Section untuk Orbit Farm
FarmOrbitSection = Tabs.Farm:Section({
    Title = "Auto Farm Orbit",
    Desc = "Farm coins automatically by orbiting around the ball.",
    Box = true,
    BoxBorder = true,
    Opened = true
})

FarmOrbitSection:Toggle({
    Title = "Enable Auto Farm Orbit",
    Flag = "AutoFarmOrbitV2_SAVE",
    Value = Config.auto_farm_enabled,
    Callback = function(state)
        -- LOGIKA LENGKAP
        auto_farm_enabled = state
        Config.auto_farm_enabled = state
        SaveConfig()
        if state then
            if auto_farm_connection then
                auto_farm_connection:Disconnect()
                auto_farm_connection = nil
            end
            auto_farm_connection = RunService.Heartbeat:Connect(function()
                if not auto_farm_enabled then return end
                local rootPart = LocalPlayer.Character and (LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character.PrimaryPart)
                if not rootPart then return end
                local ball = AutoParry.get_ball()
                if not ball then return end

                local position = ball.Position
                local angle = tick() * math.pi * 2 / (auto_farm_orbit / 5)
                local time = tick()

                if auto_farm_type == "UnderBall" then
                    rootPart.CFrame = CFrame.new(position - Vector3.new(0, auto_farm_height, 0))
                elseif auto_farm_type == "X Orbit" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * auto_farm_radius,
                        0,
                        math.sin(angle) * auto_farm_radius
                    ))
                elseif auto_farm_type == "Y Orbit" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        0,
                        math.sin(angle) * auto_farm_radius,
                        math.cos(angle) * auto_farm_radius
                    ))
                elseif auto_farm_type == "Z Orbit" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * auto_farm_radius,
                        math.sin(angle) * auto_farm_radius,
                        0
                    ))
                elseif auto_farm_type == "Helix" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * auto_farm_radius,
                        math.sin(time) * auto_farm_height,
                        math.sin(angle) * auto_farm_radius
                    ))
                elseif auto_farm_type == "Figure8" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * auto_farm_radius,
                        0,
                        math.sin(2 * angle) * (auto_farm_radius / 2)
                    ))
                elseif auto_farm_type == "Spiral" then
                    local spiralRadius = auto_farm_radius * (1 + math.sin(time * 0.5))
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * spiralRadius,
                        time % auto_farm_height,
                        math.sin(angle) * spiralRadius
                    ))
                elseif auto_farm_type == "Random Orbit" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.noise(time) * auto_farm_radius,
                        math.noise(time + 10) * auto_farm_height,
                        math.noise(time + 20) * auto_farm_radius
                    ))
                end
            end)
        elseif auto_farm_connection then
            auto_farm_connection:Disconnect()
            auto_farm_connection = nil
        end
        WindUI:Notify({
            Title = "Auto Farm Orbit",
            Content = "Auto Farm Orbit " .. (state and "enabled" or "disabled"),
            Duration = 2,
            Icon = "refresh-cw"
        })
    end
})

FarmOrbitSection:Divider()

FarmOrbitSection:Dropdown({
    Title = "Orbit Type",
    Flag = "AutoFarmType_SAVE",
    Values = {"UnderBall", "X Orbit", "Y Orbit", "Z Orbit", "Helix", "Figure8", "Spiral", "Random Orbit"},
    Value = Config.auto_farm_type,
    Multi = false,
    Callback = function(selected)
        -- LOGIKA LENGKAP
        auto_farm_type = selected
        Config.auto_farm_type = selected
        SaveConfig()
    end
})

FarmOrbitSlidersGroup = Tabs.Farm:Group({})
FarmOrbitSlidersGroup:Slider({
    Title = "Orbit Speed",
    Flag = "OrbitSpeed_SAVE",
    Value = { Min = 1, Max = 20, Default = Config.auto_farm_orbit or 5 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        auto_farm_orbit = value
        Config.auto_farm_orbit = value
        SaveConfig()
    end
})

FarmOrbitSlidersGroup:Slider({
    Title = "Orbit Height",
    Flag = "OrbitHeight_SAVE",
    Value = { Min = 0, Max = 50, Default = Config.auto_farm_height or 10 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        auto_farm_height = value
        Config.auto_farm_height = value
        SaveConfig()
    end
})

FarmOrbitSlidersGroup:Slider({
    Title = "Orbit Radius",
    Flag = "OrbitRadius_SAVE",
    Value = { Min = 5, Max = 50, Default = Config.auto_farm_radius or 20 },
    Callback = function(value)
        -- LOGIKA LENGKAP
        auto_farm_radius = value
        Config.auto_farm_radius = value
        SaveConfig()
    end
})

Tabs.Settings:Paragraph({
    Title = "A Settings", 
    Desc =  "Ambatublow",    
    Color = "Red"
})



Tabs.Settings:Section({ Title = "Teleport", Icon = "plane" })

Tabs.Settings:Button({
    Title = "Rejoin",
    Icon = "refresh-cw",
    Callback = function()
        local teleportService = game:GetService("TeleportService")
        local success, result = pcall(function()
            teleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, game:GetService("Players").LocalPlayer)
        end)
        if success then
            WindUI:Notify({
                Title = "Rejoin",
                Content = "Rejoining current server",
                Duration = 0.5,
                Icon = "refresh-cw"
            })
        else
            WindUI:Notify({
                Title = "Rejoin Failed",
                Content = "Failed to rejoin: " .. tostring(result),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "Teleport To Mobile Server",
    Icon = "plane",
    Callback = function()
        local teleportService = game:GetService("TeleportService")
        local success, result = pcall(function()
            teleportService:TeleportToPlaceInstance(15509350986, nil, game:GetService("Players").LocalPlayer)
        end)
        if success then
            WindUI:Notify({
                Title = "Teleporting",
                Content = "Teleporting to Mobile server",
                Duration = 0.5,
                Icon = "plane"
            })
        else
            WindUI:Notify({
                Title = "Teleport Failed",
                Content = "Failed to find Mobile server: " .. tostring(result),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "Teleport To PC Server",
    Icon = "plane",
    Callback = function()
        local teleportService = game:GetService("TeleportService")
        local success, result = pcall(function()
            teleportService:TeleportToPlaceInstance(14732610803, nil, game:GetService("Players").LocalPlayer)
        end)
        if success then
            WindUI:Notify({
                Title = "Teleporting",
                Content = "Teleporting to PC server",
                Duration = 0.5,
                Icon = "plane"
            })
        else
            WindUI:Notify({
                Title = "Teleport Failed",
                Content = "Failed to find PC server: " .. tostring(result),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "Teleport To VC Server",
    Icon = "plane",
    Callback = function()
        local teleportService = game:GetService("TeleportService")
        local success, result = pcall(function()
            teleportService:TeleportToPlaceInstance(15131065025, nil, game:GetService("Players").LocalPlayer)
        end)
        if success then
            WindUI:Notify({
                Title = "Teleporting",
                Content = "Teleporting to VC server",
                Duration = 0.5,
                Icon = "plane"
            })
        else
            WindUI:Notify({
                Title = "Teleport Failed",
                Content = "Failed to find VC server: " .. tostring(result),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})


Tabs.Config:Section({ Title = "Configuration Management", Icon = "folder" })

-- Input untuk nama config
ConfigNameInput = Tabs.Config:Input({
    Title = "Config Name",
    Icon = "file-cog",
    Value = ConfigName,
    Callback = function(value)
        -- LOGIKA LENGKAP
        ConfigName = value
        -- Ganti config yang aktif saat nama diubah
        CurrentConfig = ConfigManager:Config(ConfigName)
        Window.CurrentConfig = CurrentConfig
    end
})

Tabs.Config:Space()

-- Dropdown untuk memilih config yang ada
AllConfigs = ConfigManager:AllConfigs()
ConfigDropdown = Tabs.Config:Dropdown({
    Title = "Select Existing Config",
    Desc = "Load a previously saved configuration.",
    Values = AllConfigs,
    Value = table.find(AllConfigs, ConfigName) and ConfigName or nil,
    Callback = function(selectedConfigName)
        -- LOGIKA LENGKAP
        ConfigName = selectedConfigName
        ConfigNameInput:Set(selectedConfigName) -- Update input text
        -- Set config yang dipilih sebagai config aktif
        CurrentConfig = ConfigManager:Config(ConfigName)
        Window.CurrentConfig = CurrentConfig
    end
})

Tabs.Config:Space()

-- Tombol untuk menyimpan config
Tabs.Config:Button({
    Title = "Save Current Config",
    Icon = "save",
    Justify = "Center",
    Callback = function()
        -- LOGIKA LENGKAP
        if CurrentConfig:Save() then
            WindUI:Notify({
                Title = "Config Saved",
                Content = "Configuration '" .. ConfigName .. "' has been saved.",
                Duration = 3,
                Icon = "check"
            })
            -- Refresh dropdown untuk menampilkan config baru (jika ada)
            ConfigDropdown:Refresh(ConfigManager:AllConfigs())
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to save config.",
                Duration = 3,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Config:Space()

-- Tombol untuk memuat config
Tabs.Config:Button({
    Title = "Load Selected Config",
    Icon = "refresh-cw",
    Justify = "Center",
    Callback = function()
        -- LOGIKA LENGKAP
        if CurrentConfig:Load() then
            WindUI:Notify({
                Title = "Config Loaded",
                Content = "Configuration '" .. ConfigName .. "' has been loaded.",
                Duration = 3,
                Icon = "check"
            })
            
            -- === LANGSUNG TERAPKAN LOGIKA CHEAT (VERSI DIPERBAIKI TANPA ERROR) ===
            print("Applying loaded config to game logic...")

            -- Definisikan fungsi untuk menerapkan satu fitur
            local function applyFeature(featureName, flagName, state)
                print("Applying " .. tostring(state) .. " to " .. tostring(featureName))
                
                if featureName == "Triggerbot" then
                    if state then
                        if not ConnectionsManager["triggerbot"] then
                            ConnectionsManager["triggerbot"] = RunService.PostSimulation:Connect(function()
                                -- Logika triggerbot
                                local character = LocalPlayer.Character
                                if not character or not character:FindFirstChild("HumanoidRootPart") or character.Parent == workspace.Dead then return end
                                local ball = AutoParry.get_ball()
                                if not ball or not AutoParry.ball.ball_entity then return end
                                local ball_properties = AutoParry.ball.properties
                                local singularityCape = character.PrimaryPart:FindFirstChild('SingularityCape')
                                if singularityCape then return end
                                local ping_threshold = math.clamp(Player.Entity.properties.ping / 10, 15, 20)
                                local parry_range = (ping_threshold + ball_properties.speed) * 2 / math.pi
                                if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
                                    if ball_properties.distance > parry_range then return end
                                    ball_properties.is_curved = AutoParry.is_curved()
                                    ball_properties.is_curveds = AutoParry.is_curveds()
                                    if ball_properties.is_curved or ball_properties.is_curveds then return end
                                    if (tick() - ball_properties.last_hit) < (1 - math.clamp(ping_threshold / 100, 0.1, 0.7)) then return end
                                    task.spawn(function() AutoParry:PerformParry() end)
                                    ball_properties.last_hit = tick()
                                end
                            end)
                        end
                    else
                        if ConnectionsManager["triggerbot"] then
                            ConnectionsManager["triggerbot"]:Disconnect()
                            ConnectionsManager["triggerbot"] = nil
                        end
                    end
                elseif featureName == "Visualizer Monitor" then
                    if not visualizerData then
                        visualizerData = {}
                    end

                    if state then
                        if not ConnectionsManager["visualizer"] then
                            task.defer(function()
                                local visualizePart = Instance.new("Part", workspace)
                                visualizePart.Name = "VicoX_VisualizerPart"
                                visualizePart.Material = Enum.Material.ForceField
                                visualizePart.CanCollide = false
                                visualizePart.Shape = Enum.PartType.Ball
                                visualizePart.Anchored = true
                                visualizePart.Size = Vector3.new(2, 2, 2)
                                visualizePart.Color = Color3.fromRGB(0, 255, 0)
                                visualizerData.part = visualizePart
                                
                                ConnectionsManager["visualizer"] = RunService.RenderStepped:Connect(function()
                                    if not visualizerData or not visualizerData.part then return end
                                    local ball = AutoParry.get_ball()
                                    if not ball then
                                        visualizerData.part.Transparency = 1
                                        return
                                    end
                                    local ballPosition = ball.Position
                                    local player = LocalPlayer.Character
                                    if not player or not player:FindFirstChild("HumanoidRootPart") then
                                        visualizerData.part.Transparency = 1
                                        return
                                    end
                                    local playerPosition = player.HumanoidRootPart.Position
                                    local distance = (ballPosition - playerPosition).Magnitude
                                    local maxDistance = 50
                                    local minSize = 2
                                    local maxSize = 7
                                    local size = maxSize - (maxSize - minSize) * (distance / maxDistance)
                                    size = math.clamp(size, minSize, maxSize)
                                    local lagDistance = (visualizerData.part.Position - ballPosition).Magnitude
                                    
                                    if lagDistance < 0.5 then
                                        visualizerData.part.Color = Color3.fromRGB(0, 255, 0)
                                    elseif lagDistance < 2 then
                                        visualizerData.part.Color = Color3.fromRGB(255, 255, 0)
                                    else
                                        visualizerData.part.Color = Color3.fromRGB(255, 0, 0)
                                    end
                                    
                                    visualizerData.part.Transparency = 0
                                    visualizerData.part.Position = ballPosition
                                    visualizerData.part.Size = Vector3.new(size, size, size)
                                end)
                            end)
                        end
                    else
                        if ConnectionsManager["visualizer"] then
                            ConnectionsManager["visualizer"]:Disconnect()
                            ConnectionsManager["visualizer"] = nil
                        end
                        if visualizerData and visualizerData.part then
                            visualizerData.part:Destroy()
                            visualizerData.part = nil
                        end
                    end
                elseif featureName == "Strafe" then
                    Config.strafe = state
                    -- Logika Strafe biasanya mengubah properti game atau input
                    -- ...
                elseif featureName == "No Slow" then
                    Config.no_slow = state
                    local Lighting = game:GetService("Lighting")
                    if state then
                        Lighting.FogEnd = 100000
                    else
                        Lighting.FogEnd = 0 -- Kembalikan ke default
                    end
                -- ... (Tambahkan logika untuk fitur lainnya di sini) ...
                end
            end

            -- Tabel yang memetakan fitur dan koneksi yang perlu diterapkan
            local FeaturesToApply = {
                ["Triggerbot"] = { Flag = "TriggerBot_SAVE", Connection = "triggerbot" },
                ["Visualizer Monitor"] = { Flag = "VisualizerMonitorBall_SAVE", Connection = "visualizer" },
                ["Strafe"] = { Flag = "Strafe_SAVE", Connection = nil },
                ["No Slow"] = { Flag = "NoSlow_SAVE", Connection = nil },
                -- ... (tambahkan fitur lainnya) ...
            }

            -- Loop melalui semua fitur yang ada di config
            for featureName, featureData in pairs(FeaturesToApply) do
                local flagName = featureData.Flag
                local connectionName = featureData.Connection
                
                local loadedState = CurrentConfig.Flags[flagName]
                
                if loadedState ~= nil then
                    applyFeature(featureName, flagName, loadedState)
                else
                    if connectionName and ConnectionsManager[connectionName] then
                        applyFeature(featureName, flagName, false)
                    end
                end
            end

            WindUI:Notify({
                Title = "Config Applied",
                Content = "All settings from the config have been applied.",
                Duration = 3,
                Icon = "check"
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to load config.",
                Duration = 3,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Config:Divider()

-- Toggle untuk Auto Load
AutoLoadToggle = Tabs.Config:Toggle({
    Title = "Auto Load on Start",
    Desc = "Automatically load this config when the script runs.",
    Value = CurrentConfig.AutoLoad or false,
    Callback = function(state)
        -- LOGIKA LENGKAP
        CurrentConfig:SetAutoLoad(state)
        SaveConfig() -- Simpan preferensi auto-load
    end
})

Tabs.Config:Space()

-- Section untuk manajemen config lebih lanjut
ConfigManagementSection = Tabs.Config:Section({
    Title = "Advanced Management",
    Desc = "Delete or get information about your configurations.",
    Box = true,
    BoxBorder = true,
    Opened = false
})

ConfigManagementSection:Button({
    Title = "Delete Current Config",
    Icon = "trash-2",
    Justify = "Center",
    Callback = function()
        -- LOGIKA LENGKAP
        local success, err = pcall(function()
            ConfigManager:DeleteConfig(ConfigName)
        end)
        if success then
            WindUI:Notify({
                Title = "Config Deleted",
                Content = "Configuration '" .. ConfigName .. "' has been deleted.",
                Duration = 3,
                Icon = "trash-2"
            })
            -- Refresh dropdown
            ConfigDropdown:Refresh(ConfigManager:AllConfigs())
            -- Set ke config default baru
            ConfigName = "VicoX_Default"
            CurrentConfig = ConfigManager:Config(ConfigName)
            Window.CurrentConfig = CurrentConfig
            ConfigNameInput:Set(ConfigName)
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to delete config: " .. tostring(err),
                Duration = 3,
                Icon = "alert-triangle"
            })
        end
    end
})

ConfigManagementSection:Button({
    Title = "List All Configs (in Console)",
    Icon = "list",
    Justify = "Center",
    Callback = function()
        -- LOGIKA LENGKAP
        local allConfigs = ConfigManager:AllConfigs()
        if #allConfigs > 0 then
            print("---------- VicoX Configs ----------")
            for i, name in ipairs(allConfigs) do
                print(i .. ". " .. name)
            end
            print("----------------------------------")
            WindUI:Notify({
                Title = "Configs Listed",
                Content = "Check the developer console (F9) for a list of all configs.",
                Duration = 4,
                Icon = "list"
            })
        else
            WindUI:Notify({
                Title = "No Configs Found",
                Content = "You haven't saved any configs yet.",
                Duration = 3,
                Icon = "info"
            })
        end
    end
})

Tabs.Theme:Paragraph({
    Title = "UI Theme & Appearance",
    Desc = "Customize the look and feel of the VicoX interface.",
    Image = "rbxassetid://129260712070622",
    ImageSize = 48,
    Color = Color3.fromHex("#FF69B4")
})

-- BUAT SATU SECTION UTAMA UNTUK SEMUA ELEMEN THEME
ThemeMainSection = Tabs.Theme:Section({
    Title = "Theme Settings",
    Desc = "Customize all theme-related settings here",
    Box = true,
    BoxBorder = true,
    Opened = true
})

-- 1. THEME SELECTION
ThemeMainSection:Paragraph({
    Title = "Theme Selection",
    Desc = "Choose from a variety of pre-made themes.",
    Image = "rbxassetid://773396269241",
    ImageSize = 24,
    FontSize = "Medium"
})

-- Mengambil daftar tema yang tersedia di WindUI
local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

ThemeMainSection:Dropdown({
    Title = "Select Theme",
    Flag = "SelectTheme_SAVE",
    Multi = false,
    AllowNone = false,
    Value = Config.selected_theme or WindUI:GetCurrentTheme(),
    Values = themeValues,
    Callback = function(theme)
        WindUI:SetTheme(theme)
        Config.selected_theme = theme
        SaveConfig()
        WindUI:Notify({
            Title = "Theme Changed",
            Content = "Theme applied: " .. theme,
            Duration = 2,
            Icon = "palette"
        })
    end
})

ThemeMainSection:Toggle({
    Title = "Window Transparency",
    Flag = "ToggleWindowTransparency_SAVE",
    Value = Config.window_transparency ~= nil and Config.window_transparency or WindUI:GetTransparency(),
    Callback = function(e)
        Window:ToggleTransparency(e)
        Config.window_transparency = e
        SaveConfig()
    end,
})

ThemeMainSection:Divider()

-- 2. CUSTOM THEME CREATOR
ThemeMainSection:Paragraph({
    Title = "Custom Theme Creator",
    Desc = "Create your own unique theme with custom colors.",
    Image = "rbxassetid://7733960981",
    ImageSize = 24,
    FontSize = "Medium"
})

-- Variabel untuk menyimpan state tema kustom
local currentThemeName = Config.theme_name or "MyCustomTheme"
local ThemeAccent = Config.theme_accent or "#FF0000"
local ThemeOutline = Config.theme_outline or "#000000"
local ThemeText = Config.theme_text or "#FFFFFF"

ThemeMainSection:Input({
    Title = "Theme Name",
    Flag = "ThemeName_SAVE",
    Icon = "type",
    Value = currentThemeName,
    Callback = function(name)
        currentThemeName = name
        Config.theme_name = name
        SaveConfig()
        WindUI:Notify({
            Title = "Theme Name",
            Content = "Theme name set to " .. name,
            Duration = 2,
            Icon = "type"
        })
    end
})

ThemeMainSection:Colorpicker({
    Title = "Accent Color",
    Flag = "ThemeAccentColor_SAVE",
    Icon = "paintbrush",
    Default = Color3.fromHex(ThemeAccent),
    Callback = function(color)
        ThemeAccent = color:ToHex()
        Config.theme_accent = ThemeAccent
        SaveConfig()
        WindUI:Notify({
            Title = "Accent Color",
            Content = "Accent color set to " .. color:ToHex(),
            Duration = 2,
            Icon = "paintbrush"
        })
    end
})

ThemeMainSection:Colorpicker({
    Title = "Outline Color",
    Flag = "ThemeOutlineColor_SAVE",
    Icon = "paintbrush",
    Default = Color3.fromHex(ThemeOutline),
    Callback = function(color)
        ThemeOutline = color:ToHex()
        Config.theme_outline = ThemeOutline
        SaveConfig()
        WindUI:Notify({
            Title = "Outline Color",
            Content = "Outline color set to " .. color:ToHex(),
            Duration = 2,
            Icon = "paintbrush"
        })
    end
})

ThemeMainSection:Colorpicker({
    Title = "Text Color",
    Flag = "TextColor_SAVE",
    Icon = "paintbrush",
    Default = Color3.fromHex(ThemeText),
    Callback = function(color)
        ThemeText = color:ToHex()
        Config.theme_text = ThemeText
        SaveConfig()
        WindUI:Notify({
            Title = "Text Color",
            Content = "Text color set to " .. color:ToHex(),
            Duration = 2,
            Icon = "paintbrush"
        })
    end
})

ThemeMainSection:Button({
    Title = "Apply Custom Theme",
    Icon = "check-circle",
    Justify = "Center",
    Callback = function()
        WindUI:AddTheme({
            Name = currentThemeName,
            Accent = ThemeAccent,
            Outline = ThemeOutline,
            Text = ThemeText,
            Placeholder = ThemePlaceholderText
        })
        WindUI:SetTheme(currentThemeName)
        WindUI:Notify({
            Title = "Custom Theme Applied",
            Content = "Applied custom theme: " .. currentThemeName,
            Duration = 3,
            Icon = "check-circle"
        })
    end
})

ThemeMainSection:Divider()

-- 3. COLOR PRESETS
ThemeMainSection:Paragraph({
    Title = "Color Presets",
    Desc = "Quickly apply pre-defined color schemes.",
    Image = "rbxassetid://773396269241",
    ImageSize = 20,
    FontSize = "Small"
})

local colorPresets = {
    ["VicoX Red"] = { accent = "#FF0000", outline = "#8B0000", text = "#FFFFFF" },
    ["Ocean Blue"] = { accent = "#006994", outline = "#003f5c", text = "#B0E0E6" },
    ["Forest Green"] = { accent = "#228B22", outline = "#006400", text = "#90EE90" },
    ["Royal Purple"] = { accent = "#7851A9", outline = "#4B0082", text = "#DDA0DD" },
    ["Sunset Orange"] = { accent = "#FF8C00", outline = "#CC5500", text = "#FFE4B5" },
    ["Monochrome"] = { accent = "#808080", outline = "#2F4F4F", text = "#D3D3D3" }
}

-- Buat layout grid untuk tombol preset
local presetButtons = {}
for presetName, colors in pairs(colorPresets) do
    table.insert(presetButtons, {
        Title = presetName,
        Icon = "palette",
        Callback = function()
            ThemeAccent = colors.accent
            ThemeOutline = colors.outline
            ThemeText = colors.text
            Config.theme_accent = ThemeAccent
            Config.theme_outline = ThemeOutline
            Config.theme_text = ThemeText
            SaveConfig()
            WindUI:Notify({
                Title = "Preset Applied",
                Content = "Color preset '" .. presetName .. "' applied.",
                Duration = 2,
                Icon = "palette"
            })
        end
    })
end

-- Tambahkan tombol preset satu per satu
for _, buttonData in ipairs(presetButtons) do
    ThemeMainSection:Button({
        Title = buttonData.Title,
        Icon = buttonData.Icon,
        Callback = buttonData.Callback
    })
end

ThemeMainSection:Divider()

-- 4. UI SCALING
ThemeMainSection:Paragraph({
    Title = "UI Scaling",
    Desc = "Adjust the overall size of the user interface.",
    Image = "rbxassetid://7733960981",
    ImageSize = 24,
    FontSize = "Medium"
})

ThemeMainSection:Slider({
    Title = "UI Scale",
    Flag = "UIScale_SAVE",
    Icon = "maximize-2",
    Value = { Min = 0.5, Max = 1.5, Default = Config.ui_scale or 1.0, Prec = 2 },
    Callback = function(value)
        Window:SetUIScale(value)
        Config.ui_scale = value
        SaveConfig()
        WindUI:Notify({
            Title = "UI Scale",
            Content = "UI Scale set to " .. value,
            Duration = 2,
            Icon = "maximize-2"
        })
    end
})

ThemeMainSection:Button({
    Title = "Reset Scale to Default",
    Icon = "refresh-cw",
    Justify = "Center",
    Callback = function()
        Window:SetUIScale(1.0)
        Config.ui_scale = 1.0
        SaveConfig()
        WindUI:Notify({
            Title = "UI Scale Reset",
            Content = "UI scale has been reset to default.",
            Duration = 2,
            Icon = "refresh-cw"
        })
    end
})

-- Tampilkan notifikasi saat tab dibuka
WindUI:Notify({
    Title = "Theme Settings",
    Content = "Customize your UI appearance here",
    Duration = 2,
    Icon = "palette"
})

local InviteCode = "wdMvehhA62"
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

local Response = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
    Url = DiscordAPI,
    Method = "GET",
    Headers = {
        ["User-Agent"] = "RobloxBot/1.0",
        ["Accept"] = "application/json"
    }
}).Body)

if Response and Response.guild then
    local DiscordInfo = Tabs.Info:Paragraph({
        Title = Response.guild.name,
        Desc = 
            ' <font color="#52525b">â€¢</font> Member Count : ' .. tostring(Response.approximate_member_count) .. 
            '\n <font color="#16a34a">â€¢</font> Online Count : ' .. tostring(Response.approximate_presence_count)
        ,
        Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=1024",
        ImageSize = 42,
    })

    Tabs.Info:Button({
        Title = "Update Info",
        Image = "refresh-ccw",
        Callback = function()
            local UpdatedResponse = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
                Url = DiscordAPI,
                Method = "GET",
            }).Body)
            
            if UpdatedResponse and UpdatedResponse and UpdatedResponse.guild then
                DiscordInfo:SetDesc(
                    ' <font color="#52525b">â€¢</font> Member Count : ' .. tostring(UpdatedResponse.approximate_member_count) .. 
                    '\n <font color="#16a34a">â€¢</font> Online Count : ' .. tostring(UpdatedResponse.approximate_presence_count)
                )
            end
        end
    })
else
    Tabs.Info:Paragraph({
        Title = "Error when receiving information about the Discord server",
        Desc = game:GetService("HttpService"):JSONEncode(Response),
        Image = "triangle-alert",
        ImageSize = 26,
        Color = "Red",
    })
end

local LocalPlayer = Players.LocalPlayer

LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.zero)
end)

local function updateIndicator()
    if not getgenv().BallDirectionIndicator or not ScreenGui.Enabled then
        Arrow.Visible = false        
        return
    end
    local ball = AutoParry.ball.ball_entity
    if not ball or not AutoParry.ball.properties or not AutoParry.ball.properties.position then
        Arrow.Visible = false       
        return
    end
    local playerChar = player.Character
    local playerHrp = playerChar and playerChar:FindFirstChild("HumanoidRootPart")
    if not playerHrp then
        Arrow.Visible = false       
        return
    end
    local ball_position = AutoParry.ball.properties.position
    local distance = AutoParry.ball.properties.distance or (playerHrp.Position - ball_position).Magnitude
    
    local color
    if distance < 30 then
        color = Color3.new(1, 1, 1) -- Putih (dekat)
    elseif distance < 100 then
        color = Color3.new(1, 1, 0) -- Kuning (sedang)
    else
        color = Color3.new(1, 0, 0) -- Merah (jauh)
    end
    Arrow.ImageColor3 = color
    
    local viewportSize = cam.ViewportSize
    local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    local screenPoint, onScreen = cam:WorldToViewportPoint(ball_position)
    
    Arrow.Visible = true
    local offset = 50
    local direction = Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter
    if direction.Magnitude < 0.01 then
        Arrow.Visible = false        
        return
    end
    direction = direction.Unit
    local edgeX = screenCenter.X + direction.X * offset
    local edgeY = screenCenter.Y + direction.Y * offset

    local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = tweenService:Create(Arrow, tweenInfo, {Position = UDim2.new(0, edgeX, 0, edgeY)})
    tween:Play()

    
    local angle = math.atan2(direction.Y, direction.X)
    Arrow.Rotation = math.deg(angle) + 280
    
    local ping = Player.Entity.properties.ping or 0
    local ping_threshold = math.clamp(ping / 10, 13, 19)    
    local speed_factor = (ping_threshold + AutoParry.ball.properties.speed) * 1.58       
    Arrow.ImageTransparency = distance <= ping_threshold and 0 or 0.5
end

ConnectionsManager['ball_direction_indicator'] = RunService.RenderStepped:Connect(updateIndicator)






local self = AutoParry.ball.ball_entity
    local Visualize = Instance.new("Part",workspace)
    Visualize.Color = Color3.new(1, 1, 1)
    Visualize.Material = Enum.Material.ForceField
    Visualize.Transparency = 0.5
    Visualize.Anchored = true
    Visualize.CanCollide = false
    Visualize.CastShadow = false
    Visualize.Shape = Enum.PartType.Ball
    Visualize.Size = Vector3.new(30,30,30)
    local Popobd = Instance.new("Part",workspace)
    Popobd.Color = Color3.new(1, 0, 1)
    Popobd.Material = Enum.Material.ForceField
    Popobd.Transparency = 0.5
    Popobd.Anchored = true
    Popobd.CanCollide = false
    Popobd.CastShadow = false
    Popobd.Shape = Enum.PartType.Ball
    Popobd.Size = Vector3.new(30,30,30)
    local jihag = Instance.new("Part",workspace)
    jihag.Color = Color3.new(0, 0, 1)
    jihag.Material = Enum.Material.ForceField
    jihag.Transparency = 0.5
    jihag.Anchored = true
    jihag.CanCollide = false
    jihag.CastShadow = false
    jihag.Shape = Enum.PartType.Ball
    jihag.Size = Vector3.new(30,30,30)
    local Popobdm = Instance.new("Highlight")
    Popobdm.Parent = Popobd
    Popobdm.Enabled = true
    Popobdm.FillTransparency = 0
    Popobdm.OutlineColor = Color3.new(1, 1, 1)
    local jihagm = Instance.new("Highlight")
    jihagm.Parent = jihag
    jihagm.Enabled = true
    jihagm.FillTransparency = 0
    jihagm.OutlineColor = Color3.new(1, 1, 1)
    local Highlight = Instance.new("Highlight")
    Highlight.Parent = Visualize
    Highlight.Enabled = true
    Highlight.FillTransparency = 0
    Highlight.OutlineColor = Color3.new(1, 1, 1)
    
    RunService.PreSimulation:Connect(function()
        if Config.visualize_Enabled and LocalPlayer then
            Visualize.Transparency = 0
            Visualize.Material = Enum.Material.ForceField
            Visualize.Size = Vector3.new(AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range)
            Visualize.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
            Popobd.Transparency = 0
            Popobd.Material = Enum.Material.ForceField
            Popobd.Size = Vector3.new(AutoParry.ball.properties.distance,AutoParry.ball.properties.distance,AutoParry.ball.properties.distance)
            Popobd.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
            jihag.Transparency = 0
            jihag.Material = Enum.Material.ForceField
            jihag.Size = Vector3.new(AutoParry.ball.properties.speed,AutoParry.ball.properties.speed,AutoParry.ball.properties.speed)
            jihag.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
        else
            Visualize.Material = Enum.Material.ForceField
            Visualize.Transparency = 1
            Popobd.Material = Enum.Material.ForceField
            Popobd.Transparency = 1
            jihag.Material = Enum.Material.ForceField
            jihag.Transparency = 1
        end	
        if AutoParry.ball.properties.auto_spam then
          Visualize.Color = Color3.new(1, 0, 0)
          Visualize.Size = Vector3.new(30, 30, 30)
        elseif not (AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character) then
        Visualize.Color = Color3.new(0, 1, 0)
        Visualize.Size = Vector3.new(AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range)
        elseif AutoParry.ball.properties.distance < AutoParry.ball.properties.parry_range then
        Visualize.Color = Color3.new(0, 0, 0)
        Visualize.Size = Vector3.new(AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range)
        else
          Visualize.Color = Color3.new(1, 1, 1)
        end
    end)


local function createBillboard(parent, name)
    if not parent or not parent:IsA("BasePart") or not parent.Parent then
        warn("createBillboard: Invalid or missing parent for " .. tostring(name))
        return nil
    end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = name
    billboard.Parent = parent
    billboard.Adornee = parent
    billboard.Size = UDim2.new(0, 200, 0, 70) -- Fits all text
    billboard.StudsOffset = Vector3.new(0, 3.5, 0)
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = 80 -- Optimized for Android

    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "InfoTextLabel"
    textLabel.Parent = billboard
    textLabel.BackgroundTransparency = 1
    textLabel.Size = UDim2.new(0.9, 0, 0.9, 0) -- Padding
    textLabel.Position = UDim2.new(0.05, 0, 0.05, 0)
    textLabel.Font = Enum.Font.Gotham
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextScaled = false
    textLabel.TextSize = 14
    textLabel.TextWrapped = true
    textLabel.TextXAlignment = Enum.TextXAlignment.Left
    textLabel.TextYAlignment = Enum.TextYAlignment.Top
    textLabel.Text = ""

    local uiStroke = Instance.new("UIStroke")
    uiStroke.Name = "TextOutline"
    uiStroke.Parent = textLabel
    uiStroke.Color = Color3.fromRGB(0, 0, 0)
    uiStroke.Thickness = 1.5
    uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = textLabel

    return billboard
end

-- Assign to placeholder
updateBillboardText = function()
    local currentTime = tick()
    if currentTime - lastUpdateTime < 0.1 then return end
    lastUpdateTime = currentTime

    -- Update Ball Text
    if Config.ball_text_enabled then
        local ball = AutoParry.get_ball()
        if ball and ball:IsA("BasePart") and ball.Parent then
            -- Create or update billboard
            if not BallBillboard or BallBillboard.Adornee ~= ball then
                if BallBillboard then
                    BallBillboard:Destroy()
                    BallBillboard = nil
                end
                BallBillboard = createBillboard(ball, "BallInfoBillboard")
                if not BallBillboard then
                    warn("Failed to create BallBillboard")
                    return
                end
            end
            -- Update text and color
            local ball_properties = AutoParry.ball.properties
            local velocity = (typeof(ball_properties.velocity) == "Vector3" and ball_properties.velocity.Magnitude) or 0
            local is_curved = ball_properties.is_curved
            local range = ball_properties.distance or 0
            local isTargetPlayer = AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name
            if BallBillboard and BallBillboard.InfoTextLabel then
                BallBillboard.InfoTextLabel.Text = string.format(
                    "Velocity: %.1f\nCurved: %s\nRange: %.1f\nTarget: %s",
                    velocity, tostring(is_curved), range, tostring(isTargetPlayer)
                )
                local targetColor = (is_curved or isTargetPlayer) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)
                if BallBillboard.InfoTextLabel.TextColor3 ~= targetColor then
                    create_animation(BallBillboard.InfoTextLabel, TweenInfo.new(0.5), {TextColor3 = targetColor})
                end
                BallBillboardEnabled = true                
            else
                warn("BallBillboard or InfoTextLabel is nil")
            end
        else
            if BallBillboard then
                BallBillboard:Destroy()
                BallBillboard = nil
                ballBillboardEnabled = false
            end
        end
    else
        if BallBillboard then
            BallBillboard:Destroy()
            BallBillboard = nil
            ballBillboardEnabled = false
        end
    end

   
    if Config.player_text_enabled then
        local player = LocalPlayer.Character
        local hrp = player and (player:FindFirstChild("HumanoidRootPart") or player.PrimaryPart)
        if hrp and hrp:IsA("BasePart") and hrp.Parent then
            -- Create or update billboard
            if not PlayerBillboard or PlayerBillboard.Adornee ~= hrp then
                if PlayerBillboard then
                    PlayerBillboard:Destroy()
                    PlayerBillboard = nil
                end
                PlayerBillboard = createBillboard(hrp, "PlayerInfoBillboard")
                if not PlayerBillboard then
                    warn("Failed to create PlayerBillboard")
                    return
                end
            end
            -- Update text and color
            local ball = AutoParry.get_ball()
            local range = ball and (hrp.Position - ball.Position).Magnitude or 0
            local auto_spam = AutoParry.ball.properties.auto_spam
            if PlayerBillboard and PlayerBillboard.InfoTextLabel then
                PlayerBillboard.InfoTextLabel.Text = string.format(
                    "Range to Ball: %.1f\nAutoSpam: %s",
                    range, tostring(auto_spam)
                )
                local targetColor = auto_spam and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 255)
                if PlayerBillboard.InfoTextLabel.TextColor3 ~= targetColor then
                    create_animation(PlayerBillboard.InfoTextLabel, TweenInfo.new(0.5), {TextColor3 = targetColor})
                end
                PlayerBillboardEnabled = true                
            else
                warn("PlayerBillboard or InfoTextLabel is nil")
            end
        else
            if PlayerBillboard then
                PlayerBillboard:Destroy()
                PlayerBillboard = nil
                playerBillboardEnabled = false
            end
        end
    else
        if PlayerBillboard then
            PlayerBillboard:Destroy()
            PlayerBillboard = nil
            playerBillboardEnabled = false -- Uncomment if using new variable
        end
    end
end

workspace.Balls.ChildRemoved:Connect(function(child)
    if BallBillboard and child == BallBillboard.Adornee then
        BallBillboard:Destroy()
        BallBillboard = nil       
    end
end)

workspace.Alive.ChildRemoved:Connect(function(player)
    if player == LocalPlayer.Character and PlayerBillboard then
        PlayerBillboard:Destroy()
        PlayerBillboard = nil        
    end
end)

if ConnectionsManager['billboard_text'] then
    ConnectionsManager['billboard_text']:Disconnect()
end
ConnectionsManager['billboard_text'] = RunService.Heartbeat:Connect(function()
    if updateBillboardText then
        updateBillboardText()
    else
        warn("updateBillboardText is nil in Heartbeat")
    end
end)
    
ConnectionsManager['camera_field_of_view'] = RunService.PostSimulation:Connect(function()
    if not workspace.CurrentCamera then
        return
    end
    local character = LocalPlayer.Character
    if not character then
        return
    end
    local camera_enabled = Config.camera
    local current_camera = workspace.CurrentCamera
    if not camera_enabled then
        current_camera.FieldOfView = 70
        return
    end
    local field_of_view = Config.field_of_view
    current_camera.FieldOfView = field_of_view
    if AutoParry.ball.client_ball_entity == nil or #workspace.Balls:GetChildren() == 0 then
        current_camera.CameraSubject = LocalPlayer.Character
        return
    end
end)

local spamming_done = true
ConnectionsManager['ability_vulnerability'] = RunService.PostSimulation:Connect(function()
    local ability_vulnerability_enabled = Config.ability_vulnerability
    if not ability_vulnerability_enabled then
        spamming_done = true
        return
    end
    local character = LocalPlayer.Character
    if not character or Player.Entity.properties.ping > 250 then
        return
    end
    local mode = Config.ability_vulnerability_mode
    if not spamming_done or not character.Abilities[mode].Enabled then
        return
    end
    if not mode or mode == 'Quad Jump' then
        spamming_done = false
        for threads = 1, 3650 do
            ReplicatedStorage.Remotes.XtraJumped:FireServer()
        end
        spamming_done = true
    elseif mode == 'Continuity Zero' and AutoParry.target.current ~= LocalPlayer.Character then
        spamming_done = false
        ReplicatedStorage.Remotes.UseContinuityPortal:FireServer(CFrame.new(tick(), tick(), tick(), tick(), tick(), tick(), tick()))
        task.delay(20, function()
            spamming_done = true
        end)
    elseif mode == 'Quasar' then
        spamming_done = false
        ReplicatedStorage.Remotes.PlrQuasared:FireServer(AutoParry.target.aim)
        task.delay(0.085, function()
            spamming_done = true
        end)
    end
end)

-- Gravity
ConnectionsManager['gravity'] = RunService.PostSimulation:Connect(function()
    if not workspace.CurrentCamera or not LocalPlayer.Character then
        return
    end
    local gravity_enabled = Config.gravity
    if not gravity_enabled then
        workspace.Gravity = 196.2
        return
    end
    local strength = Config.gravity_strength
    workspace.Gravity = 196.2 / (strength / 10)
end)

local function setupBillboardSystem()
    local billboardLabels = {}
    local maxBillboards = 15
    local count = 0
    local lastUpdate = 0
    local updateInterval = 0.2

    local function createBillboardGui(player)
        if player == Players.LocalPlayer then
            return
        end

        local character = player.Character
        if not character then
            return
        end

        local head = character:FindFirstChild("Head")
        if not head then
            return
        end

        local billboardGui = Instance.new("BillboardGui")
        billboardGui.Adornee = head
        billboardGui.Size = UDim2.new(0, 100, 0, 25)
        billboardGui.StudsOffset = Vector3.new(0, 2, 0)
        billboardGui.AlwaysOnTop = false
        billboardGui.Parent = head

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.TextSize = 6
        textLabel.BackgroundTransparency = 1
        textLabel.TextXAlignment = Enum.TextXAlignment.Center
        textLabel.TextYAlignment = Enum.TextYAlignment.Center
        textLabel.Parent = billboardGui
        billboardLabels[player] = textLabel

        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        end
    end

    Players.PlayerRemoving:Connect(function(player)
        if billboardLabels[player] then
            billboardLabels[player].Parent.Parent:Destroy()
            billboardLabels[player] = nil
        end
    end)

    ConnectionsManager['ability_esp'] = RunService.Heartbeat:Connect(function()
        if tick() - lastUpdate < updateInterval then
            return
        end
        lastUpdate = tick()

        if not Config.ability_esp then
            for _, label in pairs(billboardLabels) do
                label.Visible = false
            end
            return
        end

        for player, label in pairs(billboardLabels) do
            local character = player.Character
            if not character or not character.Parent or character.Parent ~= workspace:FindFirstChild("Alive") then
                label.Visible = false
                continue
            end
            label.Visible = true
            local abilityName = player:GetAttribute("EquippedAbility") or ""
            label.Text = abilityName == "" and player.DisplayName or (player.DisplayName .. " [" .. abilityName .. "]")
        end
    end)

    for _, player in ipairs(Players:GetPlayers()) do
        if count >= maxBillboards then
            break
        end
        pcall(createBillboardGui, player)
        count += 1
    end

    Players.PlayerAdded:Connect(function(player)
        if count < maxBillboards then
            pcall(createBillboardGui, player)
            count += 1
        end
    end)
end

-- Personnel Detector
local staff_roles = { 'content creator', 'contributor', 'trial qa', 'tester', 'mod' }
Players.PlayerAdded:Connect(function(player)
    local is_friend = LocalPlayer:IsFriendsWith(player.UserId)
    if is_friend then
        WindUI:Notify({
            Title = "Friend Joined",
            Content = "Friend " .. player.Name .. " joined!",
            Duration = 4,
        })
    end
    local personnel_detector_enabled = Config.personnel_detector
    if not personnel_detector_enabled then
        return
    end
    local personnel_detector_auto_leave_enabled = Config.personnel_detector_auto_leave
    local player_role = tostring(player:GetRoleInGroup(12836673)):lower()
    local player_is_staff = table.find(staff_roles, player_role)
    if player_is_staff then
        if personnel_detector_auto_leave_enabled then
            game:Shutdown()
            return
        end
        WindUI:Notify({
            Title = "Personnel Detected",
            Content = "Personnel joined, " .. player.Name .. ", role " .. player_role .. ".",
            Duration = 30,
        })
    end
end)

ConnectionsManager['strafe'] = RunService.PostSimulation:Connect(function()
    if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        return
    end
    local strafe_enabled = Config.strafe
    if not strafe_enabled then
        return
    end
    local strength = Config.strafe_speed
    local Humanoid = LocalPlayer.Character.Humanoid
    if not Humanoid or Humanoid.MoveDirection.Magnitude < 0 then
        return
    end
    LocalPlayer.Character:TranslateBy(LocalPlayer.Character.Humanoid.MoveDirection * math.max((strength / 15), 2) * RunService.Heartbeat:Wait() * 10)
end)

ConnectionsManager['ball_effects'] = workspace.Balls.ChildAdded:Connect(function(ball)
    if not ball:GetAttribute("realBall") then
        return
    end
    if Config.particle_emitter then
        if not ball:FindFirstChild("ParticleEmitter") then
            local emitter = Instance.new("ParticleEmitter")
            emitter.Name = "ParticleEmitter"
            emitter.Rate = 100
            emitter.Lifetime = NumberRange.new(0.5, 1)
            emitter.Speed = NumberRange.new(0, 1)
            emitter.Size = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.5),
                NumberSequenceKeypoint.new(1, 0)
            })
            emitter.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 1)
            })
            emitter.Parent = ball
        end
    end
    if Config.glow_effect then
        if not ball:FindFirstChild("BallGlow") then
            local glow = Instance.new("PointLight")
            glow.Name = "BallGlow"
            glow.Range = 15
            glow.Brightness = 2
            glow.Parent = ball
        end
    end
end)

ConnectionsManager['training_ball_effects'] = workspace.TrainingBalls.ChildAdded:Connect(function(ball)
    if not ball:GetAttribute("realBall") then
        return
    end
    if Config.particle_emitter then
        if not ball:FindFirstChild("ParticleEmitter") then
            local emitter = Instance.new("ParticleEmitter")
            emitter.Name = "ParticleEmitter"
            emitter.Rate = 100
            emitter.Lifetime = NumberRange.new(0.5, 1)
            emitter.Speed = NumberRange.new(0, 1)
            emitter.Size = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.5),
                NumberSequenceKeypoint.new(1, 0)
            })
            emitter.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 1)
            })
            emitter.Parent = ball
        end
    end
    if Config.glow_effect then
        if not ball:FindFirstChild("BallGlow") then
            local glow = Instance.new("PointLight")
            glow.Name = "BallGlow"
            glow.Range = 15
            glow.Brightness = 2
            glow.Parent = ball
        end
    end
end)

-- No Slow
ConnectionsManager['no_slow'] = RunService.PostSimulation:Connect(function()
    if not LocalPlayer.Character or not workspace.Alive:FindFirstChild(LocalPlayer.Name) or not LocalPlayer.Character:FindFirstChild('Humanoid') then
        return
    end
    local no_slow_enabled = Config.no_slow
    if not no_slow_enabled then
        return
    end
    if LocalPlayer.Character.Humanoid.WalkSpeed < 36 then
        LocalPlayer.Character.Humanoid.WalkSpeed = 36
    end
end)

-- Auto Rewards
task.defer(function()
    while task.wait(60) do
        local auto_rewards_enabled = Config.auto_rewards
        if auto_rewards_enabled then
            Player:claim_rewards()
        end
    end
end)

-- Night Mode
ConnectionsManager['night_mode'] = RunService.PostSimulation:Connect(function()
    local night_mode_enabled = Config.night_mode
    if not night_mode_enabled then
        if Lighting.ClockTime == 11.2 then
            return
        end
        create_animation(Lighting, TweenInfo.new(1.6), { ClockTime = 11.2 })
        return
    end
    if Lighting.ClockTime == 2.5 then
        return
    end
    create_animation(Lighting, TweenInfo.new(1.6), { ClockTime = 2.5 })
end)

-- Ball Handling
local is_respawned = false
workspace.Balls.ChildRemoved:Connect(function(child)
    is_respawned = false
    if child == AutoParry.ball.ball_entity then
        AutoParry.ball.ball_entity = nil
        AutoParry.ball.client_ball_entity = nil
        ConnectionsManager.disconnect('on_target_change')
        AutoParry.reset()
    end
end)

workspace.Balls.ChildAdded:Connect(function()
    if is_respawned then
        return
    end
    is_respawned = true
    local ball_properties = AutoParry.ball.properties
    ball_properties.respawn_time = tick()
    AutoParry.ball.ball_entity = AutoParry.get_ball()
    AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()
    ConnectionsManager['on_target_change'] = AutoParry.ball.ball_entity:GetAttributeChangedSignal('target'):Connect(function()
        if target == LocalPlayer.Name then
            ball_properties.cooldown = false
            return
        end
        ball_properties.cooldown = false
        ball_properties.old_speed = ball_properties.speed
        ball_properties.last_position = ball_properties.position
        ball_properties.parries += 1
        task.delay(0.25, function()
            if ball_properties.parries > 0 then
                ball_properties.parries -= 1
            end
        end)
    end)
end)

local function look_at(primary_part, position, delta, radians)
    local primary_part_pos = primary_part.Position
    local target_pos = position

    primary_part_pos = Vector3.new(primary_part_pos.X, 0, primary_part_pos.Z)
    target_pos = Vector3.new(target_pos.X, 0, target_pos.Z)

    local primary_part_look_vector = primary_part.CFrame.LookVector
    primary_part_look_vector = Vector3.new(primary_part_look_vector.X, 0, primary_part_look_vector.Z).unit

    local lerp_vector = primary_part_look_vector:Lerp((target_pos - primary_part_pos).unit, delta)

    if lerp_vector:Dot(primary_part_look_vector) < math.cos(math.rad(radians)) then
        lerp_vector = CFrame.Angles(0, math.rad(radians), 0) * primary_part_look_vector
    end

    primary_part.CFrame = CFrame.lookAt(primary_part.Position, primary_part.Position + lerp_vector)
end

ConnectionsManager['auto_parry_rotation'] = RunService.Stepped:Connect(function()
    local auto_parry_rotation_enabled = Config.auto_parry_rotation
    if not auto_parry_rotation_enabled or not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        return
    end
    local humanoid = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
    if not humanoid or humanoid.Health <= 0 or workspace.Dead:FindFirstChild(LocalPlayer.Name) then
        humanoid.AutoRotate = true
        return
    end
    local ball = AutoParry.get_ball()
    if not ball then
        return
    end
    local auto_parry_rotation_acuity_value = Config.auto_parry_rotation_acuity / 100
    local ball_properties = AutoParry.ball.properties
    if ball_properties.speed < 10 or ball_properties.distance < 20 + ball_properties.speed / 2 then
        look_at(LocalPlayer.Character.PrimaryPart, ball_properties.rotation, auto_parry_rotation_acuity_value / 2, 25)
        return
    end
    look_at(LocalPlayer.Character.PrimaryPart, ball_properties.rotation, auto_parry_rotation_acuity_value, 25)
end)

-- No Render
task.defer(function()
    workspace.Runtime.ChildAdded:Connect(function(child)
        local no_render_enabled = Config.no_render
        local smart_no_render_enabled = Config.smart_no_render
        local ability_vulnerability_enabled = Config.ability_vulnerability
        if no_render_enabled then
            if AutoParry.ball.properties.auto_spam then
                AutoParry:PerformParry()   
            end
            if smart_no_render_enabled and not ability_vulnerability_enabled and not AutoParry.ball.properties.auto_spam then
                LocalPlayer.PlayerScripts.EffectScripts.ClientFX.Enabled = true
                return
            end
            LocalPlayer.PlayerScripts.EffectScripts.ClientFX.Enabled = false
            if child.Name == 'Tornado' then
                return
            end
            Debris:AddItem(child, 0)
            return
        end
        LocalPlayer.PlayerScripts.EffectScripts.ClientFX.Enabled = true
    end)
end)


function ManualSpam()
    -- Services
    local CoreGui = game:GetService("CoreGui")
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    -- Variabel global
    if ManualSpamGui then
        local main = ManualSpamGui:FindFirstChild("Main")
        if main then
            -- Animasi keluar
            local shadow = main:FindFirstChild("Shadow")
            local indicator = main:FindFirstChild("Indicator")
            local speedLabel = main:FindFirstChild("SpeedLabel")
            local pc = main:FindFirstChild("PC")
            local spamButton = main:FindFirstChild("SpamButton")

            if main and shadow and indicator and speedLabel and pc and spamButton then
                local tweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
                local tweens = {}
                tweens[#tweens + 1] = TweenService:Create(shadow, tweenInfo, {ImageTransparency = 1, Size = UDim2.new(1, 10, 1, 10)})
                tweens[#tweens + 1] = TweenService:Create(main, tweenInfo, {
                    BackgroundTransparency = 1,
                    Size = UDim2.new(0.182, 0, 0.153, 0),
                    Position = UDim2.new(0.414, 0, 0.304, 0),
                    Rotation = -10
                })
                tweens[#tweens + 1] = TweenService:Create(indicator, tweenInfo, {BackgroundTransparency = 1})
                tweens[#tweens + 1] = TweenService:Create(speedLabel, tweenInfo, {TextTransparency = 1})
                tweens[#tweens + 1] = TweenService:Create(pc, tweenInfo, {TextTransparency = 1})
                tweens[#tweens + 1] = TweenService:Create(spamButton, tweenInfo, {BackgroundTransparency = 1, TextTransparency = 1})

                local mainFadeOut = tweens[2] -- Tween untuk main
                for i, tween in ipairs(tweens) do
                    if tween then
                        tween:Play()
                    else
                        warn("Debug: Tween #" .. i .. " is nil")
                    end
                end

                if mainFadeOut then
                    mainFadeOut.Completed:Connect(function()
                        if ManualSpamGui then
                            ManualSpamGui:Destroy()
                            ManualSpamGui = nil
                        end
                    end)
                else
                    warn("Debug: mainFadeOut is nil, destroying GUI immediately")
                    if ManualSpamGui then
                        ManualSpamGui:Destroy()
                        ManualSpamGui = nil
                    end
                end
            else
                warn("Debug: One or more GUI elements are missing: main=" .. tostring(main) .. ", shadow=" .. tostring(shadow) .. ", indicator=" .. tostring(indicator) .. ", speedLabel=" .. tostring(speedLabel) .. ", pc=" .. tostring(pc) .. ", spamButton=" .. tostring(spamButton))
                if ManualSpamGui then
                    ManualSpamGui:Destroy()
                    ManualSpamGui = nil
                end
            end
        else
            warn("Debug: Main frame is nil")
            if ManualSpamGui then
                ManualSpamGui:Destroy()
                ManualSpamGui = nil
            end
        end

        manualSpamEnabled = false
        Config.manual_spam = false
        if manualSpamConnection then
            manualSpamConnection:Disconnect()
            manualSpamConnection = nil
        end
        if manualSpamKeyConnection then
            manualSpamKeyConnection:Disconnect()
            manualSpamKeyConnection = nil
        end
        if WindUI and WindUI.Notify then
            WindUI:Notify({
                Title = "Manual Spam",
                Content = "Manual Spam disabled",
                Duration = 0.5,
                Icon = "swords"
            })
        else
            print("Manual Spam: Disabled")
        end
        return
    end

    -- Buat ScreenGui
    ManualSpamGui = Instance.new("ScreenGui")
    ManualSpamGui.Name = "ManualSpamGui"
    ManualSpamGui.Parent = CoreGui
    ManualSpamGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ManualSpamGui.ResetOnSpawn = false

    -- Buat Frame utama
    local Main = Instance.new("Frame")
    Main.Name = "Main"
    Main.Parent = ManualSpamGui
    Main.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    Main.BackgroundTransparency = 1
    Main.BorderSizePixel = 0
    Main.Position = UDim2.new(0.414, 0, 0.304, 0)
    Main.Size = UDim2.new(0.182, 0, 0.153, 0)
    Main.Rotation = -10
    Main.ClipsDescendants = true

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 12)
    UICorner.Parent = Main

    local UIStroke = Instance.new("UIStroke")
    UIStroke.Color = Color3.fromRGB(255, 50, 50)
    UIStroke.Thickness = 1.5
    UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    UIStroke.Parent = Main

    local UIGradient = Instance.new("UIGradient")
    UIGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 25)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(50, 50, 50)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 25))
    })
    UIGradient.Rotation = 45
    UIGradient.Parent = Main
    TweenService:Create(UIGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Offset = Vector2.new(1, 0)}):Play()

    local Shadow = Instance.new("ImageLabel")
    Shadow.Name = "Shadow"
    Shadow.Parent = Main
    Shadow.BackgroundTransparency = 1
    Shadow.Size = UDim2.new(1, 20, 1, 20)
    Shadow.Position = UDim2.new(0, -10, 0, -10)
    Shadow.Image = "rbxassetid://131604521"
    Shadow.ImageTransparency = 1
    Shadow.ZIndex = -1
    Shadow.ScaleType = Enum.ScaleType.Slice
    Shadow.SliceCenter = Rect.new(10, 10, 118, 118)

    local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint.AspectRatio = 1.667
    UIAspectRatioConstraint.Parent = Main

    -- Buat Indikator
    local Indicator = Instance.new("Frame")
    Indicator.Name = "Indicator"
    Indicator.Parent = Main
    Indicator.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
    Indicator.BackgroundTransparency = 1
    Indicator.BorderSizePixel = 0
    Indicator.Position = UDim2.new(0.028, 0, 0.073, 0)
    Indicator.Size = UDim2.new(0.072, 0, 0.12, 0)

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.CornerRadius = UDim.new(1, 0)
    UICorner_2.Parent = Indicator

    local IndicatorGradient = Instance.new("UIGradient")
    IndicatorGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 50, 50)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 100, 100)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 50, 50))
    })
    IndicatorGradient.Rotation = 45
    IndicatorGradient.Parent = Indicator
    TweenService:Create(IndicatorGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Offset = Vector2.new(1, 0)}):Play()

    local IndicatorGlow = Instance.new("UIStroke")
    IndicatorGlow.Color = Color3.fromRGB(255, 100, 100)
    IndicatorGlow.Thickness = 1
    IndicatorGlow.Transparency = 0.5
    IndicatorGlow.Parent = Indicator

    local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_2.Parent = Indicator

    -- Buat TextLabel untuk kecepatan parry
    local SpeedLabel = Instance.new("TextLabel")
    SpeedLabel.Name = "SpeedLabel"
    SpeedLabel.Parent = Main
    SpeedLabel.BackgroundTransparency = 1
    SpeedLabel.Position = UDim2.new(0.164, 0, 0.073, 0)
    SpeedLabel.Size = UDim2.new(0.668, 0, 0.173, 0)
    SpeedLabel.Font = Enum.Font.GothamBold
    SpeedLabel.Text = "Spam Speed: 0/s"
    SpeedLabel.TextColor3 = Color3.fromRGB(230, 230, 230)
    SpeedLabel.TextTransparency = 1
    SpeedLabel.TextScaled = true
    SpeedLabel.TextWrapped = true
    SpeedLabel.TextStrokeTransparency = 0.7
    SpeedLabel.TextStrokeColor3 = Color3.fromRGB(255, 215, 0)

    local SpeedLabelGradient = Instance.new("UIGradient")
    SpeedLabelGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 215, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
    })
    SpeedLabelGradient.Rotation = 45
    SpeedLabelGradient.Parent = SpeedLabel
    TweenService:Create(SpeedLabelGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Offset = Vector2.new(1, 0)}):Play()
    TweenService:Create(SpeedLabel, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {TextStrokeTransparency = 0.3}):Play()

    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint.MaxTextSize = 18
    UITextSizeConstraint.Parent = SpeedLabel

    -- Buat TextLabel untuk petunjuk tombol
    local PC = Instance.new("TextLabel")
    PC.Name = "PC"
    PC.Parent = Main
    PC.BackgroundTransparency = 1
    PC.Position = UDim2.new(0.164, 0, 0.827, 0)
    PC.Size = UDim2.new(0.452, 0, 0.173, 0)
    PC.Font = Enum.Font.Gotham
    PC.Text = "Press E to toggle"
    PC.TextColor3 = Color3.fromRGB(180, 180, 180)
    PC.TextTransparency = 1
    PC.TextScaled = true
    PC.TextWrapped = true
    PC.TextStrokeTransparency = 0.7
    PC.TextStrokeColor3 = Color3.fromRGB(255, 215, 0)

    local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint_2.MaxTextSize = 16
    UITextSizeConstraint_2.Parent = PC

    local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_3.AspectRatio = 4.346
    UIAspectRatioConstraint_3.Parent = PC

    -- Buat Tombol Spam
    local SpamButton = Instance.new("TextButton")
    SpamButton.Name = "SpamButton"
    SpamButton.Parent = Main
    SpamButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    SpamButton.BackgroundTransparency = 1
    SpamButton.BorderSizePixel = 0
    SpamButton.Position = UDim2.new(0.164, 0, 0.327, 0)
    SpamButton.Size = UDim2.new(0.668, 0, 0.347, 0)
    SpamButton.Font = Enum.Font.GothamBold
    SpamButton.Text = "SPAM"
    SpamButton.TextColor3 = Color3.fromRGB(230, 230, 230)
    SpamButton.TextTransparency = 1
    SpamButton.TextScaled = true
    SpamButton.TextWrapped = true
    SpamButton.TextStrokeTransparency = 0.7
    SpamButton.TextStrokeColor3 = Color3.fromRGB(255, 215, 0)

    local UICorner_3 = Instance.new("UICorner")
    UICorner_3.CornerRadius = UDim.new(0, 8)
    UICorner_3.Parent = SpamButton

    local UIStroke_2 = Instance.new("UIStroke")
    UIStroke_2.Color = Color3.fromRGB(255, 50, 50)
    UIStroke_2.Thickness = 1.5
    UIStroke_2.Parent = SpamButton

    local ButtonGradient = Instance.new("UIGradient")
    ButtonGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(45, 45, 45)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(70, 70, 70)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(45, 45, 45))
    })
    ButtonGradient.Rotation = 45
    ButtonGradient.Parent = SpamButton
    TweenService:Create(ButtonGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Offset = Vector2.new(1, 0)}):Play()

    local UITextSizeConstraint_3 = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint_3.MaxTextSize = 26
    UITextSizeConstraint_3.Parent = SpamButton

    local UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_4.AspectRatio = 3.212
    UIAspectRatioConstraint_4.Parent = SpamButton

    
    local tweenInfo = TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
    TweenService:Create(Shadow, tweenInfo, {ImageTransparency = 0.7, Size = UDim2.new(1, 20, 1, 20)}):Play()
    TweenService:Create(Main, tweenInfo, {
        BackgroundTransparency = 0,
        Size = UDim2.new(0.227, 0, 0.191, 0),
        Position = UDim2.new(0.414, 0, 0.404, 0),
        Rotation = 0
    }):Play()
    TweenService:Create(Indicator, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0.2), {BackgroundTransparency = 0}):Play()
    TweenService:Create(SpeedLabel, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0.3), {TextTransparency = 0}):Play()
    TweenService:Create(PC, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0.3), {TextTransparency = 0}):Play()
    TweenService:Create(SpamButton, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0.4), {BackgroundTransparency = 0, TextTransparency = 0}):Play()

    -- Animasi dan pengaturan kecepatan parry
    local parrySpeed = 299
    local parryCount = 0
    local lastUpdate = tick()

    local function updateSpeedLabel()
        local elapsed = tick() - lastUpdate
        if elapsed >= 0.1 then
            local speed = math.round(parryCount / elapsed)
            SpeedLabel.Text = "Spam Speed: " .. speed .. "/s"
            parryCount = 0
            lastUpdate = tick()

            local tweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            SpeedLabel.TextTransparency = 0.4
            TweenService:Create(SpeedLabel, tweenInfo, {TextTransparency = 0}):Play()
        end
    end

    local function pulseIndicator()
        local tweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
        TweenService:Create(Indicator, tweenInfo, {Size = UDim2.new(0.08, 0, 0.133, 0)}):Play()
        TweenService:Create(Indicator, tweenInfo, {BackgroundTransparency = 0.2}):Play()
        TweenService:Create(IndicatorGlow, tweenInfo, {Transparency = 0.3}):Play()
    end

    local function toggleSpam()
        manualSpamEnabled = not manualSpamEnabled
        Config.manual_spam = manualSpamEnabled

        if manualSpamConnection then
            manualSpamConnection:Disconnect()
            manualSpamConnection = nil
        end

        if manualSpamEnabled then
            UIStroke.Color = Color3.fromRGB(50, 255, 50)
            UIStroke_2.Color = Color3.fromRGB(50, 255, 50)
            Indicator.BackgroundColor3 = Color3.fromRGB(50, 255, 50)
            IndicatorGlow.Color = Color3.fromRGB(100, 255, 100)
            IndicatorGradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 255, 50)),
                ColorSequenceKeypoint.new(0.5, Color3.fromRGB(100, 255, 100)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 255, 50))
            })
            pulseIndicator()

            local lastParry = 0
            manualSpamConnection = RunService.Heartbeat:Connect(function(deltaTime)
                if not manualSpamEnabled then return end
                local parriesPerFrame = parrySpeed * deltaTime
                local parryCountThisFrame = math.floor(parriesPerFrame)
                local remainder = parriesPerFrame - parryCountThisFrame
                if remainder >= math.random() then
                    parryCountThisFrame = parryCountThisFrame + 1
                end

                for i = 1, parryCountThisFrame do
                    local success, err = pcall(function()
                        if AutoParry and AutoParry.ExecuteParry and type(AutoParry.ExecuteParry) == "function" then
                            task.spawn(AutoParry:PerformParry())
                        else
                            warn("AutoParry or ExecuteParry is not a valid function")
                        end
                    end)
                    if success then
                        parryCount = parryCount + 1
                    else
                        warn("Error in AutoParry:ExecuteParry:", err)
                    end
                end
                updateSpeedLabel()
            end)
        else
            UIStroke.Color = Color3.fromRGB(255, 50, 50)
            UIStroke_2.Color = Color3.fromRGB(255, 50, 50)
            Indicator.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
            IndicatorGlow.Color = Color3.fromRGB(255, 100, 100)
            IndicatorGradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 50, 50)),
                ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 100, 100)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 50, 50))
            })
            Indicator.Size = UDim2.new(0.072, 0, 0.12, 0)
            Indicator.BackgroundTransparency = 0
            IndicatorGlow.Transparency = 0.5
        end

        local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        TweenService:Create(SpamButton, tweenInfo, {
            Size = manualSpamEnabled and UDim2.new(0.7, 0, 0.36, 0) or UDim2.new(0.668, 0, 0.347, 0),
            BackgroundColor3 = manualSpamEnabled and Color3.fromRGB(50, 50, 50) or Color3.fromRGB(45, 45, 45)
        }):Play()
        TweenService:Create(UIStroke_2, tweenInfo, {
            Color = manualSpamEnabled and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        }):Play()

        if WindUI and WindUI.Notify then
            WindUI:Notify({
                Title = "Manual Spam",
                Content = "Manual Spam " .. (manualSpamEnabled and "enabled" or "disabled"),
                Duration = 0.5,
                Icon = "swords"
            })
        else
            print("Manual Spam: " .. (manualSpamEnabled and "enabled" or "disabled"))
        end
    end

    -- Animasi hover
    SpamButton.MouseEnter:Connect(function()
        local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        TweenService:Create(SpamButton, tweenInfo, {
            Size = UDim2.new(0.7, 0, 0.36, 0),
            BackgroundColor3 = Color3.fromRGB(55, 55, 55)
        }):Play()
        TweenService:Create(UIStroke_2, tweenInfo, {
            Thickness = 2,
            Color = manualSpamEnabled and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
        }):Play()
    end)

    SpamButton.MouseLeave:Connect(function()
        local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        TweenService:Create(SpamButton, tweenInfo, {
            Size = UDim2.new(0.668, 0, 0.347, 0),
            BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        }):Play()
        TweenService:Create(UIStroke_2, tweenInfo, {
            Thickness = 1.5,
            Color = manualSpamEnabled and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        }):Play()
    end)

    SpamButton.MouseButton1Down:Connect(function()
        local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
        TweenService:Create(SpamButton, tweenInfo, {Size = UDim2.new(0.65, 0, 0.34, 0)}):Play()
    end)

    SpamButton.MouseButton1Up:Connect(function()
        local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        TweenService:Create(SpamButton, tweenInfo, {Size = UDim2.new(0.668, 0, 0.347, 0)}):Play()
    end)

    SpamButton.MouseButton1Click:Connect(toggleSpam)

    manualSpamKeyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.E then
            toggleSpam()
        end
    end)

    ManualSpamGui.Destroying:Connect(function()
        if manualSpamKeyConnection then
            manualSpamKeyConnection:Disconnect()
            manualSpamKeyConnection = nil
        end
        if manualSpamConnection then
            manualSpamConnection:Disconnect()
            manualSpamConnection = nil
        end
    end)

    -- Draggable GUI
    local gui = Main
    local dragging
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        local newPosition = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
        TweenService:Create(gui, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Position = newPosition}):Play()
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input == dragInput then
            update(input)
        end
    end)

    if WindUI and WindUI.Notify then
        WindUI:Notify({
            Title = "Manual Spam",
            Content = "Manual Spam GUI enabled",
            Duration = 0.5,
            Icon = "swords"
        })
    else
        print("Manual Spam: GUI enabled")
    end
end

task.delay(20, function()
    local player_ping = Player.Entity.properties.ping
    if player_ping > 100 and player_ping < 200 then
        WindUI:Notify({
            Title = "â‰ï¸[Detect Warning]â™¨ï¸",
            Content = "Low connection speed, delays may occur.",
            Duration = 15,
        })
    elseif player_ping >= 200 then
        WindUI:Notify({
            Title = "â›”[Detect Critical Warning]âš ï¸",
            Content = "Critically slow connection speed, delays ensured.",
            Duration = 15,
        })
    end
end)